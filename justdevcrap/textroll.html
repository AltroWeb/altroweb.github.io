<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Textroll - Web Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="textroll.png">
    <!-- Content Security Policy (CSP) Meta Tag -->
    <!-- This CSP is designed for stricter security, preventing 'unsafe-eval' for scripts. -->
    <!-- 'self': Allows resources from the same origin as the document. -->
    <!-- 'unsafe-inline': Still allowed for styles and necessary inline scripts (e.g., event handlers). -->
    <!--                  For ultimate security, inline scripts should use nonces or hashes. -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' https://cdn.tailwindcss.com https://www.gstatic.com https://www.gstatic.com/firebasejs/ 'unsafe-inline';
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.tailwindcss.com;
        img-src 'self' data: https://placehold.co;
        font-src 'self' https://fonts.gstatic.com;
        connect-src 'self' https://firestore.googleapis.com https://securetoken.googleapis.com https://identitytoolkit.googleapis.com https://www.googleapis.com;
        frame-src 'self' https://textroll-79302.firebaseapp.com https://*.firebaseapp.com https://*.firebaseui.com https://*.google.com;
        object-src 'none';
        base-uri 'self';
        form-action 'self';
    ">
    <style>
        /* CSS Variables for Theming */
        :root {
            /* Light Mode Colors */
            --bg-gradient-start: #8b5cf6; /* purple-500 */
            --bg-gradient-end: #4f46e5;   /* indigo-600 */
            --text-color-primary: #374151; /* gray-800 */
            --text-color-secondary: #4b5563; /* gray-600 */
            --card-bg: #fff;
            --header-text: #4338ca; /* indigo-700 */
            --room-code-text: #9333ea; /* purple-600 */
            --border-color: #e5e7eb; /* gray-200 */
            --input-border: #d1d5db; /* gray-300 */
            --input-bg-disabled: #f3f4f6; /* gray-100 */
            --button-bg-indigo: #4f46e5; /* indigo-600 */
            --button-hover-indigo: #4338ca; /* indigo-700 */
            --button-bg-purple: #9333ea; /* purple-600 */
            --button-hover-purple: #7e22ce; /* purple-700 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #2563eb; /* blue-600 */
            --button-hover-blue: #1d4ed8; /* blue-700 */
            --button-disabled-bg: #9ca3af; /* gray-400 */
            --participant-bg-you: #e0e7ff; /* indigo-100 */
            --participant-text-you: #4338ca; /* indigo-700 */
            --participant-bg-other: #f3f4f6; /* gray-100 */
            --message-bg-you: #6366f1; /* indigo-500 */
            --message-bg-other: #e5e7eb; /* gray-200 */
            --message-text-you: #fff;
            --message-text-other: #1f2937; /* gray-800 */
            --message-timestamp-opacity: 0.6;
            --chat-bg: #f9fafb; /* gray-50 */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-color-dark: rgba(0, 0, 0, 0.04);
            --modal-shadow-color: rgba(0, 0, 0, 0.25);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.06);
            --focus-ring-indigo: rgba(99, 102, 241, 0.5);
            --focus-ring-purple: rgba(168, 85, 247, 0.75);
            --focus-ring-red: rgba(239, 68, 68, 0.75);
            --focus-ring-blue: rgba(59, 130, 246, 0.5);
            --focus-ring-gray: rgba(156, 163, 175, 0.75);
            --button-shadow-offset: 0 4px 6px -1px;
            --button-shadow-blur: 0 2px 4px -1px;
        }

        /* Dark Mode Colors */
        .dark-mode {
            --bg-gradient-start: #1f2937; /* dark gray */
            --bg-gradient-end: #0f172a;   /* darker blue-gray */
            --text-color-primary: #e5e7eb; /* gray-200 */
            --text-color-secondary: #d1d5db; /* gray-300 */
            --card-bg: #374151; /* gray-700 */
            --header-text: #a78bfa; /* purple-400 */
            --room-code-text: #c084fc; /* purple-500 */
            --border-color: #4b5563; /* gray-600 */
            --input-border: #6b7280; /* gray-500 */
            --input-bg-disabled: #4b5563; /* gray-600 */
            --button-bg-indigo: #6366f1; /* indigo-500 */
            --button-hover-indigo: #4f46e5; /* indigo-600 */
            --button-bg-purple: #a855f7; /* purple-500 */
            --button-hover-purple: #9333ea; /* purple-600 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #3b82f6; /* blue-500 */
            --button-hover-blue: #2563eb; /* blue-600 */
            --button-disabled-bg: #4b5563; /* gray-600 */
            --participant-bg-you: #4f46e5; /* indigo-600 */
            --participant-text-you: #e0e7ff; /* indigo-100 */
            --participant-bg-other: #4b5563; /* gray-600 */
            --message-bg-you: #4f46e5; /* indigo-600 */
            --message-bg-other: #4b5563; /* gray-600 */
            --message-text-you: #e5e7eb;
            --message-text-other: #e5e7eb;
            --message-timestamp-opacity: 0.7;
            --chat-bg: #374151; /* gray-700 */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-color-dark: rgba(0, 0, 0, 0.2);
            --modal-shadow-color: rgba(0, 0, 0, 0.4);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.2);
        }

        /* Universal Font and Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth dark mode transition */
        }

        /* All elements inherit font, remove default button borders */
        * {
            font-family: inherit;
            box-sizing: border-box; /* Ensure consistent box model */
        }
        button {
            border: none; /* Remove default button borders */
            outline: none; /* Remove default focus outline */
            cursor: pointer;
        }

        /* Custom scrollbar for chat messages */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: var(--input-bg-disabled);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Animations */
        @keyframes scaleIn {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        .animate-scaleIn {
            animation: scaleIn 0.3s ease-out forwards;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #loading-screen.hidden {
            display: none;
        }

        /* Modal Styles */
        #modal-overlay, #privacy-policy-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(107, 114, 128, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        #modal-overlay.hidden, #privacy-policy-modal-overlay.hidden {
            display: none;
        }
        #modal-content, #privacy-policy-modal-content {
            background-color: var(--card-bg);
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px var(--modal-shadow-color), 0 10px 10px -5px var(--modal-shadow-color-dark);
            padding: 1.5rem;
            max-width: 24rem;
            width: 100%;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.3s ease-in-out;
            color: var(--text-color-primary);
        }
        #privacy-policy-modal-content {
            max-width: 36rem; /* Wider for policy text */
            max-height: 80vh; /* Limit height to enable scrolling */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            border-radius: 0.75rem; /* Rounded corners for the policy modal */
        }
        #modal-content.show, #privacy-policy-modal-content.show {
            transform: scale(1);
            opacity: 1;
        }
        #modal-title, #privacy-policy-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 1rem;
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        #modal-message {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
        }
        #privacy-policy-text {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
            flex-grow: 1; /* Allow content to grow and take available space */
            overflow-y: auto; /* Enable vertical scrolling for content */
            padding-right: 0.5rem; /* Add some padding for scrollbar */
        }
        #modal-buttons, #privacy-policy-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
            padding-top: 0.5rem; /* Space between content and buttons */
        }
        #modal-cancel-btn, #privacy-policy-close-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            color: var(--text-color-primary);
            background-color: var(--border-color);
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-cancel-btn:hover, #privacy-policy-close-btn:hover {
            background-color: #d1d5db;
        }
        .dark-mode #modal-cancel-btn:hover, .dark-mode #privacy-policy-close-btn:hover {
            background-color: #6b7280;
        }
        #modal-cancel-btn.hidden {
            display: none;
        }
        #modal-ok-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            background-color: var(--button-bg-blue);
            color: #fff;
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-ok-btn:hover {
            background-color: var(--button-hover-blue);
        }
        /* Password input group and error */
        #modal-password-input-group {
            margin-bottom: 1.5rem; /* Spacing below the group */
            padding: 0.75rem; /* Internal padding for the group */
            border: 1px solid var(--input-border); /* Subtle border */
            border-radius: 0.5rem; /* Rounded corners */
            background-color: var(--input-bg-disabled); /* Light background */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .dark-mode #modal-password-input-group {
            background-color: var(--border-color); /* Darker background for dark mode */
        }
        #modal-password-input-group label {
            margin-bottom: 0.75rem; /* More space below label */
            padding-left: 0.25rem; /* Align text with input */
        }
        #modal-password-input {
            width: 100%;
            padding: 0.8rem; /* Slightly more padding for input field */
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
            font-size: 1rem; /* Ensure good readability */
        }
        #modal-password-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px var(--focus-ring-indigo); /* Slightly thicker focus ring */
            border-color: transparent;
        }
        #modal-password-error {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem;
            margin-top: 0.5rem;
            text-align: left;
            display: block; /* Ensure it takes its own line */
        }
        /* IMPORTANT: Force hidden elements to be display: none */
        .hidden {
            display: none !important;
        }


        /* Focus styles for buttons */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-blue);
        }
        #modal-cancel-btn:focus, #privacy-policy-close-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-gray);
        }
        #leave-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red);
        }
        #create-room-btn:focus, #send-message-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
        }
        #join-room-btn:focus, #join-random-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-purple);
        }

        /* Dark Mode Toggle Button */
        .dark-mode-toggle-container {
            /* Removed absolute positioning for chat screen, now part of flex header */
            z-index: 10; /* Ensure it's above other elements in the card */
            display: flex; /* To center emoji */
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Explicitly prevent shrinking */
        }
        /* Specific adjustment for the toggle button within the home screen */
        #home-screen .dark-mode-toggle-container {
           margin-top: 2rem;
        }
        #dark-mode-toggle, #dark-mode-toggle-chat {
            background-color: var(--card-bg);
            color: var(--text-color-primary); /* Icon color */
            border: none;
            border-radius: 9999px;
            padding: 0.75rem;
            font-size: 1.25rem; /* Controls emoji size */
            cursor: pointer;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        }
        #dark-mode-toggle:hover, #dark-mode-toggle-chat:hover {
            transform: scale(1.1);
        }
        #dark-mode-toggle:active, #dark-mode-toggle-chat:active {
            transform: scale(0.95);
        }

        /* Text Icon specific styles */
        .icon-moon-text { display: block; }
        .icon-sun-text { display: none; }
        .dark-mode .icon-moon-text { display: none; }
        .dark-mode .icon-sun-text { display: block; }


        /* Home Screen */
        #home-screen {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 28rem;
            text-align: center;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
            position: relative; /* For dark mode toggle positioning */
        }
        #home-screen.hidden {
            display: none;
        }
        #home-screen h1 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--header-text);
            margin-bottom: 1.5rem;
            letter-spacing: -0.025em;
        }
        #home-screen p {
            color: var(--text-color-secondary);
            margin-bottom: 2rem;
            font-size: 1.125rem;
        }
        #home-screen .input-group {
            margin-bottom: 1.5rem;
        }
        #home-screen .input-group label {
            display: block;
            text-align: left;
            color: var(--text-color-primary);
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        #home-screen input[type="text"],
        #home-screen input[type="number"], /* Added for max participants */
        #home-screen input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #home-screen input[type="text"]:focus,
        #home-screen input[type="number"]:focus,
        #home-screen input[type="password"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #home-screen #create-password-input-group.hidden {
            display: none;
        }
        #home-screen .button-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #home-screen button {
            width: 100%;
            padding: 0.75rem 1.5rem;
            color: #fff;
            font-weight: 600;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        #home-screen button:hover {
            transform: scale(1.05);
        }
        #create-room-btn {
            background-color: var(--button-bg-indigo);
        }
        #create-room-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #join-room-btn, #join-random-room-btn { /* Apply purple to both join buttons */
            background-color: var(--button-bg-purple);
            color: #fff; /* Ensure text is white for contrast */
        }
        #join-room-btn:hover, #join-random-room-btn:hover {
            background-color: var(--button-hover-purple);
        }
        #user-id-display {
            font-size: 0.75rem;
            color: var(--text-color-secondary);
            margin-top: 1.5rem;
        }

        /* Chat Room Screen */
        #chat-room-screen {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 42rem;
            display: flex;
            flex-direction: column;
            /* REVERTED: Fixed height for consistent scrolling */
            height: 85vh; 
            position: relative; /* Ensure it's relative as requested */
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
        }
        #chat-room-screen.hidden {
            display: none;
        }
        #chat-room-screen .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            gap: 0.25rem; /* Adjusted gap for tighter fit */
            flex-wrap: nowrap; /* Prevent wrapping/stacking on all screens */
        }
        /* Room Code: To appear fully and scale dynamically */
        #chat-room-screen h2 {
            font-size: clamp(1rem, 4vw, 1.875rem); /* Dynamically scales font size based on viewport width */
            font-weight: 700;
            color: var(--header-text);
            flex-grow: 1; /* Allows it to grow and take available space */
            flex-shrink: 1; /* Allow it to shrink if needed */
            text-align: center; /* Center the room code text */
            min-width: 0; /* Allows h2 to shrink down to 0 if necessary */
            /* REMOVED: overflow: hidden;, text-overflow: ellipsis;, white-space: nowrap; */
        }
        #current-room-code {
            color: var(--room-code-text);
        }
        /* Leave and Permanent Buttons: Text should appear with "..." if too large */
        #leave-room-btn {
            padding: 0.4rem 0.8rem; /* Smaller padding for compact size */
            font-size: 0.875rem; /* Smaller font size */
            background-color: var(--button-bg-red);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent button from shrinking */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #leave-room-btn:hover {
            background-color: var(--button-hover-red);
        }

        /* NEW: Styling for Permanent Mode Button */
        #toggle-permanent-mode-btn {
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.875rem; /* Smaller font size */
            background-color: var(--button-bg-blue);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent button from shrinking */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #toggle-permanent-mode-btn:hover {
            background-color: var(--button-hover-blue);
        }
        #toggle-permanent-mode-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* NEW: Styling for Permanent Room Indicator */
        #permanent-room-indicator {
            font-size: 0.75rem; /* Even smaller font */
            font-weight: 600;
            color: var(--room-code-text); /* Using room code text color for consistency */
            background-color: var(--participant-bg-you); /* Light background for visibility */
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
            white-space: nowrap; /* Prevent wrapping */
            flex-shrink: 0; /* Prevent from shrinking */
        }
        .dark-mode #permanent-room-indicator {
            background-color: var(--participant-bg-other);
        }


        #chat-room-screen .participants-section {
            margin-bottom: 1rem;
        }
        #chat-room-screen .participants-section h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 0.5rem;
        }
        #participants-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-color-secondary);
        }
        #participants-list span { /* This is the container for username and possibly remove button */
            display: flex; /* Use flex to align username and button */
            align-items: center; /* Vertically align items */
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
        }
        #participants-list span.bg-indigo-100 {
            background-color: var(--participant-bg-you);
            color: var(--participant-text-you);
            font-weight: 500;
        }
        #participants-list span.bg-gray-100 {
            background-color: var(--participant-bg-other);
            color: var(--text-color-primary);
        }
        .remove-participant-btn {
            background-color: transparent;
            color: var(--button-bg-red);
            border: none;
            padding: 0.1rem 0.3rem; /* Adjust padding for better visual */
            font-size: 0.9rem; /* Adjust size */
            font-weight: bold;
            border-radius: 0.25rem;
            margin-left: 0.5rem; /* Space between username and button */
            cursor: pointer;
            line-height: 1; /* Helps with vertical alignment */
        }
        .remove-participant-btn:hover {
            background-color: var(--button-hover-red);
            color: white;
        }
        .remove-participant-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red); /* Specific focus for remove button */
        }


        #messages-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: var(--chat-bg);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease;
        }
        #no-messages-yet {
            text-align: center;
            color: var(--text-color-secondary);
            font-style: italic;
            margin-top: 1rem;
        }
        #no-messages-yet.hidden {
            display: none;
        }

        .message-item {
            display: flex;
            margin-bottom: 0.75rem;
        }
        .message-item.justify-end {
            justify-content: flex-end;
        }
        .message-item.justify-start {
            justify-content: flex-start;
        }
        .message-content {
            max-width: 70%;
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .message-item.justify-end .message-content {
            background-color: var(--message-bg-you);
            color: var(--message-text-you);
            border-bottom-right-radius: 0;
        }
        .message-item.justify-start .message-content {
            background-color: var(--message-bg-other);
            color: var(--message-text-other);
            border-bottom-left-radius: 0;
        }
        .message-content .sender-info {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            opacity: 0.8;
        }
        .message-content p {
            font-size: 0.875rem;
            word-break: break-word;
        }
        .message-content .timestamp {
            text-align: right;
            font-size: 0.75rem;
            opacity: var(--message-timestamp-opacity);
            margin-top: 0.25rem;
        }

        #message-form {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        #new-message-input {
            flex-grow: 1;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #new-message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #new-message-input:disabled {
            background-color: var(--input-bg-disabled);
            cursor: not-allowed;
            color: var(--text-color-secondary);
        }
        #send-message-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--button-bg-indigo);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
        }
        #send-message-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #send-message-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Footnote */
        #app-footnote {
            margin-top: 2rem; /* Spacing from the main content */
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7); /* Light white for contrast on gradient background */
            text-align: center;
            padding-bottom: 1rem; /* Ensure it's not right at the bottom edge */
        }
        #app-footnote a {
            color: inherit; /* Inherit color from parent */
            text-decoration: underline;
            
            cursor: pointer;
        }
        #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        .dark-mode #app-footnote {
            color: rgba(255, 255, 255, 0.5); /* Slightly darker for dark mode */
        }
        .dark-mode #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Mode Selection Styles */
        #mode-selection {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            width: 100%; /* Ensure it takes full width of parent */
        }
        #mode-selection button {
            flex: 1;
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            background-color: var(--card-bg); /* Default background */
            color: var(--text-color-primary); /* Default text color */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #mode-selection button.active {
            background-color: var(--button-bg-purple); /* Changed to purple */
            color: #fff;
            box-shadow: var(--button-shadow-offset) var(--button-bg-purple), var(--button-shadow-blur) var(--button-bg-purple); /* Changed to purple */
        }
        #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Lighter hover for non-active */
        }
        .dark-mode #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Darker hover for non-active */
        }

        /* Mode Containers */
        #default-mode-container,
        #random-mode-container {
            width: 100%;
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            gap: 1.5rem; /* Consistent spacing between input groups */
        }
        #default-mode-container.hidden,
        #random-mode-container.hidden {
            display: none;
        }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem; /* Re-added padding for overall layout */
                align-items: center; /* Re-centered content */
                justify-content: center; /* Re-centered content */
            }
            #home-screen {
                margin-top: 0; /* Remove specific mobile margins if body is centered */
                margin-bottom: 0;
            }
            #chat-room-screen {
                padding: 1.5rem;
                max-width: 100%;
                border-radius: 0.75rem; /* Restore border-radius */
                /* Reverted to original height and positioning for mobile */
                height: 85vh; /* Keep consistent height */
                position: relative; /* Keep consistent positioning */
            }
            #chat-room-screen .header {
                /* REVERTED: Keep header items in a row, prevent stacking */
                flex-direction: row; /* Ensure row direction */
                align-items: center; /* Vertically align items */
                flex-wrap: nowrap; /* Prevent wrapping/stacking */
                gap: 0.25rem; /* Keep original gap */
            }
            #chat-room-screen .header .dark-mode-toggle-container {
                /* REVERTED: Remove align-self, let flexbox handle it */
                align-self: auto; 
                margin-right: 0;
            }
            #chat-room-screen h2 {
                /* REMOVED: font-size: 1.5rem; */
                text-align: center; /* Keep room code centered */
                min-width: unset; 
            }
            #leave-room-btn, #toggle-permanent-mode-btn {
                /* REVERTED: Remove full width, let flex-shrink handle it */
                width: auto; 
                padding: 0.4rem 0.8rem; /* Keep smaller padding for touch targets */
                font-size: 0.875rem;
            }
            #permanent-room-indicator {
                align-self: center; /* Center the indicator if stacked */
            }

            #home-screen h1 {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }
            #home-screen p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }
            #home-screen .input-group {
                margin-bottom: 1rem;
            }
            #home-screen .button-group {
                gap: 0.75rem;
            }
            
            #chat-room-screen .participants-section h3 {
                font-size: 1rem;
            }
            #participants-list span {
                font-size: 0.75rem;
                padding: 0.2rem 0.6rem;
            }
            .remove-participant-btn {
                font-size: 0.8rem; /* Slightly smaller on mobile */
                padding: 0.1rem 0.25rem;
            }
            .message-content {
                max-width: 85%;
                padding: 0.6rem;
            }
            .message-content .sender-info, .message-content p, .message-content .timestamp {
                font-size: 0.8rem;
            }
            #message-form {
                flex-direction: column;
                gap: 0.5rem;
            }
            #new-message-input, #send-message-btn {
                width: 100%;
                padding: 0.6rem;
            }
            #send-message-btn {
                padding: 0.6rem 1rem;
            }
            /* Adjust dark mode toggle position for mobile in chat screen */
            #chat-room-screen .header .dark-mode-toggle-container {
                /* No specific right/left needed, flexbox handles it */
                margin-right: 0.5rem; /* Small margin to the right of the toggle */
            }
            #mode-selection {
                flex-direction: column;
            }
            #default-mode-container,
            #random-mode-container {
                gap: 1rem; /* Smaller gap on mobile */
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="loading-screen">
        <div class="text-2xl font-bold">Loading Textroll...</div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-content">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="input-group hidden" id="modal-password-input-group">
                <label for="modal-password-input" class="hidden">Enter password:</label>
                <input type="password" id="modal-password-input" placeholder="Room password" />
                <span id="modal-password-error" class="hidden"></span> </div>
            <div id="modal-buttons">
                <button id="modal-cancel-btn" class="hidden">
                    Cancel
                </button>
                <button id="modal-ok-btn">
                    OK
                </button>
            </div>
        </div>
    </div>

    <div id="privacy-policy-modal-overlay" class="hidden">
        <div id="privacy-policy-modal-content">
            <h3 id="privacy-policy-title">Privacy Policy for Textroll Web Chat</h3>
            <div id="privacy-policy-text">
                <p><strong>1. Data Collection:</strong> We collect your chosen username and a unique user ID generated by Firebase Authentication for the purpose of identifying you within chat rooms. Room codes and messages sent within rooms are stored temporarily on our Firebase Firestore database to facilitate real-time communication. We do NOT collect any personally identifiable information beyond your chosen username and the Firebase-generated user ID.</p>
                <p><strong>2. Data Usage:</strong> Your username and user ID are used solely to display your identity in chat rooms and manage your participation. Room data (including messages) is used to enable chat functionality. We do not use your data for advertising, tracking, or any other commercial purposes.</p>
                <p><strong>3. Data Storage and Deletion:</strong> Chat rooms and their messages are designed to be temporary. Rooms are automatically deleted if they become empty (no participants) or if there is no activity (no messages sent or users joining/leaving) for 15 minutes. Permanent rooms, if enabled by the host and secured with a password, will persist even when empty, but will be deleted after 1 week of inactivity (no messages sent or users joining/leaving).</p>
                <p><strong>4. Security:</strong> We use Firebase Firestore, which provides robust security features. However, please remember that random and unmoderated chat rooms inherently carry risks. Do NOT share sensitive personal information (e.g., real name, address, phone password, financial details) in Textroll chat rooms.</p>
                <p><strong>5. Third-Party Services:</strong> This app uses Firebase (Google) for backend services (authentication, database). Their privacy policies apply to the data they handle. We do not integrate with any other third-party analytics or advertising services.</p>
                <p><strong>6. Changes to this Policy:</strong> We may update this privacy policy from time to time. Any changes will be reflected directly within the app. Your continued use of the app after such changes constitutes your acceptance of the new policy.</p>
                <p><strong>7. Contact:</strong> For any privacy-related questions, please contact us through the platform where you accessed this application.</p>
            </div>
            <div id="privacy-policy-buttons">
                <button id="privacy-policy-close-btn">
                    Close
                </button>
            </div>
        </div>
    </div>


    <div id="home-screen" class="hidden">
        
        <h1>Textroll</h1>
        <p>
            Connect and chat anonymously with friends or strangers!
        </p>
        <div class="dark-mode-toggle-container">
            <button id="dark-mode-toggle">
                <span class="icon-moon-text">üåô</span>
                <span class="icon-sun-text">‚òÄÔ∏è</span>
                </button>
        </div>
        <br><br>

        <div id="mode-selection">
            <button id="default-mode-btn" class="active">Default Mode</button>
            <button id="random-mode-btn">Random Mode</button>
        </div>

        <div id="default-mode-container">
            <div class="input-group">
                <label for="username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="username-input"
                    placeholder="e.g., ChatMaster"
                    maxlength="15"
                />
            </div>

            <div class="input-group" id="create-password-input-group" style="display: none;">
                <label for="create-password-input">
                    Set a room password (optional):
                </label>
                <input
                    type="password"
                    id="create-password-input"
                    placeholder="Leave blank for no password"
                    maxlength="20"
                />
            </div>

            <div class="input-group">
                <label for="max-participants-input">
                    Max Participants (2-10):
                </label>
                <input
                    type="number"
                    id="max-participants-input"
                    value="4"
                    min="2"
                    max="10"
                />
            </div>

            <div class="input-group">
                <label for="room-code-input">
                    Or enter a room code to join:
                </label>
                <input
                    type="text"
                    id="room-code-input"
                    placeholder="e.g., ABCDEF"
                    maxlength="6"
                />
            </div>

            <div class="button-group">
                <button id="create-room-btn">
                    Create New Room
                </button>
                <button id="join-room-btn">
                    Join Room
                </button>
            </div>
        </div>

        <div id="random-mode-container" class="hidden">
            <div class="input-group">
                <label for="random-username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="random-username-input"
                    placeholder="e.g., AnonymousChatter"
                    maxlength="15"
                />
            </div>
            <div class="button-group">
                <button id="join-random-room-btn">
                    Join Random Room
                </button>
            </div>
        </div>

        <p id="user-id-display"></p>
    </div>

    <div id="chat-room-screen" class="hidden">
        <div class="header">
            <div class="dark-mode-toggle-container">
                <button id="dark-mode-toggle-chat">
                    <span class="icon-moon-text">üåô</span>
                    <span class="icon-sun-text">‚òÄÔ∏è</span>
                </button>
            </div>
            <h2>
                Room: <span id="current-room-code"></span>
                <!-- NEW: Permanent Room Indicator -->
                <span id="permanent-room-indicator" class="hidden">PUBLIC ROOM</span>
            </h2>
            <!-- NEW: Toggle Permanent Mode Button -->
            <button id="toggle-permanent-mode-btn" class="hidden">
                Perma
            </button>
            <button id="leave-room-btn">
                Leave
            </button>
        </div>

        <div class="participants-section">
            <h3>Participants (<span id="participants-count">0</span>/<span id="max-participants-display">4</span>):</h3>
            <div id="participants-list">
                </div>
        </div>

        <div id="messages-container" class="custom-scrollbar">
            <p id="no-messages-yet" class="hidden">No messages yet. Start the conversation!</p>
            <div id="messages-end-ref"></div> </div>

        <form id="message-form">
            <input
                type="text"
                id="new-message-input"
                placeholder="Type your message..."
            />
            <button
                type="submit"
                id="send-message-btn"
            >
                Send
            </button>
        </form>
    </div>

    <div id="app-footnote">
        Made by <a id="jdc-link" href="https://altroweb.github.io/justdevcrap">JustDevCrap.</a> With ‚òï. <a id="privacy-policy-link">Privacy Policy</a>
        <!-- Hidden Admin Login Trigger (only you know where it is) -->
        <span id="admin-login-trigger" style="cursor: pointer; opacity: 0.01; user-select: none;">.</span>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GithubAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc, serverTimestamp, arrayUnion, arrayRemove, runTransaction, query, where, getDocs, orderBy, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // No Cloud Functions import needed for this setup

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA8ErpL72u6bTzPuOx51l4Mb51NDCDBDBY", // Replace with your actual API key if necessary
            authDomain: "textroll-79302.firebaseapp.com",
            projectId: "textroll-79302",
            storageBucket: "textroll-79302.firebaseapp.com",
            messagingSenderId: "928701458132",
            appId: "1:928701458132:web:5eec69352bd35998023d41",
            measurementId: "G-DP3QEKB09S"
        };

        const textrollAppId = firebaseConfig.projectId;
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);


        // DOM Elements
        const loadingScreen = document.getElementById('loading-screen');
        const homeScreen = document.getElementById('home-screen');
        const chatRoomScreen = document.getElementById('chat-room-screen');
        const modeSelection = document.getElementById('mode-selection');
        const defaultModeBtn = document.getElementById('default-mode-btn');
        const randomModeBtn = document.getElementById('random-mode-btn');
        const defaultModeContainer = document.getElementById('default-mode-container');
        const randomModeContainer = document.getElementById('random-mode-container');
        const usernameInput = document.getElementById('username-input');
        const createPasswordInputGroup = document.getElementById('create-password-input-group');
        const createPasswordInput = document.getElementById('create-password-input');
        const maxParticipantsInput = document.getElementById('max-participants-input');
        const roomCodeInput = document.getElementById('room-code-input');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const randomUsernameInput = document.getElementById('random-username-input');
        const joinRandomRoomBtn = document.getElementById('joinRandomRoomBtn');
        const userIdDisplay = document.getElementById('user-id-display');
        const currentRoomCodeDisplay = document.getElementById('current-room-code');
        const participantsCount = document.getElementById('participants-count');
        const maxParticipantsDisplay = document.getElementById('max-participants-display');
        const participantsList = document.getElementById('participants-list');
        const messagesContainer = document.getElementById('messages-container');
        const noMessagesYet = document.getElementById('no-messages-yet');
        const messagesEndRef = document.getElementById('messages-end-ref');
        const newMessageInput = document.getElementById('new-message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const messageForm = document.getElementById('message-form');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalPasswordInputGroup = document.getElementById('modal-password-input-group');
        const modalPasswordInput = document.getElementById('modal-password-input');
        const modalPasswordError = document.getElementById('modal-password-error');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const privacyPolicyLink = document.getElementById('privacy-policy-link');
        const privacyPolicyModalOverlay = document.getElementById('privacy-policy-modal-overlay');
        const privacyPolicyModalContent = document.getElementById('privacy-policy-modal-content');
        const privacyPolicyCloseBtn = document.getElementById('privacy-policy-close-btn');
        const darkModeToggleHome = document.getElementById('dark-mode-toggle');
        const darkModeToggleChat = document.getElementById('dark-mode-toggle-chat');
        const iconMoonHome = darkModeToggleHome.querySelector('.icon-moon-text');
        const iconSunHome = darkModeToggleHome.querySelector('.icon-sun-text');
        const iconMoonChat = darkModeToggleChat.querySelector('.icon-moon-text');
        const iconSunChat = darkModeToggleChat.querySelector('.icon-sun-text');

        // NEW DOM Elements for permanent room feature
        const permanentRoomIndicator = document.getElementById('permanent-room-indicator');
        const togglePermanentModeBtn = document.getElementById('toggle-permanent-mode-btn');

        // NEW: Admin Login Trigger
        const adminLoginTrigger = document.getElementById('admin-login-trigger');


        // Application State
        let currentUserId = null;
        let currentRoom = null; // Will store { code, users, maxParticipants, password, hostId, isPermanent, permanentLastActivity }
        let unsubscribeRoomListener = null;
        let unsubscribeMessagesListener = null;
        let currentMode = 'default';
        let inactivityTimer = null;
        const INACTIVITY_TIMEOUT_MS = 15 * 60 * 1000; // 15 minutes
        const PERMANENT_INACTIVITY_TIMEOUT_MS = 7 * 24 * 60 * 60 * 1000; // 1 week in milliseconds
        let currentUserObject = null; // Stores { userId, username, joinTimestamp }


        // --- START CUSTOM ENCRYPTION ALGORITHM ---
        const ID_LENGTH = 32; // Fixed length for the hexadecimal master seed (16 bytes)
        const NUM_ROUNDS = 3; // Number of encryption/decryption rounds
        const HASH_LENGTH_HEX = 64; // SHA-256 hash length in hex characters (32 bytes)
        const MIN_BLOCK_SIZE = 5; // Minimum block size for permutation
        const MAX_BLOCK_SIZE = 15; // Maximum block size for permutation

        function generateCharacterSet() {
            let chars = [];
            for (let i = 0x20; i <= 0x7E; i++) chars.push(String.fromCharCode(i));
            for (let i = 0xA0; i <= 0xFF; i++) chars.push(String.fromCharCode(i));
            for (let i = 0x100; i <= 0x17F; i++) chars.push(String.fromCharCode(i));
            for (let i = 0x2000; i <= 0x27BF; i++) chars.push(String.fromCharCode(i));
            for (let i = 0x2E00; i <= 0x312F; i++) chars.push(String.fromCharCode(i));
            for (let i = 0x4E00; i <= 0x4E50; i++) chars.push(String.fromCharCode(i));
            const commonEmojis = [
                'üòÄ', 'üòÇ', 'üòç', 'üëç', 'üôè', 'üöÄ', 'üåü', 'üí°', 'üéâ', 'üî•', '‚ù§Ô∏è', '‚úÖ', '‚ùå', '‚ú®', 'üé∂', 'üåà', 'üê∂', 'üê±', 'üçé', 'üçï',
                'ü§î', 'üòä', 'ü•≥', 'ü§Ø', 'üò≠', 'üòé', 'ü§©', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ',
                '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'üò§', 'üò†', 'üò°', 'ü§¨', 'üòà', 'üëø', 'üíÄ', '‚ò†Ô∏è', 'üí©', 'ü§°', 'üëπ', 'üë∫', 'üëª', 'üëΩ', 'üëæ',
                'ü§ñ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ', 'üôà', 'üôâ', 'üôä', 'üíã', 'üíå', 'üíò', 'üíù', 'üíñ', 'üíó', 'üíì',
                'üíû', 'üíï', 'üíî', '‚ù§Ô∏è‚Äçüî•', '‚ù£Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'ü§é', 'üñ§', 'ü§ç', 'üíØ', 'üí¢', 'üí•', 'üí´', 'üí¶', 'üí®', 'üï≥Ô∏è',
                'üí£', 'üí¨', 'üëÅÔ∏è‚Äçüó®Ô∏è', 'üó®Ô∏è', 'üí≠', 'üóØÔ∏è', 'üí§', 'üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà',
                'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üíÖ', 'ü§≥',
                'üí™', 'ü¶æ', 'ü¶µ', 'ü¶∂', 'üëÇ', 'ü¶ª', 'üëÉ', 'üß†', 'ü´Ä', 'ü´Å', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'üë∂', 'üßí', 'üë¶', 'üëß',
                'üßë', 'üë±', 'üë®', 'üßî', 'üë¥', 'üëµ', 'üßì', 'üôç‚Äç‚ôÇÔ∏è', 'üôç‚Äç‚ôÄÔ∏è', 'üôÖ‚Äç‚ôÇÔ∏è', 'üôÖ‚Äç‚ôÄÔ∏è', 'üôÜ‚Äç‚ôÇÔ∏è', 'üôÜ‚Äç‚ôÄÔ∏è', 'üíÅ‚Äç‚ôÇÔ∏è', 'üíÅ‚Äç‚ôÄÔ∏è', 'üôã‚Äç‚ôÇÔ∏è', 'üôã‚Äç‚ôÄÔ∏è', 'üßè‚Äç‚ôÇÔ∏è', 'üßè‚Äç‚ôÄÔ∏è',
                'üôá‚Äç‚ôÇÔ∏è', 'üôá‚Äç‚ôÄÔ∏è', 'ü§¶‚Äç‚ôÇÔ∏è', 'ü§¶‚Äç‚ôÄÔ∏è', 'ü§∑‚Äç‚ôÇÔ∏è', 'ü§∑‚Äç‚ôÄÔ∏è', 'üßë‚Äç‚öïÔ∏è', 'üë®‚Äçüéì', 'üë©‚Äçüè´', 'üë®‚Äç‚öñÔ∏è', 'üë©‚Äçüåæ', 'üë®‚Äçüç≥', 'üë©‚Äçüîß', 'üë®‚Äçüè≠', 'üë©‚Äçüíº', 'üë®‚Äçüî¨', 'üë©‚Äçüíª', 'üë®‚Äçüé§',
                'üë©‚Äçüé®', 'üë®‚Äç‚úàÔ∏è', 'üë©‚ÄçüöÄ', 'üë®‚Äçüöí', 'üëÆ‚Äç‚ôÇÔ∏è', 'üëÆ‚Äç‚ôÄÔ∏è', 'üïµÔ∏è‚Äç‚ôÇÔ∏è', 'üïµÔ∏è‚Äç‚ôÄÔ∏è', 'üíÇ‚Äç‚ôÇÔ∏è', 'üíÇ‚Äç‚ôÄÔ∏è', 'üë∑‚Äç‚ôÇÔ∏è', 'üë∑‚Äç‚ôÄÔ∏è', 'ü§¥', 'üë∏', 'üë≥‚Äç‚ôÇÔ∏è', 'üë≥‚Äç‚ôÄÔ∏è', 'üë≤', 'üßï', 'ü§µ',
                'üë∞', 'ü§∞', 'ü§±', 'üëº', 'üéÖ', 'ü§∂', 'ü¶∏‚Äç‚ôÇÔ∏è', 'ü¶∏‚Äç‚ôÄÔ∏è', 'ü¶π‚Äç‚ôÇÔ∏è', 'ü¶π‚Äç‚ôÄÔ∏è', 'üßô‚Äç‚ôÇÔ∏è', 'üßô‚Äç‚ôÄÔ∏è', 'üßö‚Äç‚ôÇÔ∏è', 'üßö‚Äç‚ôÄÔ∏è', 'üßõ‚Äç‚ôÇÔ∏è', 'üßõ‚Äç‚ôÄÔ∏è', 'üßú‚Äç‚ôÇÔ∏è', 'üßú‚Äç‚ôÄÔ∏è', 'üßù‚Äç‚ôÇÔ∏è',
                'üßù‚Äç‚ôÄÔ∏è', 'üßû‚Äç‚ôÇÔ∏è', 'üßû‚Äç‚ôÄÔ∏è', 'üßü‚Äç‚ôÇÔ∏è', 'üßü‚Äç‚ôÄÔ∏è', 'üö∂‚Äç‚ôÇÔ∏è', 'üö∂‚Äç‚ôÄÔ∏è', 'üèÉ‚Äç‚ôÇÔ∏è', 'üèÉ‚Äç‚ôÄÔ∏è', 'üßç‚Äç‚ôÇÔ∏è', 'üßç‚Äç‚ôÄÔ∏è', 'üßé‚Äç‚ôÇÔ∏è', 'üßé‚Äç‚ôÄÔ∏è', 'üë®‚Äçü¶Ø', 'üë©‚Äçü¶Ø', 'üë®‚Äçü¶º', 'üë©‚Äçü¶º', 'üë®‚Äçü¶Ω', 'üë©‚Äçü¶Ω',
                'üêï', 'üêà', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶', 'üê•', 'ü¶Ü',
                'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'üï∑Ô∏è', 'ü¶Ç', 'ü¶ü', 'ü¶†', 'üê¢', 'üêç', 'ü¶é',
                'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'ü¶à', 'üê≥', 'üê¨', 'üêÑ', 'üêè', 'üêê', 'üê™', 'ü¶í', 'üêò', 'ü¶è', 'ü¶õ',
                'ü¶ù', 'ü¶°', 'ü¶¶', 'ü¶•', 'ü¶ß', 'ü¶®', 'ü¶ò', 'ü¶°', 'ü¶É', 'üêì', 'ü¶¢', 'üïäÔ∏è', 'ü¶©', 'ü¶ö', 'ü¶ú', 'üê∏', 'üêä', 'üêç', 'ü¶é', 'üêâ',
                'ü¶ï', 'ü¶ñ', 'üê≥', 'üê¨', 'üêü', 'üê†', 'üê°', 'ü¶à', 'üêô', 'üêö', 'üêå', 'ü¶ã', 'üêõ', 'üêú', 'üêù', 'üêû', 'ü¶ó', 'üï∑Ô∏è', 'üï∏Ô∏è', 'ü¶Ç',
                'ü¶ü', 'ü¶†', 'üíê', 'üå∏', 'üíÆ', 'üèµÔ∏è', 'üåπ', 'ü•Ä', 'üå∫', 'üåª', 'üåº', 'üå∑', 'üå±', 'üå≤', 'üå≥', 'üå¥', 'üåµ', 'üåæ', 'üåø', '‚òòÔ∏è',
                'üçÄ', 'üçÅ', 'üçÇ', 'üçÉ', 'üçá', 'üçà', 'üçâ', 'üçä', 'üçã', 'üçå', 'üçç', 'ü•≠', 'üçé', 'üçè', 'üçê', 'üçë', 'üçí', 'üçì', 'ü•ù', 'üçÖ',
                'ü••', 'ü•ë', 'üçÜ', 'ü•î', 'ü•ï', 'üåΩ', 'üå∂Ô∏è', 'ü•í', 'ü•¨', 'ü•¶', 'üßÑ', 'üßÖ', 'üçÑ', 'üï∫', 'üíÉ', 'üëØ‚Äç‚ôÇÔ∏è', 'üëØ‚Äç‚ôÄÔ∏è', 'üï¥Ô∏è', 'üë§', 'üë•', 'üó£Ô∏è', 'üë£', 'ü¶∞', 'ü¶±', 'ü¶≥', 'ü¶≤', 'üßë‚Äçü¶±', 'üßë‚Äçü¶≥', 'üßë‚Äçü¶∞', 'üßë‚Äçü¶≤', 'üö∂', 'üèÉ', 'üßç', 'üßé', 'üßë‚Äçü¶Ø', 'üßë‚Äçü¶º', 'üßë‚Äçü¶Ω', 'üßè', 'üßë‚Äçü§ù‚Äçüßë', 'üßë‚Äçüçº', 'üéÖüèª', 'üéÖüèº', 'üéÖüèΩ', 'üéÖüèæ', 'üéÖüèø', 'ü§∂üèª', 'ü§∂üèº', 'ü§∂üèΩ', 'ü§∂üèæ', 'ü§∂üèø', 'ü¶∏üèª', 'ü¶∏üèº', 'ü¶∏üèΩ', 'ü¶∏üèæ', 'ü¶∏üèø', 'ü¶πüèª', 'ü¶πüèº', 'ü¶πüèΩ', 'ü¶πüèæ', 'ü¶πüèø', 'üßôüèª', 'üßôüèº', 'üßôüèΩ', 'üßôüèæ', 'üßôüèø', 'üßöüèª', 'üßöüèº', 'üßöüèΩ', 'üßöüèæ', 'üßöüèø', 'üßõüèª', 'üßõüèº', 'üßõüèΩ', 'üßõüèæ', 'üßõüèø', 'üßúüèª', 'üßúüèº', 'üßúüèΩ', 'üßúüèæ', 'üßúüèø', 'üßùüèª', 'üßùüèº', 'üßùüèΩ', 'üßùüèæ', 'üßùüèø', 'üßû‚Äç‚ôÇÔ∏è', 'üßû‚Äç‚ôÄÔ∏è', 'üßü‚Äç‚ôÇÔ∏è', 'üßü‚Äç‚ôÄÔ∏è', 'üß†', 'ü´Ä', 'ü´Å', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'üëÉ', 'üëÇ', 'ü¶ª', 'ü¶∂', 'ü¶µ', 'üí™', 'ü¶æ', 'ü§≤', 'üôè', 'ü§ù', 'üëç', 'üëé', 'üëä', '‚úä', 'ü§õ', 'ü§ú', 'ü§û', '‚úåÔ∏è', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', '‚úã', 'ü§ö', 'üñêÔ∏è', 'üññ', 'üëã', 'ü§è', 'üëå', 'ü§å', '‚úçÔ∏è', 'ü§≥', 'üíÖ', 'ü¶∞', 'ü¶±', 'ü¶≥', 'ü¶≤', 'üë©‚Äçü¶∞', 'üë®‚Äçü¶∞', 'üë©‚Äçü¶±', 'üë®‚Äçü¶±', 'üë©‚Äçü¶≥', 'üë®‚Äçü¶≥', 'üë©‚Äçü¶≤', 'üë®‚Äçü¶≤', 'üßë‚Äçü¶∞', 'üßë‚Äçü¶±', 'üßë‚Äçü¶≥', 'üßë‚Äçü¶≤', 'üë∂', 'üßí', 'üë¶', 'üëß', 'üßë', 'üë±', 'üë®', 'üë©', 'üë¥', 'üëµ', 'üßì', 'üôç', 'üôé', 'üôÖ', 'üôÜ', 'üíÅ', 'üôã', 'üßè', 'üôá', 'ü§¶', 'ü§∑', 'üßë‚Äç‚öïÔ∏è', 'üßë‚Äçüéì', 'üßë‚Äçüè´', 'üßë‚Äç‚öñÔ∏è', 'üßë‚Äçüåæ', 'üßë‚Äçüç≥', 'üßë‚Äçüîß', 'üßë‚Äçüè≠', 'üßë‚Äçüíº', 'üßë‚Äçüî¨', 'üßë‚Äçüíª', 'üßë‚Äçüé§', 'üßë‚Äçüé®', 'üßë‚Äç‚úàÔ∏è', 'üßë‚ÄçüöÄ', 'üßë‚Äçüöí', 'üëÆ', 'üïµÔ∏è', 'üíÇ', 'üë∑', 'ü§¥', 'üë∏', 'üë≥', 'üßï', 'ü§µ', 'üë∞', 'ü§∞', 'ü§±', 'üëº', 'üéÖ', 'ü§∂', 'ü¶∏', 'ü¶π', 'üßô', 'üßö', 'üßõ', 'üßú', 'üßù', 'üßû', 'üßü', 'üêï', 'üêà', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'üï∑Ô∏è', 'ü¶Ç', 'ü¶ü', 'ü¶†', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'ü¶à', 'üê≥', 'üê¨', 'üêÑ', 'üêè', 'üêê', 'üê™', 'ü¶í', 'üêò', 'ü¶è', 'ü¶õ', 'ü¶ù', 'ü¶°', 'ü¶¶', 'ü¶•', 'ü¶ß', 'ü¶®', 'ü¶ò', 'ü¶É', 'üêì', 'ü¶¢', 'üïäÔ∏è', 'ü¶©', 'ü¶ö', 'ü¶ú', 'üíê', 'üå∏', 'üíÆ', 'üèµÔ∏è', 'üåπ', 'ü•Ä', 'üå∫', 'üåª', 'üåº', 'üå∑', 'üå±', 'üå≤', 'üå≥', 'üå¥', 'üåµ', 'üåæ', 'üåø', '‚òòÔ∏è', 'üçÄ', 'üçÅ', 'üçÇ', 'üçÉ', 'üçá', 'üçà', 'üçâ', 'üçä', 'üçã', 'üçå', 'üçç', 'ü•≠', 'üçé', 'üçè', 'üçê', 'üçë', 'üçí', 'üçì', 'ü•ù', 'üçÖ', 'ü••', 'ü•ë', 'üçÜ', 'ü•î', 'ü•ï', 'üåΩ', 'üå∂Ô∏è', 'ü•í', 'ü•¨', 'ü•¶', 'üßÑ', 'üßÖ', 'üçÑ', 'ü•ú', 'üå∞', 'üçû', 'ü•ê', 'ü•ñ', 'ü•®', 'ü•Ø', 'ü•û', 'üßá', 'üßÄ', 'üçñ', 'üçó', 'ü•©', 'ü•ì', 'üçî', 'üçü', 'üçï', 'üå≠', 'ü•™', 'üåÆ', 'üåØ', 'ü•ô', 'üßÜ', 'ü•ö', 'üç≥', 'ü•ò', 'üç≤', 'ü•£', 'ü•ó', 'üçø', 'üßà', 'üßÇ', 'ü•´', 'üç±', 'üçò', 'üçô', 'üçö', 'üçõ', 'üçú', 'üçù', 'üç†', 'üç¢', 'üç£', 'üç§', 'üç•', 'üç°', 'ü•ü', 'ü•†', 'ü•°', 'üç¶', 'üçß', 'üç®', 'üç©', 'üç™', 'üéÇ', 'üç∞', 'üßÅ', 'ü•ß', 'üç´', 'üç¨', 'üç≠', 'üçÆ', 'üçØ', 'üçº', 'ü•õ', '‚òï', 'üçµ', 'üç∂', 'üçæ', 'üç∑', 'üç∏', 'üçπ', 'üç∫', 'üçª', 'ü•Ç', 'ü•É', 'ü•§', 'üßã', 'üßä', 'ü•¢', 'ü•Ñ', 'üç¥', 'üçΩÔ∏è', 'ü•£', 'ü•°', 'üè∫'
            ];
            chars = chars.concat(commonEmojis);
            return [...new Set(chars)];
        }

        const CHARACTER_SET = generateCharacterSet();

        class PRNG {
            constructor(seedString) {
                let h1 = 0x85ebca6b;
                let h2 = 0x9942f0a6;
                for (let i = 0; i < seedString.length; i++) {
                    h1 = (h1 * 31 + seedString.charCodeAt(i)) | 0;
                    h2 = (h2 * 17 + seedString.charCodeAt((i + h1) % seedString.length)) | 0;
                }
                this.s0 = (BigInt(h1) << BigInt(32)) | BigInt(h2);
                this.s1 = (BigInt(h2) << BigInt(32)) | BigInt(h1);
                if (this.s0 === BigInt(0) && this.s1 === BigInt(0)) {
                    this.s0 = BigInt(1);
                }
            }
            next() {
                let s0 = this.s0;
                let s1 = this.s1;
                let result = s0 + s1;
                s1 ^= s0;
                this.s0 = ((s0 << BigInt(24)) | (s0 >> BigInt(40))) ^ s1 ^ (s1 << BigInt(16));
                this.s1 = ((s1 << BigInt(37)) | (s1 >> BigInt(27)));
                return result;
            }
            random() {
                const mask = BigInt('0x1FFFFFFFFFFFFF');
                const divisor = BigInt('0x20000000000000');
                return Number((this.next() & mask)) / Number(divisor);
            }
        }

        function deterministicShuffle(array, prng) {
            const shuffledArray = [...array];
            for (let i = shuffledArray.length - 1; i > 0; i--) {
                const j = Math.floor(prng.random() * (i + 1));
                [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
            }
            return shuffledArray;
        }

        function generateSubstitutionMap(prng) {
            const originalChars = [...CHARACTER_SET];
            const shuffledChars = deterministicShuffle(originalChars, prng);
            const forwardMap = new Map();
            const reverseMap = new Map();
            for (let i = 0; i < originalChars.length; i++) {
                forwardMap.set(originalChars[i], shuffledChars[i]);
                reverseMap.set(shuffledChars[i], originalChars[i]);
            }
            return { forwardMap, reverseMap };
        }

        function applySubstitution(charArray, map) {
            return charArray.map(char => map.has(char) ? map.get(char) : char);
        }

        function applyPermutation(charArray, blockSize) {
            if (charArray.length < blockSize) return [...charArray];
            let permutedArray = [];
            for (let i = 0; i < charArray.length; i += blockSize) {
                const block = charArray.slice(i, i + blockSize);
                permutedArray.push(...block.reverse());
            }
            return permutedArray;
        }

        function applyInversePermutation(charArray, blockSize) {
            return applyPermutation(charArray, blockSize);
        }

        async function sha256(message) {
            if (!window.crypto || !window.crypto.subtle || !window.crypto.subtle.digest) {
                console.warn('Your browser does not support Web Crypto API (SHA-256). Integrity check will be skipped.');
                return null;
            }
            const msgBuffer = new TextEncoder().encode(message);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hexHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hexHash;
        }

        // Function to derive a unique seed for the room
        // Uses roomCode and optionally password to create a robust seed string
        const deriveRoomSeed = (roomCode, password = '') => {
            // Combine roomCode and password (or just roomCode if no password)
            // A simple concatenation is okay here as the PRNG hashes the seed string.
            return `${roomCode}-${password}`;
        };

        // Encrypts a message using the room's derived seed
        async function encryptMessage(message, roomCode, roomPassword = '') {
            const masterSeed = deriveRoomSeed(roomCode, roomPassword);
            const prng = new PRNG(masterSeed);

            const plaintextHash = await sha256(message);
            
            let textToEncryptChars = Array.from(message);
            if (plaintextHash) {
                textToEncryptChars.push(...Array.from(plaintextHash));
            }

            const roundParams = [];
            for (let i = 0; i < NUM_ROUNDS; i++) {
                const { forwardMap } = generateSubstitutionMap(prng);
                const blockSize = Math.floor(prng.random() * (MAX_BLOCK_SIZE - MIN_BLOCK_SIZE + 1)) + MIN_BLOCK_SIZE;
                roundParams.push({ forwardMap, blockSize });
            }

            let currentChars = [...textToEncryptChars];

            for (let i = 0; i < NUM_ROUNDS; i++) {
                currentChars = applySubstitution(currentChars, roundParams[i].forwardMap);
                currentChars = applyPermutation(currentChars, roundParams[i].blockSize);
            }
            return currentChars.join(''); // Return just the encrypted text, no masterSeed prepended
        }

        // Decrypts a message using the room's derived seed
        async function decryptMessage(encryptedText, roomCode, roomPassword = '') {
            if (!encryptedText) return ''; // Handle empty encrypted text

            const masterSeed = deriveRoomSeed(roomCode, roomPassword);
            const prng = new PRNG(masterSeed);

            const encryptedTextChars = Array.from(encryptedText);

            const roundParams = [];
            for (let i = 0; i < NUM_ROUNDS; i++) {
                const { forwardMap, reverseMap } = generateSubstitutionMap(prng);
                const blockSize = Math.floor(prng.random() * (MAX_BLOCK_SIZE - MIN_BLOCK_SIZE + 1)) + MIN_BLOCK_SIZE;
                roundParams.push({ forwardMap, reverseMap, blockSize });
            }

            let currentChars = [...encryptedTextChars];

            for (let i = NUM_ROUNDS - 1; i >= 0; i--) {
                currentChars = applyInversePermutation(currentChars, roundParams[i].blockSize);
                currentChars = applySubstitution(currentChars, roundParams[i].reverseMap);
            }

            let decryptedPlaintextChars = [...currentChars];
            let decryptedHashChars = null;

            if (currentChars.length >= HASH_LENGTH_HEX) {
                decryptedPlaintextChars = currentChars.slice(0, currentChars.length - HASH_LENGTH_HEX);
                decryptedHashChars = currentChars.slice(currentChars.length - HASH_LENGTH_HEX);
            } else {
                console.warn('Decrypted text too short to contain a hash. Integrity check skipped.');
            }

            const finalDecryptedPlaintext = decryptedPlaintextChars.join('');
            const finalDecryptedHash = decryptedHashChars ? decryptedHashChars.join('') : null;

            if (finalDecryptedHash) {
                const recomputedHash = await sha256(finalDecryptedPlaintext);
                if (recomputedHash === null) {
                    console.warn('Integrity check skipped during decryption due to browser limitations.');
                } else if (recomputedHash !== finalDecryptedHash) {
                    console.error('Integrity check FAILED! Message might have been tampered with.');
                    return "[TAMPERED MESSAGE]"; // Indicate tampering
                }
            }
            return finalDecryptedPlaintext;
        }
        // --- END CUSTOM ENCRYPTION ALGORITHM ---


        // Utility to generate room code
        const generateRoomCode = () => {
            let result = '';
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            for (let i = 0; i < 6; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        };

        // Modal display functions
        const showModal = (title, message, onConfirmCallback, showCancel = false, onCancelCallback = () => hideModal(), showPasswordInput = false) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.toggle('hidden', !showCancel);
            modalPasswordInputGroup.classList.add('hidden');
            modalPasswordError.classList.add('hidden');
            if (showPasswordInput) {
                modalPasswordInputGroup.classList.remove('hidden');
            }
            modalPasswordInput.value = '';
            modalOkBtn.onclick = async () => { await onConfirmCallback(); };
            modalCancelBtn.onclick = () => { onCancelCallback(); hideModal(); };
            modalOverlay.classList.remove('hidden');
            setTimeout(() => modalContent.classList.add('show'), 10);
        };
        const hideModal = () => {
            modalContent.classList.remove('show');
            setTimeout(() => {
                modalOverlay.classList.add('hidden');
                modalPasswordInputGroup.classList.add('hidden');
                modalPasswordError.classList.add('hidden');
            }, 300);
        };
        const showPrivacyPolicyModal = () => {
            privacyPolicyModalOverlay.classList.remove('hidden');
            setTimeout(() => privacyPolicyModalContent.classList.add('show'), 10);
        };
        const hidePrivacyPolicyModal = () => {
            privacyPolicyModalContent.classList.remove('show');
            setTimeout(() => privacyPolicyModalOverlay.classList.add('hidden'), 300);
        };

        // UI Update Logic
        const updateUI = () => {
            loadingScreen.classList.add('hidden');
            if (currentRoom) {
                homeScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('hidden');
                chatRoomScreen.classList.add('animate-scaleIn');
                homeScreen.classList.remove('animate-scaleIn');
                currentRoomCodeDisplay.textContent = currentRoom.code;
                renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                maxParticipantsDisplay.textContent = currentRoom.maxParticipants || 4;
                const isCurrentUserInRoom = currentRoom.users.some(u => u.userId === currentUserId);
                newMessageInput.disabled = !isCurrentUserInRoom;
                sendMessageBtn.disabled = !isCurrentUserInRoom;
                updatePermanentModeUI(); // NEW: Update permanent mode UI
            } else {
                homeScreen.classList.remove('hidden');
                homeScreen.classList.add('animate-scaleIn');
                chatRoomScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('animate-scaleIn');
                updateModeUI(currentMode);
            }
        };

        // NEW: Function to update the permanent mode button and indicator UI
        const updatePermanentModeUI = () => {
            if (!currentRoom) {
                togglePermanentModeBtn.classList.add('hidden');
                permanentRoomIndicator.classList.add('hidden');
                return;
            }
            const isHost = currentUserId === currentRoom.hostId;
            const isPermanent = currentRoom.isPermanent;

            togglePermanentModeBtn.classList.toggle('hidden', !isHost); // Only host sees the button
            togglePermanentModeBtn.textContent = isPermanent ? 'Temp' : 'Perma';
            togglePermanentModeBtn.disabled = false; 

            permanentRoomIndicator.classList.toggle('hidden', !isPermanent); // Show indicator if permanent
        };

        // Render participants with remove button for host
        const renderParticipants = (users, hostId) => {
            participantsList.innerHTML = '';
            participantsCount.textContent = users.length;
            const isHost = currentUserId === hostId;

            users.forEach(user => {
                const participantSpan = document.createElement('span');
                participantSpan.className = `${user.userId === currentUserId ? 'bg-indigo-100' : 'bg-gray-100'}`;
                
                const usernameText = document.createTextNode(`${user.username} ${user.userId === currentUserId ? '(You)' : ''} ${user.userId === hostId ? '(Host)' : ''}`);
                participantSpan.appendChild(usernameText);

                // Admin (host) can remove other participants
                if (isHost && user.userId !== currentUserId) {
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-participant-btn';
                    removeBtn.textContent = '‚úï'; // Using a multiplication X, or use an SVG/icon font
                    removeBtn.title = `Remove ${user.username}`;
                    removeBtn.onclick = () => handleRemoveParticipant(user);
                    participantSpan.appendChild(removeBtn);
                }
                participantsList.appendChild(participantSpan);
            });
        };
        
        // Function for host to remove a participant
        const handleRemoveParticipant = async (userToRemove) => {
            if (!currentRoom || currentUserId !== currentRoom.hostId) {
                showModal("Error", "Only the host can remove participants.", () => hideModal());
                return;
            }
            showModal(
                "Remove Participant", 
                `Are you sure you want to remove ${userToRemove.username} from the room?`,
                async () => {
                    const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                    try {
                        await runTransaction(db, async (transaction) => {
                            const roomDoc = await transaction.get(roomRef);
                            if (!roomDoc.exists()) {
                                throw new Error("Room does not exist.");
                            }
                            const roomData = roomDoc.data();
                            const usersInRoom = roomData.users || [];
                            
                            // Find the exact user object in Firestore to remove
                            const userObjectInFirestore = usersInRoom.find(u => u.userId === userToRemove.userId);

                            if (userObjectInFirestore) {
                                const updateFields = { users: arrayRemove(userObjectInFirestore), lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) { // NEW: Update permanentLastActivity if permanent
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                transaction.update(roomRef, updateFields);
                            } else {
                                console.warn(`User ${userToRemove.username} not found in Firestore for removal.`);
                            }
                        });
                        // The onSnapshot listener will update the UI.
                        // If the removed user is the current client, they will be kicked out by onSnapshot logic.
                        hideModal(); // Hide confirmation modal
                    } catch (error) {
                        console.error("Error removing participant:", error);
                        showModal("Removal Failed", `Failed to remove ${userToRemove.username}. Please try again.`, () => hideModal());
                    }
                },
                true // Show cancel button
            );
        };


        // Render messages (filtered by joinTimestamp and decrypted)
        const renderMessages = async (messages) => { // Made async
            messagesContainer.innerHTML = '';
            const currentUserJoinTimestamp = currentUserObject?.joinTimestamp;
            const currentUserJoinTime = currentUserJoinTimestamp instanceof Date ? currentUserJoinTimestamp.getTime() : (currentUserJoinTimestamp?.toDate ? currentUserJoinTimestamp.toDate().getTime() : 0);

            const filteredMessages = messages.filter(msg => {
                if (!currentUserJoinTime || !msg.timestamp) return true;
                const messageTime = msg.timestamp instanceof Date ? msg.timestamp.getTime() : (msg.timestamp.toDate ? msg.timestamp.toDate().getTime() : 0);
                return messageTime >= currentUserJoinTime;
            });

            if (filteredMessages.length === 0) {
                noMessagesYet.classList.remove('hidden');
            } else {
                noMessagesYet.classList.add('hidden');
                for (const msg of filteredMessages) { // Use for...of for async/await
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message-item ${msg.senderId === currentUserId ? 'justify-end' : 'justify-start'}`;
                    const contentDiv = document.createElement('div');
                    contentDiv.className = "message-content";
                    const senderSpan = document.createElement('div');
                    senderSpan.className = "sender-info";
                    senderSpan.textContent = msg.senderId === currentUserId ? 'You' : msg.senderUsername;
                    const textP = document.createElement('p');
                    
                    // --- DECRYPT MESSAGE HERE ---
                    try {
                        const decryptedText = await decryptMessage(msg.text, currentRoom.code, currentRoom.password);
                        textP.textContent = decryptedText;
                    } catch (e) {
                        console.error("Decryption failed for message:", msg.id, e);
                        textP.textContent = "[Decryption Failed]"; // Show error if decryption fails
                    }
                    // --- END DECRYPT MESSAGE ---

                    const timestampDiv = document.createElement('div');
                    timestampDiv.className = "timestamp";
                    const date = msg.timestamp ? (msg.timestamp instanceof Date ? msg.timestamp : msg.timestamp.toDate()) : null;
                    timestampDiv.textContent = date ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                    contentDiv.appendChild(senderSpan);
                    contentDiv.appendChild(textP);
                    contentDiv.appendChild(timestampDiv);
                    messageDiv.appendChild(contentDiv);
                    messagesContainer.appendChild(messageDiv);
                }
            }
            messagesContainer.appendChild(messagesEndRef);
            messagesEndRef.scrollIntoView({ behavior: 'smooth' });
        };

        // Firebase Auth
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = `Your User ID: ${currentUserId}`;
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Error signing in:", error);
                    showModal("Authentication Error", "Could not sign in. Please try again.", () => hideModal());
                }
            }
            updateUI();
        });

        // Create Room Button
        createRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const password = createPasswordInput.value.trim();
            const maxParticipants = parseInt(maxParticipantsInput.value, 10);

            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => hideModal());
                return;
            }
            if (isNaN(maxParticipants) || maxParticipants < 2 || maxParticipants > 10) {
                showModal("Invalid Max Participants", "Please set max participants between 2 and 10.", () => hideModal());
                return;
            }
            
            let newRoomCode = generateRoomCode();
            let roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, newRoomCode);
            let roomDoc = await getDoc(roomRef);
            while (roomDoc.exists()) {
                newRoomCode = generateRoomCode();
                roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, newRoomCode);
                roomDoc = await getDoc(roomRef);
            }

            const user = { userId: currentUserId, username: username, joinTimestamp: serverTimestamp() }; // Use serverTimestamp for consistency
            const roomData = {
                code: newRoomCode,
                users: [user],
                hostId: currentUserId,
                createdAt: serverTimestamp(),
                lastActivity: serverTimestamp(),
                maxParticipants: maxParticipants,
                isPermanent: false,
                permanentLastActivity: null
            };
            if (password) roomData.password = password; // Store plaintext password

            try {
                await setDoc(roomRef, roomData);
                currentUserObject = user;
                window.addEventListener('beforeunload', handlePageExit);
                currentRoom = { ...roomData, code: newRoomCode, isPermanent: false, permanentLastActivity: null }; // Update currentRoom with actual code
                roomCodeInput.value = newRoomCode;
                createPasswordInput.value = '';
                await setupRoomListeners(newRoomCode); // Pass newRoomCode
                updateUI();
            } catch (error) {
                console.error("Error creating room:", error);
                showModal("Creation Failed", error.message || "Failed to create room. Please try again.", () => hideModal());
            }
        });

        // Join Room Button
        joinRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const roomCode = roomCodeInput.value.trim().toUpperCase();

            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => hideModal());
                return;
            }
            if (!roomCode) {
                showModal("Invalid Room Code", "Please enter a room code.", () => hideModal());
                return;
            }

            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);
            try {
                const roomDoc = await getDoc(roomRef);
                if (!roomDoc.exists()) {
                    showModal("Room Not Found", "Room code does not exist.", () => hideModal());
                    return;
                }
                const roomData = roomDoc.data();
                const currentUsers = roomData.users || [];
                const maxAllowedUsers = roomData.maxParticipants || 4;

                // Check if username is taken (case-insensitive)
                const isUsernameTaken = currentUsers.some(u => u.username.toLowerCase() === username.toLowerCase() && u.userId !== currentUserId);
                if (isUsernameTaken) {
                    showModal("Username Taken", "This username is already taken in this room. Please choose another.", () => hideModal());
                    return;
                }

                // Check if room is full
                if (currentUsers.length >= maxAllowedUsers && !currentUsers.some(u => u.userId === currentUserId)) {
                    showModal("Room Full", "This room is full.", () => hideModal());
                    return;
                }

                if (roomData.password) { // Room has a password
                    showModal("Enter Password", "This room is password protected.", async () => {
                        const enteredPassword = modalPasswordInput.value.trim();
                        modalPasswordError.classList.add('hidden');

                        // --- PASSWORD VALIDATION (CLIENT-SIDE) ---
                        // Since we are not using Cloud Functions, plaintext password validation happens here.
                        if (enteredPassword !== roomData.password) {
                            modalPasswordError.textContent = "Incorrect password.";
                            modalPasswordError.classList.remove('hidden');
                            modalPasswordInput.value = '';
                            return; // Stop execution, keep modal open
                        }
                        // --- END PASSWORD VALIDATION ---

                        // If password is correct, proceed to join
                        await performJoinRoomTransaction(roomRef, roomCode, username, maxAllowedUsers, roomData.password, roomData.hostId, roomData.isPermanent, roomData.permanentLastActivity);
                        hideModal();
                    }, true, () => {}, true); // Show cancel, show password input
                } else { // Room has no password
                    await performJoinRoomTransaction(roomRef, roomCode, username, maxAllowedUsers, null, roomData.hostId, roomData.isPermanent, roomData.permanentLastActivity);
                }
            } catch (error) {
                console.error("Error joining room (initial check):", error);
                showModal("Join Failed", error.message || "Failed to join room. Check code and try again.", () => hideModal());
            }
        });

        // Transaction to join a room (used by both join and random join)
        const performJoinRoomTransaction = async (roomRef, roomCode, username, roomMaxParticipants, roomPassword = null, hostId = null, isPermanent = false, permanentLastActivity = null) => {
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("Room no longer exists");
                    const roomData = roomDoc.data();
                    let usersInRoom = roomData.users || [];
                    const maxAllowedUsers = roomData.maxParticipants || roomMaxParticipants || 4;
                    let existingUserIndex = usersInRoom.findIndex(u => u.userId === currentUserId);

                    if (existingUserIndex !== -1) {
                        usersInRoom[existingUserIndex].joinTimestamp = serverTimestamp(); // Update timestamp
                        usersInRoom[existingUserIndex].username = username; // Update username if changed
                    } else {
                        if (usersInRoom.length >= maxAllowedUsers) throw new Error("Room full (re-check)");
                        if (usersInRoom.some(u => u.username.toLowerCase() === username.toLowerCase())) throw new Error("Username taken (re-check)");
                        const newUser = { userId: currentUserId, username: username, joinTimestamp: serverTimestamp() };
                        usersInRoom.push(newUser);
                    }
                    
                    const updateFields = { users: usersInRoom, lastActivity: serverTimestamp() };
                    if (roomData.isPermanent) {
                        updateFields.permanentLastActivity = serverTimestamp();
                    }
                    transaction.update(roomRef, updateFields);

                    // Update currentRoom state with latest data from transaction
                    currentRoom = { 
                        code: roomCode, 
                        users: usersInRoom, 
                        maxParticipants: maxAllowedUsers, 
                        password: roomPassword, // Keep password in local state for decryption
                        hostId: roomData.hostId || hostId,
                        isPermanent: roomData.isPermanent || isPermanent,
                        permanentLastActivity: roomData.permanentLastActivity || permanentLastActivity
                    };
                });
                currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                if (currentUserObject) window.addEventListener('beforeunload', handlePageExit);
                else console.error("Could not find current user object after join transaction.");
                await setupRoomListeners(roomCode);
                updateUI();
                hideModal();
            } catch (error) {
                console.error("Error joining room (transaction):", error);
                let errorMessage = "Failed to join room. Please try again.";
                if (error.message.includes("Room full")) errorMessage = "Room is now full.";
                if (error.message.includes("Username taken")) errorMessage = "Username was taken.";
                if (error.message.includes("Room no longer exists")) errorMessage = "The room no longer exists.";
                showModal("Join Failed", errorMessage, () => hideModal());
            }
        };

        // Join Random Room
        joinRandomRoomBtn.addEventListener('click', async () => {
            const username = randomUsernameInput.value.trim();
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => { hideModal(); }); 
                return;
            }
            const randomWarningShown = localStorage.getItem('randomWarningShown');
            if (!randomWarningShown) {
                showModal("Anonymous Chat Warning", "You are about to join a random, unmoderated, and temporary chat room. Do not share personal information.", async () => {
                    localStorage.setItem('randomWarningShown', 'true'); 
                    await findRandomRoom(username);
                }, true, () => {});
            } else {
                await findRandomRoom(username);
            }
        });

        const findRandomRoom = async (username) => {
            try {
                const roomsCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms`);
                const querySnapshot = await getDocs(roomsCollectionRef); // Fetch all rooms
                
                let availableRooms = [];
                querySnapshot.forEach(docSnap => {
                    const roomData = docSnap.data();
                    const maxAllowedUsers = roomData.maxParticipants || 4;
                    // Ensure room has users, is not full, and has no password for random join
                    if (roomData.users && roomData.users.length > 0 && roomData.users.length < maxAllowedUsers && !roomData.password) {
                        const isUsernameTaken = roomData.users.some(u => u.username.toLowerCase() === username.toLowerCase() && u.userId !== currentUserId);
                        if (!isUsernameTaken) {
                            availableRooms.push({ id: docSnap.id, ...roomData }); // Include ID for join
                        }
                    }
                });

                if (availableRooms.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableRooms.length);
                    const roomToJoin = availableRooms[randomIndex];
                    await performJoinRoomTransaction(
                        doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomToJoin.id),
                        roomToJoin.id,
                        username,
                        roomToJoin.maxParticipants,
                        roomToJoin.password,
                        roomToJoin.hostId,
                        roomToJoin.isPermanent,
                        roomToJoin.permanentLastActivity
                    );
                } else {
                    showModal("No Random Rooms", "No random rooms available. Try creating one!", () => hideModal());
                }
            } catch (error) {
                console.error("Error finding random room:", error);
                showModal("Error", error.message || "Failed to find a random room.", () => hideModal());
            }
        };
        
        // Room Inactivity Check
        const checkInactivity = async (roomCode) => {
            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);
            try {
                const roomDoc = await getDoc(roomRef); // Get latest room data
                if (!roomDoc.exists()) {
                    if (inactivityTimer) clearInterval(inactivityTimer);
                    inactivityTimer = null;
                    handleLeaveRoomCleanUp();
                    showModal("Room Ended", "The room you were in has ended.", () => {});
                    return;
                }
                const roomData = roomDoc.data();
                const currentTime = Date.now();
                let shouldDelete = false;
                let reason = "";
                let activityTimestamp = null;
                let timeoutDuration = 0;

                if (roomData.isPermanent) {
                    activityTimestamp = roomData.permanentLastActivity ?
                        (roomData.permanentLastActivity instanceof Date ? roomData.permanentLastActivity : roomData.permanentLastActivity.toDate()) :
                        (roomData.createdAt instanceof Date ? roomData.createdAt : roomData.createdAt.toDate());
                    timeoutDuration = PERMANENT_INACTIVITY_TIMEOUT_MS;
                    reason = "due to 1 week inactivity (permanent room)";
                } else {
                    activityTimestamp = roomData.lastActivity ?
                        (roomData.lastActivity instanceof Date ? roomData.lastActivity : roomData.lastActivity.toDate()) :
                        (roomData.createdAt instanceof Date ? roomData.createdAt : roomData.createdAt.toDate());
                    timeoutDuration = INACTIVITY_TIMEOUT_MS;
                    reason = "due to 15 minute inactivity (empty temporary room)";
                }

                if (!(activityTimestamp instanceof Date)) {
                    console.warn("Activity timestamp is not a valid Date object:", activityTimestamp);
                    return;
                }
                const lastActivityTime = activityTimestamp.getTime();

                if (roomData.isPermanent) {
                    if (currentTime - lastActivityTime >= timeoutDuration) {
                        shouldDelete = true;
                    }
                } else {
                    if ((roomData.users && roomData.users.length === 0) && (currentTime - lastActivityTime >= timeoutDuration)) {
                        shouldDelete = true;
                    }
                }

                if (shouldDelete) {
                    if (inactivityTimer) {
                        clearInterval(inactivityTimer);
                        inactivityTimer = null;
                    }
                    showModal("Room Timed Out", `This room was deleted ${reason}.`, async () => {
                        try {
                            // Only host can delete the room
                            if (currentUserId === roomData.hostId) {
                                // Delete all messages in the subcollection first
                                const messagesQuerySnapshot = await getDocs(collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomCode}/messages`));
                                messagesQuerySnapshot.docs.forEach(msgDoc => {
                                    deleteDoc(msgDoc.ref); // Direct delete, relies on rules
                                });
                                await deleteDoc(roomRef); // Direct delete, relies on rules
                                console.log(`Room ${roomCode} deleted ${reason} by host.`);
                            } else {
                                console.warn(`Room ${roomCode} should be deleted but current user is not host. Relying on host or manual cleanup.`);
                                showModal("Room Timed Out", `This room was deleted ${reason}. You were not the host, so automatic deletion failed for you.`, () => {});
                            }
                            handleLeaveRoomCleanUp();
                            hideModal();
                        } catch (e) {
                            console.warn(`Could not delete timed out room ${roomCode}:`, e.message || e);
                            handleLeaveRoomCleanUp(); // Still clean up client-side
                            hideModal();
                        }
                    });
                }
            } catch (error) {
                console.error("Error in checkInactivity:", error);
                // If room doesn't exist, it's already gone, just clean up.
                if (error.code === 'not-found') {
                     if (inactivityTimer) clearInterval(inactivityTimer);
                     inactivityTimer = null;
                     handleLeaveRoomCleanUp();
                     hideModal();
                     showModal("Room Ended", "The room you were in has ended.", () => {});
                } else {
                    showModal("Connection Error", error.message || "Failed to check room inactivity.", () => hideModal());
                }
            }
        };

        // Setup Room Listeners (Updated to handle encrypted messages)
        const setupRoomListeners = async (roomCode) => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) clearInterval(inactivityTimer);

            const roomDocRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);
            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomCode}/messages`);

            try {
                const roomDoc = await getDoc(roomDocRef);
                if (roomDoc.exists()) {
                    currentRoom = { ...roomDoc.data(), code: roomCode };
                    currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                    renderParticipants(currentRoom.users, currentRoom.hostId);
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants;
                    updatePermanentModeUI();
                } else { 
                    showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal();
                    });
                    return;
                }
            } catch (error) { 
                 console.error("Error fetching initial room data:", error);
                showModal("Connection Error", error.message || "Failed to get initial room data.", () => { hideModal(); });
                return;
            }
            
            // Real-time listener for room changes
            unsubscribeRoomListener = onSnapshot(roomDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const roomData = docSnap.data();
                    const amIStillInRoom = roomData.users && roomData.users.some(u => u.userId === currentUserId);

                    if (!amIStillInRoom && currentRoom) {
                        showModal("Removed from Room", "You have been removed from the room or the room has changed.", () => {
                            handleLeaveRoomCleanUp();
                            hideModal();
                        });
                        return;
                    }

                    currentRoom = {
                        ...currentRoom, // Preserve existing properties like password
                        users: roomData.users || [],
                        maxParticipants: roomData.maxParticipants || 4,
                        lastActivity: roomData.lastActivity,
                        hostId: roomData.hostId,
                        isPermanent: roomData.isPermanent || false,
                        permanentLastActivity: roomData.permanentLastActivity || null
                    };
                    currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                    renderParticipants(currentRoom.users, currentRoom.hostId);
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants;
                    updatePermanentModeUI();
                    
                    // Reset and restart inactivity timer
                    if (inactivityTimer) clearInterval(inactivityTimer);
                    inactivityTimer = setInterval(() => checkInactivity(roomCode), 60 * 1000); // Pass roomCode
                    checkInactivity(roomCode); // Run immediately
                } else { 
                     showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal();
                    });
                }
            }, (error) => { 
                console.error("Error listening to room:", error);
                showModal("Connection Error", error.message || "Failed to get room updates.", () => { hideModal(); });
            });
            
            // Real-time listener for messages
            unsubscribeMessagesListener = onSnapshot(query(messagesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
                const newMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderMessages(newMessages); 
            }, (error) => {
                console.error("Error listening to messages:", error);
                showModal("Connection Error", error.message || "Failed to get message updates.", () => { hideModal(); });
            });
        };

        // Send Message (Now encrypts message)
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newMessageText = newMessageInput.value.trim();
            if (!newMessageText) return;
            if (!currentRoom || !currentUserId || !currentUserObject) {
                 console.warn("Cannot send message: currentRoom, currentUserId, or currentUserObject is not set.");
                 return;
            }
            
            try {
                // --- ENCRYPT MESSAGE HERE ---
                const encryptedText = await encryptMessage(newMessageText, currentRoom.code, currentRoom.password);
                // --- END ENCRYPT MESSAGE ---

                const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.code}/messages`);
                await addDoc(messagesCollectionRef, {
                    senderId: currentUserId,
                    senderUsername: currentUserObject.username,
                    type: 'text',
                    timestamp: serverTimestamp(),
                    text: encryptedText, // Store encrypted text
                });

                // Update room's last activity
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                const roomData = (await getDoc(roomRef)).data(); // Get latest room data
                const updateFields = { lastActivity: serverTimestamp() };
                if (roomData.isPermanent) {
                    updateFields.permanentLastActivity = serverTimestamp();
                }
                await updateDoc(roomRef, updateFields);

                newMessageInput.value = ''; 
            } catch (error) {
                console.error("Error sending message:", error);
                showModal("Message Failed", error.message || "Failed to send message.", () => { hideModal(); }); 
            }
        });

        // Leave Room Button
        leaveRoomBtn.addEventListener('click', () => {
            showModal("Leave Room", "Are you sure you want to leave this room?", async () => {
                if (!currentRoom || !currentUserId || !currentUserObject) {
                    console.warn("Cannot leave room: state not properly set.");
                    hideModal();
                    return;
                }
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) {
                            console.warn("Room already gone when attempting to leave.");
                            return; // Room already gone, just clean up locally
                        }
                        const roomData = roomDoc.data();
                        const currentUsers = roomData.users || [];
                        const userObjectToRemoveFromFirestore = currentUsers.find(u => u.userId === currentUserId);

                        if (userObjectToRemoveFromFirestore) { 
                            const updatedUsers = currentUsers.filter(u => u.userId !== currentUserId);

                            if (currentUserId === roomData.hostId) { // Current user is the host
                                if (roomData.isPermanent) {
                                    // Host leaving a permanent room: just remove host from users, room persists
                                    transaction.update(roomRef, {
                                        users: arrayRemove(userObjectToRemoveFromFirestore),
                                        lastActivity: serverTimestamp(),
                                        permanentLastActivity: serverTimestamp()
                                    });
                                } else {
                                    // Host leaving a non-permanent room: delete the room immediately
                                    // Delete all messages in the subcollection first
                                    const messagesQuerySnapshot = await getDocs(collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.code}/messages`));
                                    messagesQuerySnapshot.docs.forEach(msgDoc => {
                                        transaction.delete(msgDoc.ref); // Direct delete, relies on rules
                                    });
                                    transaction.delete(roomRef); // Direct delete, relies on rules
                                }
                            } else { // Current user is a participant (not host)
                                const updateFields = { users: arrayRemove(userObjectToRemoveFromFirestore), lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) {
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                transaction.update(roomRef, updateFields);
                            }
                        } else {
                            console.warn("Attempted to leave room, user not found in Firestore. Cleaning up locally.");
                        }
                    });
                    handleLeaveRoomCleanUp(); 
                    hideModal(); 
                }
                catch (error) {
                    console.error("Error leaving room:", error);
                    showModal("Leave Failed", error.message || "Could not leave room.", () => { 
                        handleLeaveRoomCleanUp(); 
                        hideModal(); 
                    }); 
                }
            }, true); 
        });
        
        // Local Cleanup
        const handleLeaveRoomCleanUp = () => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) clearInterval(inactivityTimer);
            window.removeEventListener('beforeunload', handlePageExit);
            currentUserObject = null; 
            currentRoom = null;
            roomCodeInput.value = '';
            newMessageInput.value = '';
            messagesContainer.innerHTML = ''; 
            noMessagesYet.classList.remove('hidden'); 
            updateUI();
        };

        // Page Exit (Best Effort)
        const handlePageExit = async () => {
             if (currentRoom && currentUserId && currentUserObject) {
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                try {
                    const roomDoc = await getDoc(roomRef);
                    if (roomDoc.exists()) {
                        const roomData = roomDoc.data();
                        const usersInFirestore = roomData.users || [];
                        const userToRemove = usersInFirestore.find(u => u.userId === currentUserId && u.username === currentUserObject.username);
                        if (userToRemove) {
                            // Only remove the user. Let the onSnapshot and inactivity checks handle room deletion.
                            const updateFields = { lastActivity: serverTimestamp() };
                            if (roomData.isPermanent) {
                                updateFields.permanentLastActivity = serverTimestamp();
                            }
                            await updateDoc(roomRef, {
                                users: arrayRemove(userToRemove), 
                                ...updateFields
                            }).catch(e => console.warn("Best-effort: Failed to remove user on exit (updateDoc):", e));
                        }
                    }
                } catch (e) {
                    console.warn("Best-effort: Error in handlePageExit:", e);
                }
            }
        };

        // Toggle Permanent Mode Button
        togglePermanentModeBtn.addEventListener('click', async () => {
            if (!currentRoom || currentUserId !== currentRoom.hostId) {
                showModal("Permission Denied", "Only the host can toggle permanent mode.", () => hideModal());
                return;
            }

            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
            const newPermanentState = !currentRoom.isPermanent; // Toggle the state

            showModal(
                "Toggle Permanent Room",
                `Are you sure you want to ${newPermanentState ? 'make this room permanent' : 'make this room temporary'}?`,
                async () => {
                    try {
                        const updateFields = {
                            isPermanent: newPermanentState,
                            lastActivity: serverTimestamp()
                        };
                        if (newPermanentState) {
                            updateFields.permanentLastActivity = serverTimestamp();
                        } else {
                            updateFields.permanentLastActivity = null;
                        }
                        await updateDoc(roomRef, updateFields);
                        
                        // Update local state immediately for responsive UI
                        currentRoom.isPermanent = newPermanentState; 
                        currentRoom.permanentLastActivity = newPermanentState ? new Date() : null; 

                        updatePermanentModeUI();
                        hideModal();
                    } catch (error) {
                        console.error("Error toggling permanent mode:", error);
                        showModal("Error", error.message || "Failed to toggle permanent mode. Please try again.", () => hideModal());
                    }
                },
                true // Show cancel button
            );
        });


        // Dark Mode & UI Mode Switching
        const applyDarkMode = (isDarkMode) => {
            document.body.classList.toggle('dark-mode', isDarkMode);
            iconMoonHome.classList.toggle('hidden', isDarkMode);
            iconSunHome.classList.toggle('hidden', !isDarkMode);
            iconMoonChat.classList.toggle('hidden', isDarkMode);
            iconSunChat.classList.toggle('hidden', !isDarkMode);
        };
        darkModeToggleHome.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });
        darkModeToggleChat.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') applyDarkMode(true); else applyDarkMode(false);

        const updateModeUI = (mode) => {
            currentMode = mode;
            if (mode === 'default') {
                defaultModeBtn.classList.add('active');
                randomModeBtn.classList.remove('active');
                defaultModeContainer.classList.remove('hidden');
                randomModeContainer.classList.add('hidden');
                randomUsernameInput.value = '';
            } else { 
                randomModeBtn.classList.add('active');
                defaultModeBtn.classList.remove('active');
                randomModeContainer.classList.remove('hidden');
                defaultModeContainer.classList.add('hidden');
                usernameInput.value = '';
                createPasswordInput.value = '';
                roomCodeInput.value = '';
                createPasswordInputGroup.style.display = 'none'; 
                maxParticipantsInput.value = '4'; 
            }
        };
        defaultModeBtn.addEventListener('click', () => updateModeUI('default'));
        randomModeBtn.addEventListener('click', () => updateModeUI('random'));
        usernameInput.addEventListener('input', () => {
            if (usernameInput.value.trim() !== '') createPasswordInputGroup.style.display = 'block';
            else {
                createPasswordInputGroup.style.display = 'none';
                createPasswordInput.value = ''; 
            }
        });

        // Privacy Policy & DOMContentLoaded
        privacyPolicyLink.addEventListener('click', showPrivacyPolicyModal);
        privacyPolicyCloseBtn.addEventListener('click', hidePrivacyPolicyModal);
        document.addEventListener('DOMContentLoaded', () => {
            homeScreen.classList.add('hidden');
            chatRoomScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            updateModeUI('default');
            if (usernameInput.value.trim() !== '') createPasswordInputGroup.style.display = 'block';
        });

        // Admin Login Trigger (Hidden)
        if (adminLoginTrigger) {
            adminLoginTrigger.addEventListener('click', async () => {
                const provider = new GithubAuthProvider();
                try {
                    await signInWithPopup(auth, provider);
                    console.log("Admin GitHub sign-in successful!");
                    showModal("Admin Login", "You are now signed in as admin.", () => hideModal());
                    // The onAuthStateChanged listener will automatically update UI
                } catch (error) {
                    console.error("Admin GitHub sign-in failed:", error);
                    showModal("Admin Login Failed", error.message || "Could not sign in with GitHub. Please try again.", () => hideModal());
                }
            });
        }

    </script>
</body>
</html>
