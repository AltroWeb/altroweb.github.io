<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Textroll - Web Chat</title>

    <!-- Content Security Policy (CSP) Meta Tag -->
    <!-- This CSP is designed to allow necessary resources while restricting others. -->
    <!-- 'self': Allows resources from the same origin as the document. -->
    <!-- 'unsafe-inline': Allows inline scripts and styles. This is generally NOT recommended for production -->
    <!--                  but is often necessary for quick demos or when using frameworks like Tailwind JIT -->
    <!--                  without a build step that hashes inline styles. For production, prefer hashes or nonces. -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' https://cdn.tailwindcss.com https://www.gstatic.com https://www.gstatic.com/firebasejs/ 'unsafe-inline';
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.tailwindcss.com;
        img-src 'self' data: https://placehold.co;
        font-src 'self' https://fonts.gstatic.com;
        connect-src 'self' https://firestore.googleapis.com https://securetoken.googleapis.com https://identitytoolkit.googleapis.com https://www.googleapis.com;
        frame-src 'self' https://textroll-79302.firebaseapp.com https://*.firebaseapp.com https://*.firebaseui.com https://*.google.com;
        object-src 'none';
        base-uri 'self';
        form-action 'self';
    ">


    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="textroll.png">
    <style>
        /* CSS Variables for Theming */
        :root {
            /* Light Mode Colors */
            --bg-gradient-start: #8b5cf6; /* purple-500 */
            --bg-gradient-end: #4f46e5;   /* indigo-600 */
            --text-color-primary: #374151; /* gray-800 */
            --text-color-secondary: #4b5563; /* gray-600 */
            --card-bg: #fff;
            --header-text: #4338ca; /* indigo-700 */
            --room-code-text: #9333ea; /* purple-600 */
            --border-color: #e5e7eb; /* gray-200 */
            --input-border: #d1d5db; /* gray-300 */
            --input-bg-disabled: #f3f4f6; /* gray-100 */
            --button-bg-indigo: #4f46e5; /* indigo-600 */
            --button-hover-indigo: #4338ca; /* indigo-700 */
            --button-bg-purple: #9333ea; /* purple-600 */
            --button-hover-purple: #7e22ce; /* purple-700 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #2563eb; /* blue-600 */
            --button-hover-blue: #1d4ed8; /* blue-700 */
            --button-disabled-bg: #9ca3af; /* gray-400 */
            --participant-bg-you: #e0e7ff; /* indigo-100 */
            --participant-text-you: #4338ca; /* indigo-700 */
            --participant-bg-other: #f3f4f6; /* gray-100 */
            --message-bg-you: #6366f1; /* indigo-500 */
            --message-bg-other: #e5e7eb; /* gray-200 */
            --message-text-you: #fff;
            --message-text-other: #1f2937; /* gray-800 */
            --message-timestamp-opacity: 0.6;
            --chat-bg: #f9fafb; /* gray-50 */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-color-dark: rgba(0, 0, 0, 0.04);
            --modal-shadow-color: rgba(0, 0, 0, 0.25);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.06);
            --focus-ring-indigo: rgba(99, 102, 241, 0.5);
            --focus-ring-purple: rgba(168, 85, 247, 0.75);
            --focus-ring-red: rgba(239, 68, 68, 0.75);
            --focus-ring-blue: rgba(59, 130, 246, 0.5);
            --focus-ring-gray: rgba(156, 163, 175, 0.75);
            --button-shadow-offset: 0 4px 6px -1px;
            --button-shadow-blur: 0 2px 4px -1px;
        }

        /* Dark Mode Colors */
        .dark-mode {
            --bg-gradient-start: #1f2937; /* dark gray */
            --bg-gradient-end: #0f172a;   /* darker blue-gray */
            --text-color-primary: #e5e7eb; /* gray-200 */
            --text-color-secondary: #d1d5db; /* gray-300 */
            --card-bg: #374151; /* gray-700 */
            --header-text: #a78bfa; /* purple-400 */
            --room-code-text: #c084fc; /* purple-500 */
            --border-color: #4b5563; /* gray-600 */
            --input-border: #6b7280; /* gray-500 */
            --input-bg-disabled: #4b5563; /* gray-600 */
            --button-bg-indigo: #6366f1; /* indigo-500 */
            --button-hover-indigo: #4f46e5; /* indigo-600 */
            --button-bg-purple: #a855f7; /* purple-500 */
            --button-hover-purple: #9333ea; /* purple-600 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #3b82f6; /* blue-500 */
            --button-hover-blue: #2563eb; /* blue-600 */
            --button-disabled-bg: #4b5563; /* gray-600 */
            --participant-bg-you: #4f46e5; /* indigo-600 */
            --participant-text-you: #e0e7ff; /* indigo-100 */
            --participant-bg-other: #4b5563; /* gray-600 */
            --message-bg-you: #4f46e5; /* indigo-600 */
            --message-bg-other: #4b5563; /* gray-600 */
            --message-text-you: #e5e7eb;
            --message-text-other: #e5e7eb;
            --message-timestamp-opacity: 0.7;
            --chat-bg: #374151; /* gray-700 */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-color-dark: rgba(0, 0, 0, 0.2);
            --modal-shadow-color: rgba(0, 0, 0, 0.4);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.2);
        }

        /* Universal Font and Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth dark mode transition */
        }

        /* All elements inherit font, remove default button borders */
        * {
            font-family: inherit;
            box-sizing: border-box; /* Ensure consistent box model */
        }
        button {
            border: none; /* Remove default button borders */
            outline: none; /* Remove default focus outline */
            cursor: pointer;
        }

        /* Custom scrollbar for chat messages */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: var(--input-bg-disabled);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Animations */
        @keyframes scaleIn {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        .animate-scaleIn {
            animation: scaleIn 0.3s ease-out forwards;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #loading-screen.hidden {
            display: none;
        }

        /* Modal Styles */
        #modal-overlay, #privacy-policy-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(107, 114, 128, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        #modal-overlay.hidden, #privacy-policy-modal-overlay.hidden {
            display: none;
        }
        #modal-content, #privacy-policy-modal-content {
            background-color: var(--card-bg);
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px var(--modal-shadow-color), 0 10px 10px -5px var(--modal-shadow-color-dark);
            padding: 1.5rem;
            max-width: 24rem;
            width: 100%;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.3s ease-in-out;
            color: var(--text-color-primary);
        }
        #privacy-policy-modal-content {
            max-width: 36rem; /* Wider for policy text */
            max-height: 80vh; /* Limit height to enable scrolling */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            border-radius: 0.75rem; /* Rounded corners for the policy modal */
        }
        #modal-content.show, #privacy-policy-modal-content.show {
            transform: scale(1);
            opacity: 1;
        }
        #modal-title, #privacy-policy-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 1rem;
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        #modal-message {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
        }
        #privacy-policy-text {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
            flex-grow: 1; /* Allow content to grow and take available space */
            overflow-y: auto; /* Enable vertical scrolling for content */
            padding-right: 0.5rem; /* Add some padding for scrollbar */
        }
        #modal-buttons, #privacy-policy-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
            padding-top: 0.5rem; /* Space between content and buttons */
        }
        #modal-cancel-btn, #privacy-policy-close-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            color: var(--text-color-primary);
            background-color: var(--border-color);
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-cancel-btn:hover, #privacy-policy-close-btn:hover {
            background-color: #d1d5db;
        }
        .dark-mode #modal-cancel-btn:hover, .dark-mode #privacy-policy-close-btn:hover {
            background-color: #6b7280;
        }
        #modal-cancel-btn.hidden {
            display: none;
        }
        #modal-ok-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            background-color: var(--button-bg-blue);
            color: #fff;
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-ok-btn:hover {
            background-color: var(--button-hover-blue);
        }
        /* Password input group and error */
        #modal-password-input-group {
            margin-bottom: 1.5rem; /* Spacing below the group */
            padding: 0.75rem; /* Internal padding for the group */
            border: 1px solid var(--input-border); /* Subtle border */
            border-radius: 0.5rem; /* Rounded corners */
            background-color: var(--input-bg-disabled); /* Light background */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .dark-mode #modal-password-input-group {
            background-color: var(--border-color); /* Darker background for dark mode */
        }
        #modal-password-input-group label {
            margin-bottom: 0.75rem; /* More space below label */
            padding-left: 0.25rem; /* Align text with input */
        }
        #modal-password-input {
            width: 100%;
            padding: 0.8rem; /* Slightly more padding for input field */
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
            font-size: 1rem; /* Ensure good readability */
        }
        #modal-password-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px var(--focus-ring-indigo); /* Slightly thicker focus ring */
            border-color: transparent;
        }
        #modal-password-error {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem;
            margin-top: 0.5rem;
            text-align: left;
            display: block; /* Ensure it takes its own line */
        }
        /* IMPORTANT: Force hidden elements to be display: none */
        .hidden {
            display: none !important;
        }


        /* Focus styles for buttons */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-blue);
        }
        #modal-cancel-btn:focus, #privacy-policy-close-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-gray);
        }
        #leave-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red);
        }
        #create-room-btn:focus, #send-message-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
        }
        #join-room-btn:focus, #join-random-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-purple);
        }

        /* Dark Mode Toggle Button */
        .dark-mode-toggle-container {
            /* Removed absolute positioning for chat screen, now part of flex header */
            z-index: 10; /* Ensure it's above other elements in the card */
            display: flex; /* To center emoji */
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Explicitly prevent shrinking */
        }
        /* Specific adjustment for the toggle button within the home screen */
        #home-screen .dark-mode-toggle-container {
           margin-top: 2rem;
        }
        #dark-mode-toggle, #dark-mode-toggle-chat {
            background-color: var(--card-bg);
            color: var(--text-color-primary); /* Icon color */
            border: none;
            border-radius: 9999px;
            padding: 0.75rem;
            font-size: 1.25rem; /* Controls emoji size */
            cursor: pointer;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        }
        #dark-mode-toggle:hover, #dark-mode-toggle-chat:hover {
            transform: scale(1.1);
        }
        #dark-mode-toggle:active, #dark-mode-toggle-chat:active {
            transform: scale(0.95);
        }

        /* Text Icon specific styles */
        .icon-moon-text { display: block; }
        .icon-sun-text { display: none; }
        .dark-mode .icon-moon-text { display: none; }
        .dark-mode .icon-sun-text { display: block; }


        /* Home Screen */
        #home-screen {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 28rem;
            text-align: center;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
            position: relative; /* For dark mode toggle positioning */
        }
        #home-screen.hidden {
            display: none;
        }
        #home-screen h1 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--header-text);
            margin-bottom: 1.5rem;
            letter-spacing: -0.025em;
        }
        #home-screen p {
            color: var(--text-color-secondary);
            margin-bottom: 2rem;
            font-size: 1.125rem;
        }
        #home-screen .input-group {
            margin-bottom: 1.5rem;
        }
        #home-screen .input-group label {
            display: block;
            text-align: left;
            color: var(--text-color-primary);
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        #home-screen input[type="text"],
        #home-screen input[type="number"], /* Added for max participants */
        #home-screen input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #home-screen input[type="text"]:focus,
        #home-screen input[type="number"]:focus,
        #home-screen input[type="password"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #home-screen #create-password-input-group.hidden {
            display: none;
        }
        #home-screen .button-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #home-screen button {
            width: 100%;
            padding: 0.75rem 1.5rem;
            color: #fff;
            font-weight: 600;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        #home-screen button:hover {
            transform: scale(1.05);
        }
        #create-room-btn {
            background-color: var(--button-bg-indigo);
        }
        #create-room-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #join-room-btn, #join-random-room-btn { /* Apply purple to both join buttons */
            background-color: var(--button-bg-purple);
            color: #fff; /* Ensure text is white for contrast */
        }
        #join-room-btn:hover, #join-random-room-btn:hover {
            background-color: var(--button-hover-purple);
        }
        #user-id-display {
            font-size: 0.75rem;
            color: var(--text-color-secondary);
            margin-top: 1.5rem;
        }

        /* Chat Room Screen */
        #chat-room-screen {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 42rem;
            display: flex;
            flex-direction: column;
            /* REVERTED: Fixed height for consistent scrolling */
            height: 85vh; 
            position: relative; /* Ensure it's relative as requested */
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
        }
        #chat-room-screen.hidden {
            display: none;
        }
        #chat-room-screen .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            gap: 0.25rem; /* Adjusted gap for tighter fit */
            flex-wrap: nowrap; /* Prevent wrapping/stacking on all screens */
        }
        /* Room Code: To appear fully and scale dynamically */
        #chat-room-screen h2 {
            font-size: clamp(1rem, 4vw, 1.875rem); /* Dynamically scales font size based on viewport width */
            font-weight: 700;
            color: var(--header-text);
            flex-grow: 1; /* Allows it to grow and take available space */
            flex-shrink: 1; /* Allow it to shrink if needed */
            text-align: center; /* Center the room code text */
            min-width: 0; /* Allows h2 to shrink down to 0 if necessary */
            /* REMOVED: overflow: hidden;, text-overflow: ellipsis;, white-space: nowrap; */
        }
        #current-room-code {
            color: var(--room-code-text);
        }
        /* Leave and Permanent Buttons: Text should appear with "..." if too large */
        #leave-room-btn {
            padding: 0.4rem 0.8rem; /* Smaller padding for compact size */
            font-size: 0.875rem; /* Smaller font size */
            background-color: var(--button-bg-red);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent button from shrinking */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #leave-room-btn:hover {
            background-color: var(--button-hover-red);
        }

        /* NEW: Styling for Permanent Mode Button */
        #toggle-permanent-mode-btn {
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.875rem; /* Smaller font size */
            background-color: var(--button-bg-blue);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent button from shrinking */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #toggle-permanent-mode-btn:hover {
            background-color: var(--button-hover-blue);
        }
        #toggle-permanent-mode-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* NEW: Styling for Permanent Room Indicator */
        #permanent-room-indicator {
            font-size: 0.55rem; /* Even smaller font */
            font-weight: 600;
            color: var(--room-code-text); /* Using room code text color for consistency */
            background-color: var(--participant-bg-you); /* Light background for visibility */
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
            white-space: nowrap; /* Prevent wrapping */
            flex-shrink: 0; /* Prevent from shrinking */
        }
        .dark-mode #permanent-room-indicator {
            background-color: var(--participant-bg-other);
        }


        #chat-room-screen .participants-section {
            margin-bottom: 1rem;
        }
        #chat-room-screen .participants-section h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 0.5rem;
        }
        #participants-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-color-secondary);
        }
        #participants-list span { /* This is the container for username and possibly remove button */
            display: flex; /* Use flex to align username and button */
            align-items: center; /* Vertically align items */
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
        }
        #participants-list span.bg-indigo-100 {
            background-color: var(--participant-bg-you);
            color: var(--participant-text-you);
            font-weight: 500;
        }
        #participants-list span.bg-gray-100 {
            background-color: var(--participant-bg-other);
            color: var(--text-color-primary);
        }
        .remove-participant-btn {
            background-color: transparent;
            color: var(--button-bg-red);
            border: none;
            padding: 0.1rem 0.3rem; /* Adjust padding for better visual */
            font-size: 0.9rem; /* Adjust size */
            font-weight: bold;
            border-radius: 0.25rem;
            margin-left: 0.5rem; /* Space between username and button */
            cursor: pointer;
            line-height: 1; /* Helps with vertical alignment */
        }
        .remove-participant-btn:hover {
            background-color: var(--button-hover-red);
            color: white;
        }
        .remove-participant-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red); /* Specific focus for remove button */
        }


        #messages-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: var(--chat-bg);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease;
        }
        #no-messages-yet {
            text-align: center;
            color: var(--text-color-secondary);
            font-style: italic;
            margin-top: 1rem;
        }
        #no-messages-yet.hidden {
            display: none;
        }

        .message-item {
            display: flex;
            margin-bottom: 0.75rem;
        }
        .message-item.justify-end {
            justify-content: flex-end;
        }
        .message-item.justify-start {
            justify-content: flex-start;
        }
        .message-content {
            max-width: 70%;
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .message-item.justify-end .message-content {
            background-color: var(--message-bg-you);
            color: var(--message-text-you);
            border-bottom-right-radius: 0;
        }
        .message-item.justify-start .message-content {
            background-color: var(--message-bg-other);
            color: var(--message-text-other);
            border-bottom-left-radius: 0;
        }
        .message-content .sender-info {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            opacity: 0.8;
        }
        .message-content p {
            font-size: 0.875rem;
            word-break: break-word;
        }
        .message-content .timestamp {
            text-align: right;
            font-size: 0.75rem;
            opacity: var(--message-timestamp-opacity);
            margin-top: 0.25rem;
        }

        #message-form {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        #new-message-input {
            flex-grow: 1;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #new-message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #new-message-input:disabled {
            background-color: var(--input-bg-disabled);
            cursor: not-allowed;
            color: var(--text-color-secondary);
        }
        #send-message-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--button-bg-indigo);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
        }
        #send-message-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #send-message-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Footnote */
        #app-footnote {
            margin-top: 2rem; /* Spacing from the main content */
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7); /* Light white for contrast on gradient background */
            text-align: center;
            padding-bottom: 1rem; /* Ensure it's not right at the bottom edge */
        }
        #app-footnote a {
            color: inherit; /* Inherit color from parent */
            text-decoration: underline;
            
            cursor: pointer;
        }
        #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        .dark-mode #app-footnote {
            color: rgba(255, 255, 255, 0.5); /* Slightly darker for dark mode */
        }
        .dark-mode #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Mode Selection Styles */
        #mode-selection {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            width: 100%; /* Ensure it takes full width of parent */
        }
        #mode-selection button {
            flex: 1;
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            background-color: var(--card-bg); /* Default background */
            color: var(--text-color-primary); /* Default text color */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #mode-selection button.active {
            background-color: var(--button-bg-purple); /* Changed to purple */
            color: #fff;
            box-shadow: var(--button-shadow-offset) var(--button-bg-purple), var(--button-shadow-blur) var(--button-bg-purple); /* Changed to purple */
        }
        #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Lighter hover for non-active */
        }
        .dark-mode #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Darker hover for non-active */
        }

        /* Mode Containers */
        #default-mode-container,
        #random-mode-container {
            width: 100%;
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            gap: 1.5rem; /* Consistent spacing between input groups */
        }
        #default-mode-container.hidden,
        #random-mode-container.hidden {
            display: none;
        }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem; /* Re-added padding for overall layout */
                align-items: center; /* Re-centered content */
                justify-content: center; /* Re-centered content */
            }
            #home-screen {
                margin-top: 0; /* Remove specific mobile margins if body is centered */
                margin-bottom: 0;
            }
            #chat-room-screen {
                padding: 1.5rem;
                max-width: 100%;
                border-radius: 0.75rem; /* Restore border-radius */
                /* Reverted to original height and positioning for mobile */
                height: 85vh; /* Keep consistent height */
                position: relative; /* Keep consistent positioning */
            }
            #chat-room-screen .header {
                /* REVERTED: Keep header items in a row, prevent stacking */
                flex-direction: row; /* Ensure row direction */
                align-items: center; /* Vertically align items */
                flex-wrap: nowrap; /* Prevent wrapping/stacking */
                gap: 0.25rem; /* Keep original gap */
            }
            #chat-room-screen .header .dark-mode-toggle-container {
                /* REVERTED: Remove align-self, let flexbox handle it */
                align-self: auto; 
                margin-right: 0;
            }
            #chat-room-screen h2 {
                /* REMOVED: font-size: 1.5rem; */
                text-align: center; /* Keep room code centered */
                min-width: unset; 
            }
            #leave-room-btn, #toggle-permanent-mode-btn {
                /* REVERTED: Remove full width, let flex-shrink handle it */
                width: auto; 
                padding: 0.4rem 0.8rem; /* Keep smaller padding for touch targets */
                font-size: 0.875rem;
            }
            #permanent-room-indicator {
                align-self: center; /* Center the indicator if stacked */
            }

            #home-screen h1 {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }
            #home-screen p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }
            #home-screen .input-group {
                margin-bottom: 1rem;
            }
            #home-screen .button-group {
                gap: 0.75rem;
            }
            
            #chat-room-screen .participants-section h3 {
                font-size: 1rem;
            }
            #participants-list span {
                font-size: 0.75rem;
                padding: 0.2rem 0.6rem;
            }
            .remove-participant-btn {
                font-size: 0.8rem; /* Slightly smaller on mobile */
                padding: 0.1rem 0.25rem;
            }
            .message-content {
                max-width: 85%;
                padding: 0.6rem;
            }
            .message-content .sender-info, .message-content p, .message-content .timestamp {
                font-size: 0.8rem;
            }
            #message-form {
                flex-direction: column;
                gap: 0.5rem;
            }
            #new-message-input, #send-message-btn {
                width: 100%;
                padding: 0.6rem;
            }
            #send-message-btn {
                padding: 0.6rem 1rem;
            }
            /* Adjust dark mode toggle position for mobile in chat screen */
            #chat-room-screen .header .dark-mode-toggle-container {
                /* No specific right/left needed, flexbox handles it */
                margin-right: 0.5rem; /* Small margin to the right of the toggle */
            }
            #mode-selection {
                flex-direction: column;
            }
            #default-mode-container,
            #random-mode-container {
                gap: 1rem; /* Smaller gap on mobile */
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="loading-screen">
        <div class="text-2xl font-bold">Loading Textroll...</div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-content">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="input-group hidden" id="modal-password-input-group">
                <label for="modal-password-input" class="hidden">Enter password:</label>
                <input type="password" id="modal-password-input" placeholder="Room password" />
                <span id="modal-password-error" class="hidden"></span> </div>
            <div id="modal-buttons">
                <button id="modal-cancel-btn" class="hidden">
                    Cancel
                </button>
                <button id="modal-ok-btn">
                    OK
                </button>
            </div>
        </div>
    </div>

    <div id="privacy-policy-modal-overlay" class="hidden">
        <div id="privacy-policy-modal-content">
            <h3 id="privacy-policy-title">Privacy Policy for Textroll Web Chat</h3>
            <div id="privacy-policy-text">
                <p><strong>1. Data Collection:</strong> We collect your chosen username and a unique user ID generated by Firebase Authentication for the purpose of identifying you within chat rooms. Room codes and messages sent within rooms are stored temporarily on our Firebase Firestore database to facilitate real-time communication. We do NOT collect any personally identifiable information beyond your chosen username and the Firebase-generated user ID.</p>
                <p><strong>2. Data Usage:</strong> Your username and user ID are used solely to display your identity in chat rooms and manage your participation. Room data (including messages) is used to enable chat functionality. We do not use your data for advertising, tracking, or any other commercial purposes.</p>
                <p><strong>3. Data Storage and Deletion:</strong> Chat rooms and their messages are designed to be temporary. Rooms are automatically deleted if they become empty (no participants) or if there is no activity (no messages sent or users joining/leaving) for 15 minutes. Permanent rooms, if enabled by the host and secured with a password, will persist even when empty, but will be deleted after 1 week of inactivity (no messages sent or users joining/leaving).</p>
                <p><strong>4. Security:</strong> We use Firebase Firestore, which provides robust security features. However, please remember that random and unmoderated chat rooms inherently carry risks. Do NOT share sensitive personal information (e.g., real name, address, phone password, financial details) in Textroll chat rooms.</p>
                <p><strong>5. Encryption Algorithm (Deprecated):</strong> All sensitive data, including chat messages, room codes, usernames, and room passwords, are encrypted using a custom substitution cipher (Hashtik V2). While this algorithm provides a basic level of obfuscation, it is considered **deprecated** and is not cryptographically robust against advanced attacks. It is primarily used here to prevent casual snooping of data directly from the database. For highly sensitive communications, a more modern and robust encryption standard would be required. This algorithm is intended for future updates to a more secure method.</p>
                <p><strong>6. Changes to this Policy:</strong> We may update this privacy policy from time to time. Any changes will be reflected directly within the app. Your continued use of the app after such changes constitutes your acceptance of the new policy.</p>
                <p><strong>7. Contact:</strong> For any privacy-related questions, please contact us through the platform where you accessed this application.</p>
            </div>
            <div id="privacy-policy-buttons">
                <button id="privacy-policy-close-btn">
                    Close
                </button>
            </div>
        </div>
    </div>


    <div id="home-screen" class="hidden">
        
        <h1>Textroll</h1>
        <p>
            Connect and chat anonymously with friends or strangers!
        </p>
        <div class="dark-mode-toggle-container">
            <button id="dark-mode-toggle">
                <span class="icon-moon-text">🌙</span>
                <span class="icon-sun-text">☀️</span>
                </button>
        </div>
        <br><br>

        <div id="mode-selection">
            <button id="default-mode-btn" class="active">Default Mode</button>
            <button id="random-mode-btn">Random Mode</button>
        </div>

        <div id="default-mode-container">
            <div class="input-group">
                <label for="username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="username-input"
                    placeholder="e.g., ChatMaster"
                    maxlength="15"
                />
            </div>

            <div class="input-group" id="create-password-input-group" style="display: none;">
                <label for="create-password-input">
                    Set a room password (optional):
                </label>
                <input
                    type="password"
                    id="create-password-input"
                    placeholder="Leave blank for no password"
                    maxlength="20"
                />
            </div>

            <div class="input-group">
                <label for="max-participants-input">
                    Max Participants (2-10):
                </label>
                <input
                    type="number"
                    id="max-participants-input"
                    value="4"
                    min="2"
                    max="10"
                />
            </div>

            <div class="input-group">
                <label for="room-code-input">
                    Or enter a room code to join:
                </label>
                <input
                    type="text"
                    id="room-code-input"
                    placeholder="e.g., ABCDEF"
                    maxlength="6"
                />
            </div>

            <div class="button-group">
                <button id="create-room-btn">
                    Create New Room
                </button>
                <button id="join-room-btn">
                    Join Room
                </button>
            </div>
        </div>

        <div id="random-mode-container" class="hidden">
            <div class="input-group">
                <label for="random-username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="random-username-input"
                    placeholder="e.g., AnonymousChatter"
                    maxlength="15"
                />
            </div>
            <div class="button-group">
                <button id="join-random-room-btn">
                    Join Random Room
                </button>
            </div>
        </div>

        <p id="user-id-display"></p>
    </div>

    <div id="chat-room-screen" class="hidden">
        <div class="header">
            <div class="dark-mode-toggle-container">
                <button id="dark-mode-toggle-chat">
                    <span class="icon-moon-text">🌙</span>
                    <span class="icon-sun-text">☀️</span>
                </button>
            </div>
            <h2>
                Room: <span id="current-room-code"></span>
                <!-- NEW: Permanent Room Indicator -->
                <span id="permanent-room-indicator" class="hidden">PUBLIC</span>
            </h2>
            <!-- NEW: Toggle Permanent Mode Button -->
            <button id="toggle-permanent-mode-btn" class="hidden">
                Perma
            </button>
            <button id="leave-room-btn">
                Leave
            </button>
        </div>

        <div class="participants-section">
            <h3>Participants (<span id="participants-count">0</span>/<span id="max-participants-display">4</span>):</h3>
            <div id="participants-list">
                </div>
        </div>

        <div id="messages-container" class="custom-scrollbar">
            <p id="no-messages-yet" class="hidden">No messages yet. Start the conversation!</p>
            <div id="messages-end-ref"></div> </div>

        <form id="message-form">
            <input
                type="text"
                id="new-message-input"
                placeholder="Type your message..."
            />
            <button
                type="submit"
                id="send-message-btn"
            >
                Send
            </button>
        </form>
    </div>

    <div id="app-footnote">
        Made by <a id="jdc-link" href="https://altroweb.github.io/justdevcrap">JustDevCrap.</a> With ☕. <a id="privacy-policy-link">Privacy Policy</a>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GithubAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc, serverTimestamp, arrayUnion, arrayRemove, runTransaction, query, where, getDocs, orderBy, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA8ErpL72u6bTzPuOx51l4Mb51NDCDBDBY", // Replace with your actual API key if necessary
            authDomain: "textroll-79302.firebaseapp.com",
            projectId: "textroll-79302",
            storageBucket: "textroll-79302.firebaseapp.com",
            messagingSenderId: "928701458132",
            appId: "1:928701458132:web:5eec69352bd35998023d41",
            measurementId: "G-DP3QEKB09S"
        };

        const textrollAppId = firebaseConfig.projectId;
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // DOM Elements
        const loadingScreen = document.getElementById('loading-screen');
        const homeScreen = document.getElementById('home-screen');
        const chatRoomScreen = document.getElementById('chat-room-screen');
        const modeSelection = document.getElementById('mode-selection');
        const defaultModeBtn = document.getElementById('default-mode-btn');
        const randomModeBtn = document.getElementById('random-mode-btn');
        const defaultModeContainer = document.getElementById('default-mode-container');
        const randomModeContainer = document.getElementById('random-mode-container');
        const usernameInput = document.getElementById('username-input');
        const createPasswordInputGroup = document.getElementById('create-password-input-group');
        const createPasswordInput = document.getElementById('create-password-input');
        const maxParticipantsInput = document.getElementById('max-participants-input');
        const roomCodeInput = document.getElementById('room-code-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const randomUsernameInput = document.getElementById('random-username-input');
        const joinRandomRoomBtn = document.getElementById('join-random-room-btn');
        const userIdDisplay = document.getElementById('user-id-display');
        const currentRoomCodeDisplay = document.getElementById('current-room-code');
        const participantsCount = document.getElementById('participants-count');
        const maxParticipantsDisplay = document.getElementById('max-participants-display');
        const participantsList = document.getElementById('participants-list');
        const messagesContainer = document.getElementById('messages-container');
        const noMessagesYet = document.getElementById('no-messages-yet');
        const messagesEndRef = document.getElementById('messages-end-ref');
        const newMessageInput = document.getElementById('new-message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const messageForm = document.getElementById('message-form');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalPasswordInputGroup = document.getElementById('modal-password-input-group');
        const modalPasswordInput = document.getElementById('modal-password-input');
        const modalPasswordError = document.getElementById('modal-password-error');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const privacyPolicyLink = document.getElementById('privacy-policy-link');
        const privacyPolicyModalOverlay = document.getElementById('privacy-policy-modal-overlay');
        const privacyPolicyModalContent = document.getElementById('privacy-policy-modal-content');
        const privacyPolicyCloseBtn = document.getElementById('privacy-policy-close-btn');
        const darkModeToggleHome = document.getElementById('dark-mode-toggle');
        const darkModeToggleChat = document.getElementById('dark-mode-toggle-chat');
        const iconMoonHome = darkModeToggleHome.querySelector('.icon-moon-text');
        const iconSunHome = darkModeToggleHome.querySelector('.icon-sun-text');
        const iconMoonChat = darkModeToggleChat.querySelector('.icon-moon-text');
        const iconSunChat = darkModeToggleChat.querySelector('.icon-sun-text');

        // NEW DOM Elements for permanent room feature
        const permanentRoomIndicator = document.getElementById('permanent-room-indicator');
        const togglePermanentModeBtn = document.getElementById('toggle-permanent-mode-btn');


        // Application State
        let currentUserId = null;
        // currentRoom will now store the Firestore document ID (internalId) and the decrypted room code (code)
        let currentRoom = null; // Will store { internalId, code, users, maxParticipants, password, hostId, isPermanent, permanentLastActivity }
        let unsubscribeRoomListener = null;
        let unsubscribeMessagesListener = null;
        let currentMode = 'default';
        let inactivityTimer = null;
        const INACTIVITY_TIMEOUT_MS = 15 * 60 * 1000; // 15 minutes
        const PERMANENT_INACTIVITY_TIMEOUT_MS = 7 * 24 * 60 * 60 * 1000; // 1 week in milliseconds
        // currentUserObject will store { userId, username (decrypted), joinTimestamp }
        let currentUserObject = null; 

        // --- Encryption/Decryption Constants and Functions from hashtik-solo-v2.html ---
        const ID_LENGTH = 16; // Fixed length for the hexadecimal seed/ID

        // Character Set Generation
        function generateCharacterSet() {
            let chars = [];
            // Printable ASCII (U+0020 to U+007E)
            for (let i = 0x20; i <= 0x7E; i++) {
                chars.push(String.fromCharCode(i));
            }
            // Latin-1 Supplement (U+00A0 to U+00FF)
            for (let i = 0xA0; i <= 0xFF; i++) {
                chars.push(String.fromCharCode(i));
            }
            // Latin Extended-A (U+0100 to U+017F)
            for (let i = 0x100; i <= 0x17F; i++) {
                chars.push(String.fromCharCode(i));
            }
            // General Punctuation (U+2000 to U+206F)
            for (let i = 0x2000; i <= 0x206F; i++) {
                chars.push(String.fromCharCode(i));
            }
            // Currency Symbols (U+20A0 to U+20CF)
            for (let i = 0x20A0; i <= 0x20CF; i++) {
                chars.push(String.fromCharCode(i));
            }
            // Mathematical Operators (U+2200 to U+22FF)
            for (let i = 0x2200; i <= 0x22FF; i++) {
                chars.push(String.fromCharCode(i));
            }
            // Geometric Shapes (U+25A0 to U+25FF)
            for (let i = 0x25A0; i <= 0x25FF; i++) {
                chars.push(String.fromCharCode(i));
            }
            // Dingbats (U+2700 to U+27BF)
            for (let i = 0x2700; i <= 0x27BF; i++) {
                chars.push(String.fromCharCode(i));
            }

            // A selection of common emojis (represented as surrogate pairs or single code points)
            const commonEmojis = [
                '😀', '😂', '😍', '👍', '🙏', '🚀', '🌟', '💡', '🎉', '🔥', '❤️', '✅', '❌', '✨', '🎶', '🌈', '🐶', '🐱', '🍎', '🍕',
                '🤔', '😊', '🥳', '🤯', '😭', '😎', '🤩', '💯', '👋', '👏', '🙌', '🤞', '👌', '💪', '🧠', '👀', '🗣️', '💬', '💭', '🌍',
                '🌙', '☀️', '☁️', '☔', '⚡', '❄️', '🌸', '🍂', '🍁', '🌱', '🌳', '🌊', '🐠', '🐬', '🐢', '🦋', '🐝', '🐞', '🐜', '🕷️',
                '🍔', '🍟', '🍦', '🍩', '🍪', '🍫', '🍬', '🍭', '☕', '🍵', '🥂', '🍻', '🍷', '🍸', '🍹', '🧉', '🍼', '🥛', '🍞', '🧀'
            ];
            chars = chars.concat(commonEmojis);
            return [...new Set(chars)];
        }
        const CHARACTER_SET = generateCharacterSet();

        // Pseudo-Random Number Generator (PRNG)
        class PRNG {
            constructor(seedString) {
                let s0 = 0x87654321;
                let s1 = 0x12345678;

                if (typeof seedString === 'string' && seedString.length > 0) {
                    for (let i = 0; i < seedString.length; i++) {
                        s0 = ((s0 << 5) + s0) ^ seedString.charCodeAt(i);
                        s1 = ((s1 << 5) + s1) ^ seedString.charCodeAt((i + 1) % seedString.length);
                    }
                } else {
                    s0 = Math.floor(Math.random() * 0xFFFFFFFF);
                    s1 = Math.floor(Math.random() * 0xFFFFFFFF);
                }

                this.state0 = s0 === 0 ? 1 : s0;
                this.state1 = s1 === 0 ? 2 : s1;
            }

            next() {
                let s0 = this.state0;
                let s1 = this.state1;

                s1 ^= s0;
                s0 = ((s0 << 26) | (s0 >>> 6));
                s0 += s1;
                s1 = ((s1 << 9) | (s1 >>> 23));
                s1 += s0;

                this.state0 = s0;
                this.state1 = s1;

                return (s0 + s1) >>> 0;
            }

            random() {
                return this.next() / 0x100000000;
            }
        }

        // Generates a random 16-character hexadecimal seed
        function generateRandomSeed() {
            let seed = '';
            if (window.crypto && window.crypto.getRandomValues) {
                const randomBytes = new Uint8Array(ID_LENGTH / 2);
                window.crypto.getRandomValues(randomBytes);
                for (let i = 0; i < randomBytes.length; i++) {
                    seed += randomBytes[i].toString(16).padStart(2, '0');
                }
            } else {
                for (let i = 0; i < ID_LENGTH; i++) {
                    seed += Math.floor(Math.random() * 16).toString(16);
                }
            }
            return seed;
        }

        // Deterministically shuffles an array using the provided PRNG
        function deterministicShuffle(array, prng) {
            const shuffledArray = [...array];
            for (let i = shuffledArray.length - 1; i > 0; i--) {
                const j = Math.floor(prng.random() * (i + 1));
                [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
            }
            return shuffledArray;
        }

        // Generates the forward and reverse mapping based on a seed
        function generateMapping(seed) {
            const prng = new PRNG(seed);
            const originalChars = [...CHARACTER_SET];
            const shuffledChars = deterministicShuffle(originalChars, prng);

            const forwardMap = new Map();
            const reverseMap = new Map();

            for (let i = 0; i < originalChars.length; i++) {
                forwardMap.set(originalChars[i], shuffledChars[i]);
                reverseMap.set(shuffledChars[i], originalChars[i]);
            }
            return { forwardMap, reverseMap };
        }

        /**
         * Encrypts a given plaintext message using Hashtik V2.
         * @param {string} plaintext The message to encrypt.
         * @returns {string|null} The encrypted string with master seed prepended, or null if input is invalid.
         */
        function encryptMessage(plaintext) {
            if (!plaintext || !plaintext.trim()) {
                return null;
            }

            const seed = generateRandomSeed();
            const { forwardMap } = generateMapping(seed);

            let encrypted = '';
            for (const char of plaintext) {
                encrypted += forwardMap.has(char) ? forwardMap.get(char) : char;
            }

            return seed + encrypted;
        }

        /**
         * Decrypts a given encrypted message using Hashtik V2.
         * @param {string} encryptedText The encrypted message string.
         * @returns {string} The decrypted plaintext, or an error message if decryption fails.
         */
        function decryptMessage(encryptedText) {
            if (!encryptedText || typeof encryptedText !== 'string' || !encryptedText.trim()) {
                return ""; // Return empty string for empty or invalid input
            }

            if (encryptedText.length < ID_LENGTH) {
                console.error(`Invalid encrypted text: ID must be ${ID_LENGTH} characters long.`);
                return "[Decryption Error: Invalid Format]";
            }

            const seed = encryptedText.substring(0, ID_LENGTH);
            const cipherText = encryptedText.substring(ID_LENGTH);

            if (!/^[0-9a-fA-F]{16}$/.test(seed)) {
                 console.error('Invalid ID format in encrypted message.');
                 return "[Decryption Error: Invalid ID]";
            }

            const { reverseMap } = generateMapping(seed);

            let decrypted = '';
            for (const char of cipherText) {
                decrypted += reverseMap.has(char) ? reverseMap.get(char) : char;
            }
            return decrypted;
        }
        // --- End Encryption/Decryption Functions ---


        // Utility to generate room code
        const generateRoomCode = () => {
            let result = '';
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            for (let i = 0; i < 6; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        };

        // Modal display functions
        const showModal = (title, message, onConfirmCallback, showCancel = false, onCancelCallback = () => hideModal(), showPasswordInput = false) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.toggle('hidden', !showCancel);
            modalPasswordInputGroup.classList.add('hidden');
            modalPasswordError.classList.add('hidden');
            if (showPasswordInput) {
                modalPasswordInputGroup.classList.remove('hidden');
            }
            modalPasswordInput.value = '';
            modalOkBtn.onclick = async () => { await onConfirmCallback(); };
            modalCancelBtn.onclick = () => { onCancelCallback(); hideModal(); };
            modalOverlay.classList.remove('hidden');
            setTimeout(() => modalContent.classList.add('show'), 10);
        };
        const hideModal = () => {
            modalContent.classList.remove('show');
            setTimeout(() => {
                modalOverlay.classList.add('hidden');
                modalPasswordInputGroup.classList.add('hidden');
                modalPasswordError.classList.add('hidden');
            }, 300);
        };
        const showPrivacyPolicyModal = () => {
            privacyPolicyModalOverlay.classList.remove('hidden');
            setTimeout(() => privacyPolicyModalContent.classList.add('show'), 10);
        };
        const hidePrivacyPolicyModal = () => {
            privacyPolicyModalContent.classList.remove('show');
            setTimeout(() => privacyPolicyModalOverlay.classList.add('hidden'), 300);
        };

        // UI Update Logic
        const updateUI = () => {
            loadingScreen.classList.add('hidden');
            if (currentRoom) {
                homeScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('hidden');
                chatRoomScreen.classList.add('animate-scaleIn');
                homeScreen.classList.remove('animate-scaleIn');
                currentRoomCodeDisplay.textContent = currentRoom.code; // Display decrypted code
                renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                maxParticipantsDisplay.textContent = currentRoom.maxParticipants || 4;
                const isCurrentUserInRoom = currentRoom.users.some(u => u.userId === currentUserId);
                newMessageInput.disabled = !isCurrentUserInRoom;
                sendMessageBtn.disabled = !isCurrentUserInRoom;
                updatePermanentModeUI(); // NEW: Update permanent mode UI
            } else {
                homeScreen.classList.remove('hidden');
                homeScreen.classList.add('animate-scaleIn');
                chatRoomScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('animate-scaleIn');
                updateModeUI(currentMode);
            }
        };

        // NEW: Function to update the permanent mode button and indicator UI
        const updatePermanentModeUI = () => {
            if (!currentRoom) {
                togglePermanentModeBtn.classList.add('hidden');
                permanentRoomIndicator.classList.add('hidden');
                return;
            }
            const isHost = currentUserId === currentRoom.hostId;
            const isPermanent = currentRoom.isPermanent;
            // const hasPassword = currentRoom.password; // Removed password check for permanent mode

            togglePermanentModeBtn.classList.toggle('hidden', !isHost); // Only host sees the button
            // Shortened text for the button
            togglePermanentModeBtn.textContent = isPermanent ? 'Temp' : 'Perma';
            // Always enable the button for the host, regardless of password
            togglePermanentModeBtn.disabled = false; 

            permanentRoomIndicator.classList.toggle('hidden', !isPermanent); // Show indicator if permanent
        };

        // Render participants with remove button for host
        const renderParticipants = (users, hostId) => {
            participantsList.innerHTML = '';
            participantsCount.textContent = users.length;
            const isHost = currentUserId === hostId;

            users.forEach(user => {
                const participantSpan = document.createElement('span');
                participantSpan.className = `${user.userId === currentUserId ? 'bg-indigo-100' : 'bg-gray-100'}`;
                
                // Decrypt username for display
                const decryptedUsername = decryptMessage(user.username);
                const usernameText = document.createTextNode(`${decryptedUsername} ${user.userId === currentUserId ? '(You)' : ''} ${user.userId === hostId ? '(Host)' : ''}`);
                participantSpan.appendChild(usernameText);

                if (isHost && user.userId !== currentUserId) { // Host can remove others
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-participant-btn';
                    removeBtn.textContent = '✕'; // Using a multiplication X, or use an SVG/icon font
                    removeBtn.title = `Remove ${decryptedUsername}`;
                    removeBtn.onclick = () => handleRemoveParticipant(user);
                    participantSpan.appendChild(removeBtn);
                }
                participantsList.appendChild(participantSpan);
            });
        };
        
        // Function for host to remove a participant
        const handleRemoveParticipant = async (userToRemove) => {
            if (!currentRoom || currentUserId !== currentRoom.hostId) {
                showModal("Error", "Only the host can remove participants.", () => hideModal());
                return;
            }
            // Decrypt username for display in modal
            const decryptedUsernameToRemove = decryptMessage(userToRemove.username);

            showModal(
                "Remove Participant", 
                `Are you sure you want to remove ${decryptedUsernameToRemove} from the room?`,
                async () => {
                    const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.internalId); // Use internalId
                    try {
                        await runTransaction(db, async (transaction) => {
                            const roomDoc = await transaction.get(roomRef);
                            if (!roomDoc.exists()) {
                                throw new Error("Room does not exist.");
                            }
                            const roomData = roomDoc.data();
                            const usersInRoom = roomData.users || [];
                            
                            // Find the exact user object in Firestore to remove by matching encrypted username and userId
                            const userObjectInFirestore = usersInRoom.find(u => u.userId === userToRemove.userId && u.username === userToRemove.username);

                            if (userObjectInFirestore) {
                                const updateFields = { users: arrayRemove(userObjectInFirestore), lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) { // NEW: Update permanentLastActivity if permanent
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                transaction.update(roomRef, updateFields);
                            } else {
                                console.warn(`User ${decryptedUsernameToRemove} not found in Firestore for removal.`);
                            }
                        });
                        hideModal(); // Hide confirmation modal
                    } catch (error) {
                        console.error("Error removing participant:", error);
                        showModal("Removal Failed", `Failed to remove ${decryptedUsernameToRemove}. Please try again.`, () => hideModal());
                    }
                },
                true // Show cancel button
            );
        };


        // Render messages (filtered by joinTimestamp)
        const renderMessages = (messages) => {
            messagesContainer.innerHTML = '';
            const currentUserJoinTimestamp = currentRoom?.users?.find(u => u.userId === currentUserId)?.joinTimestamp;
            const currentUserJoinTime = currentUserJoinTimestamp instanceof Date ? currentUserJoinTimestamp.getTime() : (currentUserJoinTimestamp?.toDate ? currentUserJoinTimestamp.toDate().getTime() : 0);

            const filteredMessages = messages.filter(msg => {
                if (!currentUserJoinTime || !msg.timestamp) return true;
                const messageTime = msg.timestamp instanceof Date ? msg.timestamp.getTime() : (msg.timestamp.toDate ? msg.timestamp.toDate().getTime() : 0);
                return messageTime >= currentUserJoinTime;
            });

            if (filteredMessages.length === 0) {
                noMessagesYet.classList.remove('hidden');
            } else {
                noMessagesYet.classList.add('hidden');
                filteredMessages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message-item ${msg.senderId === currentUserId ? 'justify-end' : 'justify-start'}`;
                    const contentDiv = document.createElement('div');
                    contentDiv.className = "message-content";
                    const senderSpan = document.createElement('div');
                    senderSpan.className = "sender-info";
                    // Decrypt sender username for display
                    const decryptedSenderUsername = decryptMessage(msg.senderUsername);
                    senderSpan.textContent = msg.senderId === currentUserId ? 'You' : decryptedSenderUsername;
                    const textP = document.createElement('p');
                    
                    // Decrypt the message text before displaying
                    const decryptedText = decryptMessage(msg.text);
                    textP.textContent = decryptedText;

                    const timestampDiv = document.createElement('div');
                    timestampDiv.className = "timestamp";
                    const date = msg.timestamp ? (msg.timestamp instanceof Date ? msg.timestamp : msg.timestamp.toDate()) : null;
                    timestampDiv.textContent = date ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                    contentDiv.appendChild(senderSpan);
                    contentDiv.appendChild(textP);
                    contentDiv.appendChild(timestampDiv);
                    messageDiv.appendChild(contentDiv);
                    messagesContainer.appendChild(messageDiv);
                });
            }
            messagesContainer.appendChild(messagesEndRef);
            messagesEndRef.scrollIntoView({ behavior: 'smooth' });
        };

        // Firebase Auth
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = `Your User ID: ${currentUserId}`;
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Error signing in:", error);
                    showModal("Authentication Error", "Could not sign in. Please try again.", () => hideModal());
                }
            }
            updateUI();
        });

        // Create Room
        const createRoom = async (username, password = null, maxParticipants = 4) => {
            const roomsCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms`);
            const roomDocRef = doc(roomsCollectionRef); // Generate a new, random Firestore document ID

            const humanReadableRoomCode = generateRoomCode();
            const encryptedRoomCode = encryptMessage(humanReadableRoomCode); // Encrypt the human-readable code
            const encryptedUsername = encryptMessage(username); // Encrypt the username
            const encryptedPassword = password ? encryptMessage(password) : null; // Encrypt password if present

            const user = { userId: currentUserId, username: encryptedUsername, joinTimestamp: new Date() };
            const roomData = {
                encryptedCode: encryptedRoomCode, // Store encrypted room code
                users: [user],
                hostId: currentUserId, // Set hostId on creation
                createdAt: serverTimestamp(),
                lastActivity: serverTimestamp(),
                maxParticipants: maxParticipants,
                isPermanent: false,
                permanentLastActivity: null
            };
            if (encryptedPassword) roomData.password = encryptedPassword; // Store encrypted password

            try {
                await setDoc(roomDocRef, roomData);
                currentUserObject = { userId: currentUserId, username: username, joinTimestamp: new Date() }; // Store decrypted username locally
                window.addEventListener('beforeunload', handlePageExit);
                // Return data including the internal Firestore ID and the decrypted human-readable code
                return { 
                    internalId: roomDocRef.id, 
                    code: humanReadableRoomCode, 
                    users: [currentUserObject], // Return with decrypted username for local use
                    maxParticipants: maxParticipants, 
                    password: password, // Return decrypted password for local use
                    hostId: currentUserId, 
                    isPermanent: false, 
                    permanentLastActivity: null 
                }; 
            } catch (error) {
                console.error("Error creating room:", error);
                showModal("Creation Failed", "Failed to create room. Please try again.", () => hideModal());
                return null;
            }
        };

        createRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const password = createPasswordInput.value.trim();
            const maxParticipants = parseInt(maxParticipantsInput.value, 10);
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => hideModal());
                return;
            }
            if (isNaN(maxParticipants) || maxParticipants < 2 || maxParticipants > 10) {
                showModal("Invalid Max Participants", "Please set max participants between 2 and 10.", () => hideModal());
                return;
            }
            const room = await createRoom(username, password || null, maxParticipants);
            if (room) {
                currentRoom = room; // currentRoom now includes internalId and decrypted code
                roomCodeInput.value = room.code; // Display decrypted code
                createPasswordInput.value = '';
                await setupRoomListeners(room.internalId); // Use internalId for listener
                updateUI();
            }
        });

        // Join Room Transaction
        const performJoinRoomTransaction = async (roomInternalId, roomCode, username, roomMaxParticipants, roomPassword = null, hostId = null, isPermanent = false, permanentLastActivity = null) => {
            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomInternalId);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("Room no longer exists");
                    const roomData = roomDoc.data();
                    let usersInRoom = roomData.users || []; // These usernames are encrypted

                    const maxAllowedUsers = roomData.maxParticipants || roomMaxParticipants || 4;
                    const encryptedUsername = encryptMessage(username); // Encrypt username for storage

                    let existingUserIndex = usersInRoom.findIndex(u => u.userId === currentUserId);

                    if (existingUserIndex !== -1) {
                        // If user already exists, update their entry (e.g., joinTimestamp, username if it changed)
                        usersInRoom[existingUserIndex].joinTimestamp = new Date();
                        usersInRoom[existingUserIndex].username = encryptedUsername; // Update with encrypted username
                    } else {
                        // Check for username uniqueness by decrypting existing usernames
                        const isUsernameTaken = usersInRoom.some(u => decryptMessage(u.username).toLowerCase() === username.toLowerCase());
                        if (isUsernameTaken) throw new Error("Username taken (re-check)");
                        
                        if (usersInRoom.length >= maxAllowedUsers) throw new Error("Room full (re-check)");
                        
                        const newUser = { userId: currentUserId, username: encryptedUsername, joinTimestamp: new Date() };
                        usersInRoom.push(newUser);
                    }
                    
                    const updateFields = { users: usersInRoom, lastActivity: serverTimestamp() };
                    if (roomData.isPermanent) {
                        updateFields.permanentLastActivity = serverTimestamp();
                    }
                    transaction.update(roomRef, updateFields);

                    // Reconstruct currentRoom object with decrypted values for local UI state
                    const decryptedUsers = usersInRoom.map(u => ({ ...u, username: decryptMessage(u.username) }));
                    const decryptedPassword = roomData.password ? decryptMessage(roomData.password) : null;

                    currentRoom = { 
                        internalId: roomInternalId,
                        code: roomCode, // This is already the decrypted code passed in
                        users: decryptedUsers, 
                        maxParticipants: maxAllowedUsers, 
                        password: decryptedPassword,
                        hostId: roomData.hostId || hostId,
                        isPermanent: roomData.isPermanent || isPermanent,
                        permanentLastActivity: roomData.permanentLastActivity || permanentLastActivity
                    };
                });
                currentUserObject = currentRoom.users.find(u => u.userId === currentUserId); // Find with decrypted username
                if (currentUserObject) window.addEventListener('beforeunload', handlePageExit);
                else console.error("Could not find current user object after join transaction.");
                await setupRoomListeners(roomInternalId); // Use internalId for listener
                updateUI();
                hideModal();
            } catch (error) {
                console.error("Error joining room (transaction):", error);
                let errorMessage = "Failed to join room. Please try again.";
                if (error.message.includes("Room full")) errorMessage = "Room is now full.";
                if (error.message.includes("Username taken")) errorMessage = "Username was taken.";
                if (error.message.includes("Room no longer exists")) errorMessage = "The room no longer exists.";
                showModal("Join Failed", errorMessage, () => hideModal());
            }
        };

        joinRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const enteredRoomCode = roomCodeInput.value.trim().toUpperCase(); // User entered, human-readable code
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => hideModal());
                return;
            }
            if (!enteredRoomCode) {
                showModal("Invalid Room Code", "Please enter a room code.", () => hideModal());
                return;
            }

            const roomsCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms`);
            let foundRoomDoc = null;
            let roomInternalId = null;

            // Step 1: Query all rooms and decrypt their codes to find a match
            try {
                const querySnapshot = await getDocs(roomsCollectionRef);
                for (const docSnap of querySnapshot.docs) {
                    const roomData = docSnap.data();
                    const decryptedCode = decryptMessage(roomData.encryptedCode);
                    if (decryptedCode === enteredRoomCode) {
                        foundRoomDoc = docSnap;
                        roomInternalId = docSnap.id; // Get the Firestore internal ID
                        break;
                    }
                }
            } catch (error) {
                console.error("Error searching for room by decrypted code:", error);
                showModal("Search Error", "Failed to search for room. Please try again.", () => hideModal());
                return;
            }

            if (!foundRoomDoc) {
                showModal("Room Not Found", "Room code does not exist.", () => hideModal());
                return;
            }

            const roomData = foundRoomDoc.data();
            const currentUsers = roomData.users || []; // These usernames are encrypted
            const maxAllowedUsers = roomData.maxParticipants || 4;
            
            // Check if username is taken (case-insensitive) by decrypting existing usernames
            const isUsernameTaken = currentUsers.some(u => decryptMessage(u.username).toLowerCase() === username.toLowerCase() && u.userId !== currentUserId);
            if (isUsernameTaken) {
                showModal("Username Taken", "This username is already taken in this room. Please choose another.", () => hideModal());
                return;
            }

            // Check if room is full
            if (currentUsers.length >= maxAllowedUsers && !currentUsers.some(u => u.userId === currentUserId)) {
                showModal("Room Full", "This room is full.", () => hideModal());
                return;
            }

            if (roomData.password) { // If there's an encrypted password
                 showModal("Enter Password", "This room is password protected.", async () => {
                    const enteredPassword = modalPasswordInput.value.trim();
                    const decryptedStoredPassword = decryptMessage(roomData.password); // Decrypt stored password for comparison
                    if (enteredPassword === decryptedStoredPassword) {
                        modalPasswordError.classList.add('hidden');
                        await performJoinRoomTransaction(roomInternalId, enteredRoomCode, username, maxAllowedUsers, decryptedStoredPassword, roomData.hostId, roomData.isPermanent, roomData.permanentLastActivity);
                    } else {
                        modalPasswordError.textContent = "Incorrect password.";
                        modalPasswordError.classList.remove('hidden');
                        modalPasswordInput.value = '';
                    }
                }, true, () => {}, true);
            } else {
                await performJoinRoomTransaction(roomInternalId, enteredRoomCode, username, maxAllowedUsers, null, roomData.hostId, roomData.isPermanent, roomData.permanentLastActivity);
            }
        });

        // Join Random Room
        joinRandomRoomBtn.addEventListener('click', async () => {
            const username = randomUsernameInput.value.trim();
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => { hideModal(); }); 
                return;
            }
            const randomWarningShown = localStorage.getItem('randomWarningShown');
            if (!randomWarningShown) {
                showModal("Anonymous Chat Warning", "You are about to join a random, unmoderated, and temporary chat room. Do not share personal information.", async () => {
                    localStorage.setItem('randomWarningShown', 'true'); 
                    await findRandomRoom(username);
                }, true, () => {});
            } else {
                await findRandomRoom(username);
            }
        });

        const findRandomRoom = async (username) => {
            const roomsCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms`);
            try {
                // Query for rooms that are not permanent
                const q = query(roomsCollectionRef, where('isPermanent', '==', false)); 
                const querySnapshot = await getDocs(q);
                let availableRooms = [];
                for (const docSnap of querySnapshot.docs) {
                    const roomData = docSnap.data();
                    const maxAllowedUsers = roomData.maxParticipants || 4;
                    const usersInRoom = roomData.users || []; // These usernames are encrypted

                    // Decrypt usernames for uniqueness check
                    const isUsernameTaken = usersInRoom.some(u => decryptMessage(u.username).toLowerCase() === username.toLowerCase() && u.userId !== currentUserId);

                    // Decrypt password to check if room is password-protected
                    const decryptedPassword = roomData.password ? decryptMessage(roomData.password) : null;

                    // Ensure room has users, is not full, and has no password for random join
                    if (usersInRoom.length > 0 && usersInRoom.length < maxAllowedUsers && !decryptedPassword && !isUsernameTaken) {
                        // Decrypt the room code for local storage/display, but use internalId for Firestore operations
                        const decryptedRoomCode = decryptMessage(roomData.encryptedCode);
                        availableRooms.push({
                            internalId: docSnap.id, // Firestore document ID
                            code: decryptedRoomCode, // Decrypted human-readable code
                            users: usersInRoom, // Encrypted usernames
                            maxParticipants: roomData.maxParticipants,
                            password: decryptedPassword, // Decrypted password
                            hostId: roomData.hostId,
                            isPermanent: roomData.isPermanent,
                            permanentLastActivity: roomData.permanentLastActivity
                        });
                    }
                }

                if (availableRooms.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableRooms.length);
                    const roomToJoin = availableRooms[randomIndex];
                    // Pass decrypted room code and password to transaction for local use/comparison
                    await performJoinRoomTransaction(roomToJoin.internalId, roomToJoin.code, username, roomToJoin.maxParticipants, roomToJoin.password, roomToJoin.hostId, roomToJoin.isPermanent, roomToJoin.permanentLastActivity);
                } else {
                    showModal("No Random Rooms", "No random rooms available. Try creating one!", () => hideModal());
                }
            } catch (error) {
                console.error("Error finding random room:", error);
                showModal("Error", "Failed to find a random room.", () => hideModal());
            }
        };
        
        // Room Inactivity Check
        const checkInactivity = async (roomDocRef) => {
            try {
                const roomDoc = await getDoc(roomDocRef);
                if (!roomDoc.exists()) {
                    console.log("Room no longer exists, skipping inactivity check.");
                    return;
                }
                const roomData = roomDoc.data();
                const currentTime = Date.now();

                let shouldDelete = false;
                let reason = "";
                let activityTimestamp = null;
                let timeoutDuration = 0;

                if (roomData.isPermanent) {
                    activityTimestamp = roomData.permanentLastActivity ?
                        (roomData.permanentLastActivity.toDate ? roomData.permanentLastActivity.toDate() : roomData.permanentLastActivity) :
                        (roomData.createdAt.toDate ? roomData.createdAt.toDate() : roomData.createdAt); // Fallback to createdAt if permanentLastActivity is missing
                    timeoutDuration = PERMANENT_INACTIVITY_TIMEOUT_MS;
                    reason = "due to 1 week inactivity (permanent room)";
                } else {
                    activityTimestamp = roomData.lastActivity ?
                        (roomData.lastActivity.toDate ? roomData.lastActivity.toDate() : roomData.lastActivity) :
                        (roomData.createdAt.toDate ? roomData.createdAt.toDate() : roomData.createdAt); // Fallback to createdAt if lastActivity is missing
                    timeoutDuration = INACTIVITY_TIMEOUT_MS;
                    reason = "due to 15 minute inactivity (empty temporary room)";
                }

                if (!(activityTimestamp instanceof Date)) {
                    console.warn("Activity timestamp is not a valid Date object:", activityTimestamp);
                    return;
                }
                const lastActivityTime = activityTimestamp.getTime();

                // For temporary rooms, only delete if empty AND inactive.
                // For permanent rooms, delete if inactive, regardless of users (as they persist when empty).
                if (roomData.isPermanent) {
                    if (currentTime - lastActivityTime >= timeoutDuration) {
                        shouldDelete = true;
                    }
                } else {
                    if ((roomData.users && roomData.users.length === 0) && (currentTime - lastActivityTime >= timeoutDuration)) {
                        shouldDelete = true;
                    }
                }

                if (shouldDelete) {
                    if (inactivityTimer) {
                        clearInterval(inactivityTimer);
                        inactivityTimer = null;
                    }
                    showModal("Room Timed Out", `This room was deleted ${reason}.`, async () => {
                        const roomInternalIdToDelete = roomDoc.id; // Use internal ID
                        handleLeaveRoomCleanUp();
                        hideModal();
                        if (roomInternalIdToDelete) {
                            try {
                                // Delete messages subcollection first
                                const messagesQuerySnapshot = await getDocs(collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomInternalIdToDelete}/messages`));
                                messagesQuerySnapshot.docs.forEach(async (msgDoc) => {
                                    await deleteDoc(msgDoc.ref);
                                });
                                await deleteDoc(doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomInternalIdToDelete));
                                console.log(`Room ${roomInternalIdToDelete} deleted ${reason}.`);
                            } catch (e) {
                                console.warn(`Could not delete timed out room ${roomInternalIdToDelete}:`, e);
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Error in checkInactivity:", error);
            }
        };

        // Setup Room Listeners
        const setupRoomListeners = async (roomInternalId) => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) clearInterval(inactivityTimer);

            const roomDocRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomInternalId);
            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomInternalId}/messages`);

            try {
                const roomDoc = await getDoc(roomDocRef);
                if (roomDoc.exists()) {
                    const roomData = roomDoc.data();
                    // Decrypt room code and usernames for local state
                    const decryptedCode = decryptMessage(roomData.encryptedCode);
                    const decryptedUsers = (roomData.users || []).map(u => ({ ...u, username: decryptMessage(u.username) }));
                    const decryptedPassword = roomData.password ? decryptMessage(roomData.password) : null;

                    currentRoom = { 
                        internalId: roomInternalId, // Store Firestore document ID
                        code: decryptedCode, // Store decrypted human-readable code
                        users: decryptedUsers, // Store decrypted usernames
                        maxParticipants: roomData.maxParticipants || 4,
                        lastActivity: roomData.lastActivity,
                        password: decryptedPassword, // Store decrypted password
                        hostId: roomData.hostId,
                        isPermanent: roomData.isPermanent || false,
                        permanentLastActivity: roomData.permanentLastActivity || null
                    };
                    currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                    renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants;
                    updatePermanentModeUI(); // Initial UI update for permanent mode
                } else { 
                    showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal();
                    });
                    return;
                }
            } catch (error) { 
                 console.error("Error fetching initial room data:", error);
                showModal("Connection Error", "Failed to get initial room data.", () => { hideModal(); });
                return;
            }
            // Initial messages fetch
            try {
                const initialMessagesQuery = query(messagesCollectionRef, orderBy('timestamp', 'asc'));
                const initialMessagesSnapshot = await getDocs(initialMessagesQuery);
                const initialMessages = initialMessagesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderMessages(initialMessages); // Synchronous rendering
            } catch (error) {
                console.error("Error fetching initial messages:", error);
                showModal("Connection Error", "Failed to get initial messages.", () => { hideModal(); });
                return; 
            }


            unsubscribeRoomListener = onSnapshot(roomDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const roomData = docSnap.data();
                    // Decrypt room code and usernames for local state
                    const decryptedCode = decryptMessage(roomData.encryptedCode);
                    const decryptedUsers = (roomData.users || []).map(u => ({ ...u, username: decryptMessage(u.username) }));
                    const decryptedPassword = roomData.password ? decryptMessage(roomData.password) : null;

                    // Check if current user is still in the room's user list (using decrypted username for comparison)
                    const amIStillInRoom = decryptedUsers.some(u => u.userId === currentUserId);

                    if (!amIStillInRoom && currentRoom) { // If current user was removed or left
                        showModal("Removed from Room", "You have been removed from the room or the room has changed.", () => {
                            handleLeaveRoomCleanUp();
                            hideModal();
                        });
                        return; // Stop further processing for this client in this room
                    }

                    currentRoom = {
                        internalId: roomInternalId,
                        code: decryptedCode,
                        users: decryptedUsers,
                        maxParticipants: roomData.maxParticipants || 4,
                        lastActivity: roomData.lastActivity,
                        password: decryptedPassword,
                        hostId: roomData.hostId,
                        isPermanent: roomData.isPermanent || false,
                        permanentLastActivity: roomData.permanentLastActivity || null
                    };
                    currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                    renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants;
                    updatePermanentModeUI(); // Update permanent mode UI on snapshot
                    
                    // Reset and restart inactivity timer
                    if (inactivityTimer) clearInterval(inactivityTimer);
                    inactivityTimer = setInterval(() => checkInactivity(roomDocRef), 60 * 1000); // Check every minute
                    checkInactivity(roomDocRef); // Run immediately on snapshot update
                } else { 
                     showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal();
                    });
                }
            }, (error) => { 
                console.error("Error listening to room:", error);
                showModal("Connection Error", "Failed to get room updates.", () => { hideModal(); });
            });
            
            unsubscribeMessagesListener = onSnapshot(query(messagesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
                const newMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderMessages(newMessages); // Synchronous rendering
                if (currentRoom && currentRoom.internalId) { // Use internalId
                    const roomRefToUpdate = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.internalId);
                    const updateFields = { lastActivity: serverTimestamp() };
                    if (currentRoom.isPermanent) {
                        updateFields.permanentLastActivity = serverTimestamp();
                    }
                    updateDoc(roomRefToUpdate, updateFields).catch(e => console.error("Error updating last activity on message receive:", e));
                }
            }, (error) => {
                console.error("Error listening to messages:", error);
                showModal("Connection Error", "Failed to get message updates.", () => { hideModal(); });
            });
        };

        // Send Message
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newMessageText = newMessageInput.value.trim();
            if (!newMessageText) return;
            if (!currentRoom || !currentUserId || !currentUserObject) {
                 console.warn("Cannot send message: currentRoom, currentUserId, or currentUserObject is not set.");
                 return;
            }
            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.internalId}/messages`); // Use internalId
            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.internalId); // Use internalId
            
            // Encrypt the message before sending
            const encryptedMessage = encryptMessage(newMessageText);
            if (!encryptedMessage) {
                showModal("Encryption Failed", "Could not encrypt message. Please try again.", () => hideModal());
                return;
            }

            try {
                await addDoc(messagesCollectionRef, {
                    senderId: currentUserId,
                    senderUsername: encryptMessage(currentUserObject.username), // Encrypt sender username for storage
                    type: 'text', 
                    timestamp: serverTimestamp(),
                    text: encryptedMessage, // Store encrypted message
                });
                const updateFields = { lastActivity: serverTimestamp() };
                if (currentRoom.isPermanent) {
                    updateFields.permanentLastActivity = serverTimestamp();
                }
                await updateDoc(roomRef, updateFields);
                newMessageInput.value = ''; 
            } catch (error) {
                console.error("Error sending message:", error);
                showModal("Message Failed", "Failed to send message.", () => { hideModal(); }); 
            }
        });

        // Leave Room Button
        leaveRoomBtn.addEventListener('click', () => {
            showModal("Leave Room", "Are you sure you want to leave this room?", async () => {
                if (!currentRoom || !currentUserId || !currentUserObject) {
                    console.warn("Cannot leave room: state not properly set.");
                    hideModal();
                    return;
                }
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.internalId); // Use internalId
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) {
                            console.warn("Room already gone when attempting to leave.");
                            return; // Room already gone, just clean up locally
                        }
                        const roomData = roomDoc.data();
                        const currentUsers = roomData.users || []; // These usernames are encrypted

                        // Find the user object to remove by matching userId and *encrypted* username
                        const userObjectToRemoveFromFirestore = currentUsers.find(u => u.userId === currentUserId && decryptMessage(u.username) === currentUserObject.username);

                        if (userObjectToRemoveFromFirestore) { 
                            if (currentUserId === roomData.hostId) { // Current user is the host
                                if (roomData.isPermanent) {
                                    // Host leaving a permanent room: just remove host from users, room persists
                                    transaction.update(roomRef, {
                                        users: arrayRemove(userObjectToRemoveFromFirestore),
                                        lastActivity: serverTimestamp(),
                                        permanentLastActivity: serverTimestamp()
                                    });
                                } else {
                                    // Host leaving a non-permanent room: delete the room immediately regardless of other participants
                                    // Delete all messages in the subcollection first
                                    const messagesQuerySnapshot = await getDocs(collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.internalId}/messages`)); // Use internalId
                                    messagesQuerySnapshot.docs.forEach(msgDoc => {
                                        transaction.delete(msgDoc.ref);
                                    });
                                    transaction.delete(roomRef);
                                }
                            } else { // Current user is a participant (not host)
                                const updateFields = { users: arrayRemove(userObjectToRemoveFromFirestore), lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) {
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                transaction.update(roomRef, updateFields);
                            }
                        } else {
                            console.warn("Attempted to leave room, user not found in Firestore. Cleaning up locally.");
                        }
                    });
                    handleLeaveRoomCleanUp(); 
                    hideModal(); 
                }
                catch (error) {
                    console.error("Error leaving room:", error);
                    showModal("Leave Failed", "Could not leave room.", () => { 
                        handleLeaveRoomCleanUp(); 
                        hideModal(); 
                    }); 
                }
            }, true); 
        });
        
        // Local Cleanup
        const handleLeaveRoomCleanUp = () => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) clearInterval(inactivityTimer);
            window.removeEventListener('beforeunload', handlePageExit);
            currentUserObject = null; 
            currentRoom = null;
            roomCodeInput.value = '';
            newMessageInput.value = '';
            messagesContainer.innerHTML = ''; 
            noMessagesYet.classList.remove('hidden'); 
            updateUI();
        };

        // Page Exit (Best Effort)
        const handlePageExit = () => {
             if (currentRoom && currentUserId && currentUserObject) {
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.internalId); // Use internalId
                try {
                    getDoc(roomRef).then(roomDoc => {
                        if (roomDoc.exists()) {
                            const roomData = roomDoc.data();
                            const usersInFirestore = roomData.users || []; // These usernames are encrypted
                            // Find user to remove by matching userId and *encrypted* username
                            const userToRemove = usersInFirestore.find(u => u.userId === currentUserId && decryptMessage(u.username) === currentUserObject.username);
                            if (userToRemove) {
                                // Only remove the user. Let the onSnapshot and inactivity checks handle room deletion.
                                const updateFields = { lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) {
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                updateDoc(roomRef, {
                                    users: arrayRemove(userToRemove), 
                                    ...updateFields
                                }).catch(e => console.warn("Best-effort: Failed to remove user on exit (updateDoc):", e));
                            }
                        }
                    }).catch(e => console.warn("Best-effort: Error fetching room doc on exit:", e));
                } catch (e) {
                    console.warn("Best-effort: Error in handlePageExit:", e);
                }
            }
        };

        // NEW: Event listener for the "Toggle Permanent Mode" button
        togglePermanentModeBtn.addEventListener('click', async () => {
            if (!currentRoom || currentUserId !== currentRoom.hostId) {
                showModal("Permission Denied", "Only the host can toggle permanent mode.", () => hideModal());
                return;
            }
            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.internalId); // Use internalId
            const newPermanentState = !currentRoom.isPermanent; // Toggle the state

            showModal(
                "Toggle Permanent Room",
                `Are you sure you want to ${newPermanentState ? 'make this room permanent' : 'make this room temporary'}?`,
                async () => {
                    try {
                        const updateFields = {
                            isPermanent: newPermanentState,
                            lastActivity: serverTimestamp() // Also update general activity
                        };
                        if (newPermanentState) {
                            updateFields.permanentLastActivity = serverTimestamp(); // Set timestamp when made permanent
                        } else {
                            updateFields.permanentLastActivity = null; // Clear timestamp when made temporary
                        }
                        await updateDoc(roomRef, updateFields);
                        
                        // Update local state immediately for responsive UI
                        currentRoom.isPermanent = newPermanentState; 
                        currentRoom.permanentLastActivity = newPermanentState ? new Date() : null; 

                        updatePermanentModeUI(); // Update UI based on new state
                        hideModal();
                    } catch (error) {
                        console.error("Error toggling permanent mode:", error);
                        showModal("Error", "Failed to toggle permanent mode. Please try again.", () => hideModal());
                    }
                },
                true // Show cancel button
            );
        });


        // Dark Mode & UI Mode Switching
        const applyDarkMode = (isDarkMode) => {
            document.body.classList.toggle('dark-mode', isDarkMode);
            iconMoonHome.classList.toggle('hidden', isDarkMode);
            iconSunHome.classList.toggle('hidden', !isDarkMode);
            iconMoonChat.classList.toggle('hidden', isDarkMode);
            iconSunChat.classList.toggle('hidden', !isDarkMode);
        };
        darkModeToggleHome.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });
        darkModeToggleChat.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') applyDarkMode(true); else applyDarkMode(false);

        const updateModeUI = (mode) => {
            currentMode = mode;
            if (mode === 'default') {
                defaultModeBtn.classList.add('active');
                randomModeBtn.classList.remove('active');
                defaultModeContainer.classList.remove('hidden');
                randomModeContainer.classList.add('hidden');
                randomUsernameInput.value = '';
            } else { 
                randomModeBtn.classList.add('active');
                defaultModeBtn.classList.remove('active');
                randomModeContainer.classList.remove('hidden');
                defaultModeContainer.classList.add('hidden');
                usernameInput.value = '';
                createPasswordInput.value = '';
                roomCodeInput.value = '';
                createPasswordInputGroup.style.display = 'none'; 
                maxParticipantsInput.value = '4'; 
            }
        };
        defaultModeBtn.addEventListener('click', () => updateModeUI('default'));
        randomModeBtn.addEventListener('click', () => updateModeUI('random'));
        usernameInput.addEventListener('input', () => {
            if (usernameInput.value.trim() !== '') createPasswordInputGroup.style.display = 'block';
            else {
                createPasswordInputGroup.style.display = 'none';
                createPasswordInput.value = ''; 
            }
        });

        // Privacy Policy & DOMContentLoaded
        privacyPolicyLink.addEventListener('click', showPrivacyPolicyModal);
        privacyPolicyCloseBtn.addEventListener('click', hidePrivacyPolicyModal);
        document.addEventListener('DOMContentLoaded', () => {
            homeScreen.classList.add('hidden');
            chatRoomScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            updateModeUI('default');
            if (usernameInput.value.trim() !== '') createPasswordInputGroup.style.display = 'block';
        });

    </script>
</body>
</html>
