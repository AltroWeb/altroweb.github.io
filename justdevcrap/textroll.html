<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Textroll - Web Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="textroll.png">
    <style>
        /* CSS Variables for Theming */
        :root {
            /* Light Mode Colors */
            --bg-gradient-start: #8b5cf6; /* purple-500 */
            --bg-gradient-end: #4f46e5;   /* indigo-600 */
            --text-color-primary: #374151; /* gray-800 */
            --text-color-secondary: #4b5563; /* gray-600 */
            --card-bg: #fff;
            --header-text: #4338ca; /* indigo-700 */
            --room-code-text: #9333ea; /* purple-600 */
            --border-color: #e5e7eb; /* gray-200 */
            --input-border: #d1d5db; /* gray-300 */
            --input-bg-disabled: #f3f4f6; /* gray-100 */
            --button-bg-indigo: #4f46e5; /* indigo-600 */
            --button-hover-indigo: #4338ca; /* indigo-700 */
            --button-bg-purple: #9333ea; /* purple-600 */
            --button-hover-purple: #7e22ce; /* purple-700 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #2563eb; /* blue-600 */
            --button-hover-blue: #1d4ed8; /* blue-700 */
            --button-disabled-bg: #9ca3af; /* gray-400 */
            --participant-bg-you: #e0e7ff; /* indigo-100 */
            --participant-text-you: #4338ca; /* indigo-700 */
            --participant-bg-other: #f3f4f6; /* gray-100 */
            --message-bg-you: #6366f1; /* indigo-500 */
            --message-bg-other: #e5e7eb; /* gray-200 */
            --message-text-you: #fff;
            --message-text-other: #1f2937; /* gray-800 */
            --message-timestamp-opacity: 0.6;
            --chat-bg: #f9fafb; /* gray-50 */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-color-dark: rgba(0, 0, 0, 0.04);
            --modal-shadow-color: rgba(0, 0, 0, 0.25);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.06);
            --focus-ring-indigo: rgba(99, 102, 241, 0.5);
            --focus-ring-purple: rgba(168, 85, 247, 0.75);
            --focus-ring-red: rgba(239, 68, 68, 0.75);
            --focus-ring-blue: rgba(59, 130, 246, 0.5);
            --focus-ring-gray: rgba(156, 163, 175, 0.75);
            --button-shadow-offset: 0 4px 6px -1px;
            --button-shadow-blur: 0 2px 4px -1px;
        }

        /* Dark Mode Colors */
        .dark-mode {
            --bg-gradient-start: #1f2937; /* dark gray */
            --bg-gradient-end: #0f172a;   /* darker blue-gray */
            --text-color-primary: #e5e7eb; /* gray-200 */
            --text-color-secondary: #d1d5db; /* gray-300 */
            --card-bg: #374151; /* gray-700 */
            --header-text: #a78bfa; /* purple-400 */
            --room-code-text: #c084fc; /* purple-500 */
            --border-color: #4b5563; /* gray-600 */
            --input-border: #6b7280; /* gray-500 */
            --input-bg-disabled: #4b5563; /* gray-600 */
            --button-bg-indigo: #6366f1; /* indigo-500 */
            --button-hover-indigo: #4f46e5; /* indigo-600 */
            --button-bg-purple: #a855f7; /* purple-500 */
            --button-hover-purple: #9333ea; /* purple-600 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #3b82f6; /* blue-500 */
            --button-hover-blue: #2563eb; /* blue-600 */
            --button-disabled-bg: #4b5563; /* gray-600 */
            --participant-bg-you: #4f46e5; /* indigo-600 */
            --participant-text-you: #e0e7ff; /* indigo-100 */
            --participant-bg-other: #4b5563; /* gray-600 */
            --message-bg-you: #4f46e5; /* indigo-600 */
            --message-bg-other: #4b5563; /* gray-600 */
            --message-text-you: #e5e7eb;
            --message-text-other: #e5e7eb;
            --message-timestamp-opacity: 0.7;
            --chat-bg: #374151; /* gray-700 */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-color-dark: rgba(0, 0, 0, 0.2);
            --modal-shadow-color: rgba(0, 0, 0, 0.4);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.2);
        }

        /* Universal Font and Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth dark mode transition */
        }

        /* All elements inherit font, remove default button borders */
        * {
            font-family: inherit;
            box-sizing: border-box; /* Ensure consistent box model */
        }
        button {
            border: none; /* Remove default button borders */
            outline: none; /* Remove default focus outline */
            cursor: pointer;
        }

        /* Custom scrollbar for chat messages */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: var(--input-bg-disabled);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Animations */
        @keyframes scaleIn {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        .animate-scaleIn {
            animation: scaleIn 0.3s ease-out forwards;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #loading-screen.hidden {
            display: none;
        }

        /* Modal Styles */
        #modal-overlay, #privacy-policy-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(107, 114, 128, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        #modal-overlay.hidden, #privacy-policy-modal-overlay.hidden {
            display: none;
        }
        #modal-content, #privacy-policy-modal-content {
            background-color: var(--card-bg);
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px var(--modal-shadow-color), 0 10px 10px -5px var(--modal-shadow-color-dark);
            padding: 1.5rem;
            max-width: 24rem;
            width: 100%;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.3s ease-in-out;
            color: var(--text-color-primary);
        }
        #privacy-policy-modal-content {
            max-width: 36rem; /* Wider for policy text */
            max-height: 80vh; /* Limit height to enable scrolling */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            border-radius: 0.75rem; /* Rounded corners for the policy modal */
        }
        #modal-content.show, #privacy-policy-modal-content.show {
            transform: scale(1);
            opacity: 1;
        }
        #modal-title, #privacy-policy-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 1rem;
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        #modal-message {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
        }
        #privacy-policy-text {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
            flex-grow: 1; /* Allow content to grow and take available space */
            overflow-y: auto; /* Enable vertical scrolling for content */
            padding-right: 0.5rem; /* Add some padding for scrollbar */
        }
        #modal-buttons, #privacy-policy-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
            padding-top: 0.5rem; /* Space between content and buttons */
        }
        #modal-cancel-btn, #privacy-policy-close-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            color: var(--text-color-primary);
            background-color: var(--border-color);
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-cancel-btn:hover, #privacy-policy-close-btn:hover {
            background-color: #d1d5db;
        }
        .dark-mode #modal-cancel-btn:hover, .dark-mode #privacy-policy-close-btn:hover {
            background-color: #6b7280;
        }
        #modal-cancel-btn.hidden {
            display: none;
        }
        #modal-ok-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            background-color: var(--button-bg-blue);
            color: #fff;
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-ok-btn:hover {
            background-color: var(--button-hover-blue);
        }
        /* Password input group and error */
        #modal-password-input-group {
            margin-bottom: 1.5rem; /* Spacing below the group */
            padding: 0.75rem; /* Internal padding for the group */
            border: 1px solid var(--input-border); /* Subtle border */
            border-radius: 0.5rem; /* Rounded corners */
            background-color: var(--input-bg-disabled); /* Light background */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .dark-mode #modal-password-input-group {
            background-color: var(--border-color); /* Darker background for dark mode */
        }
        #modal-password-input-group label {
            margin-bottom: 0.75rem; /* More space below label */
            padding-left: 0.25rem; /* Align text with input */
        }
        #modal-password-input {
            width: 100%;
            padding: 0.8rem; /* Slightly more padding for input field */
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
            font-size: 1rem; /* Ensure good readability */
        }
        #modal-password-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px var(--focus-ring-indigo); /* Slightly thicker focus ring */
            border-color: transparent;
        }
        #modal-password-error {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem;
            margin-top: 0.5rem;
            text-align: left;
            display: block; /* Ensure it takes its own line */
        }
        /* IMPORTANT: Force hidden elements to be display: none */
        .hidden {
            display: none !important;
        }


        /* Focus styles for buttons */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-blue);
        }
        #modal-cancel-btn:focus, #privacy-policy-close-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-gray);
        }
        #leave-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red);
        }
        #create-room-btn:focus, #send-message-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
        }
        #join-room-btn:focus, #join-random-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-purple);
        }

        /* Dark Mode Toggle Button */
        .dark-mode-toggle-container {
            /* Removed absolute positioning for chat screen, now part of flex header */
            z-index: 10; /* Ensure it's above other elements in the card */
            display: flex; /* To center emoji */
            align-items: center;
            justify-content: center;
        }
        /* Specific adjustment for the toggle button within the home screen */
        #home-screen .dark-mode-toggle-container {
            margin-top: 2rem;
        }
        #dark-mode-toggle, #dark-mode-toggle-chat {
            background-color: var(--card-bg);
            color: var(--text-color-primary); /* Icon color */
            border: none;
            border-radius: 9999px;
            padding: 0.75rem;
            font-size: 1.25rem; /* Controls emoji size */
            cursor: pointer;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        }
        #dark-mode-toggle:hover, #dark-mode-toggle-chat:hover {
            transform: scale(1.1);
        }
        #dark-mode-toggle:active, #dark-mode-toggle-chat:active {
            transform: scale(0.95);
        }

        /* Text Icon specific styles */
        .icon-moon-text { display: block; }
        .icon-sun-text { display: none; }
        .dark-mode .icon-moon-text { display: none; }
        .dark-mode .icon-sun-text { display: block; }


        /* Home Screen */
        #home-screen {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 28rem;
            text-align: center;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
            position: relative; /* For dark mode toggle positioning */
        }
        #home-screen.hidden {
            display: none;
        }
        #home-screen h1 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--header-text);
            margin-bottom: 1.5rem;
            letter-spacing: -0.025em;
        }
        #home-screen p {
            color: var(--text-color-secondary);
            margin-bottom: 2rem;
            font-size: 1.125rem;
        }
        #home-screen .input-group {
            margin-bottom: 1.5rem;
        }
        #home-screen .input-group label {
            display: block;
            text-align: left;
            color: var(--text-color-primary);
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        #home-screen input[type="text"],
        #home-screen input[type="number"], /* Added for max participants */
        #home-screen input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #home-screen input[type="text"]:focus,
        #home-screen input[type="number"]:focus,
        #home-screen input[type="password"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #home-screen #create-password-input-group.hidden {
            display: none;
        }
        #home-screen .button-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #home-screen button {
            width: 100%;
            padding: 0.75rem 1.5rem;
            color: #fff;
            font-weight: 600;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        #home-screen button:hover {
            transform: scale(1.05);
        }
        #create-room-btn {
            background-color: var(--button-bg-indigo);
        }
        #create-room-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #join-room-btn, #join-random-room-btn { /* Apply purple to both join buttons */
            background-color: var(--button-bg-purple);
            color: #fff; /* Ensure text is white for contrast */
        }
        #join-room-btn:hover, #join-random-room-btn:hover {
            background-color: var(--button-hover-purple);
        }
        #user-id-display {
            font-size: 0.75rem;
            color: var(--text-color-secondary);
            margin-top: 1.5rem;
        }

        /* Chat Room Screen */
        #chat-room-screen {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 42rem;
            display: flex;
            flex-direction: column;
            height: 85vh;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
            position: relative; /* For dark mode toggle positioning */
        }
        #chat-room-screen.hidden {
            display: none;
        }
        #chat-room-screen .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            gap: 1rem; /* Add gap for spacing between header elements */
        }
        #chat-room-screen h2 {
            font-size: 1.875rem;
            font-weight: 700;
            color: var(--header-text);
            /* Allow h2 to grow and take available space, pushing other elements */
            flex-grow: 1;
            text-align: center; /* Center the room code text */
        }
        #current-room-code {
            color: var(--room-code-text);
        }
        #leave-room-btn {
            padding: 0.5rem 1rem;
            background-color: var(--button-bg-red);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
        }
        #leave-room-btn:hover {
            background-color: var(--button-hover-red);
        }

        #chat-room-screen .participants-section {
            margin-bottom: 1rem;
        }
        #chat-room-screen .participants-section h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 0.5rem;
        }
        #participants-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-color-secondary);
        }
        #participants-list span {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
        }
        #participants-list span.bg-indigo-100 {
            background-color: var(--participant-bg-you);
            color: var(--participant-text-you);
            font-weight: 500;
        }
        #participants-list span.bg-gray-100 {
            background-color: var(--participant-bg-other);
            color: var(--text-color-primary);
        }

        #messages-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: var(--chat-bg);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease;
        }
        #no-messages-yet {
            text-align: center;
            color: var(--text-color-secondary);
            font-style: italic;
            margin-top: 1rem;
        }
        #no-messages-yet.hidden {
            display: none;
        }

        .message-item {
            display: flex;
            margin-bottom: 0.75rem;
        }
        .message-item.justify-end {
            justify-content: flex-end;
        }
        .message-item.justify-start {
            justify-content: flex-start;
        }
        .message-content {
            max-width: 70%;
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .message-item.justify-end .message-content {
            background-color: var(--message-bg-you);
            color: var(--message-text-you);
            border-bottom-right-radius: 0;
        }
        .message-item.justify-start .message-content {
            background-color: var(--message-bg-other);
            color: var(--message-text-other);
            border-bottom-left-radius: 0;
        }
        .message-content .sender-info {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            opacity: 0.8;
        }
        .message-content p {
            font-size: 0.875rem;
            word-break: break-word;
        }
        .message-content .timestamp {
            text-align: right;
            font-size: 0.75rem;
            opacity: var(--message-timestamp-opacity);
            margin-top: 0.25rem;
        }

        #message-form {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        #new-message-input {
            flex-grow: 1;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #new-message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #new-message-input:disabled {
            background-color: var(--input-bg-disabled);
            cursor: not-allowed;
            color: var(--text-color-secondary);
        }
        #send-message-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--button-bg-indigo);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
        }
        #send-message-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #send-message-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Footnote */
        #app-footnote {
            margin-top: 2rem; /* Spacing from the main content */
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7); /* Light white for contrast on gradient background */
            text-align: center;
            padding-bottom: 1rem; /* Ensure it's not right at the bottom edge */
        }
        #app-footnote a {
            color: inherit; /* Inherit color from parent */
            text-decoration: underline;
            
            cursor: pointer;
        }
        #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        .dark-mode #app-footnote {
            color: rgba(255, 255, 255, 0.5); /* Slightly darker for dark mode */
        }
        .dark-mode #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Mode Selection Styles */
        #mode-selection {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            width: 100%; /* Ensure it takes full width of parent */
        }
        #mode-selection button {
            flex: 1;
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            background-color: var(--card-bg); /* Default background */
            color: var(--text-color-primary); /* Default text color */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #mode-selection button.active {
            background-color: var(--button-bg-purple); /* Changed to purple */
            color: #fff;
            box-shadow: var(--button-shadow-offset) var(--button-bg-purple), var(--button-shadow-blur) var(--button-bg-purple); /* Changed to purple */
        }
        #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Lighter hover for non-active */
        }
        .dark-mode #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Darker hover for non-active */
        }

        /* Mode Containers */
        #default-mode-container,
        #random-mode-container {
            width: 100%;
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            gap: 1.5rem; /* Consistent spacing between input groups */
        }
        #default-mode-container.hidden,
        #random-mode-container.hidden {
            display: none;
        }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }
            #home-screen, #chat-room-screen {
                padding: 1.5rem;
                max-width: 100%;
                border-radius: 0.5rem;
            }
            #home-screen h1 {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }
            #home-screen p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }
            #home-screen .input-group {
                margin-bottom: 1rem;
            }
            #home-screen .button-group {
                gap: 0.75rem;
            }
            #chat-room-screen h2 {
                font-size: 1.5rem;
            }
            #leave-room-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.875rem;
            }
            #chat-room-screen .participants-section h3 {
                font-size: 1rem;
            }
            #participants-list span {
                font-size: 0.75rem;
                padding: 0.2rem 0.6rem;
            }
            .message-content {
                max-width: 85%;
                padding: 0.6rem;
            }
            .message-content .sender-info, .message-content p, .message-content .timestamp {
                font-size: 0.8rem;
            }
            #message-form {
                flex-direction: column;
                gap: 0.5rem;
            }
            #new-message-input, #send-message-btn {
                width: 100%;
                padding: 0.6rem;
            }
            #send-message-btn {
                padding: 0.6rem 1rem;
            }
            /* Adjust dark mode toggle position for mobile in chat screen */
            #chat-room-screen .header .dark-mode-toggle-container {
                /* No specific right/left needed, flexbox handles it */
                margin-right: 0.5rem; /* Small margin to the right of the toggle */
            }
            #mode-selection {
                flex-direction: column;
            }
            #default-mode-container,
            #random-mode-container {
                gap: 1rem; /* Smaller gap on mobile */
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="loading-screen">
        <div class="text-2xl font-bold">Loading Textroll...</div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-content">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="input-group hidden" id="modal-password-input-group">
                <label for="modal-password-input" class="hidden">Enter password:</label>
                <input type="password" id="modal-password-input" placeholder="Room password" />
                <span id="modal-password-error" class="hidden"></span> </div>
            <div id="modal-buttons">
                <button id="modal-cancel-btn" class="hidden">
                    Cancel
                </button>
                <button id="modal-ok-btn">
                    OK
                </button>
            </div>
        </div>
    </div>

    <div id="privacy-policy-modal-overlay" class="hidden">
        <div id="privacy-policy-modal-content">
            <h3 id="privacy-policy-title">Privacy Policy for Textroll Web Chat</h3>
            <div id="privacy-policy-text">
                <p><strong>1. Data Collection:</strong> We collect your chosen username and a unique user ID generated by Firebase Authentication for the purpose of identifying you within chat rooms. Room codes and messages sent within rooms are stored temporarily on our Firebase Firestore database to facilitate real-time communication. We do NOT collect any personally identifiable information beyond your chosen username and the Firebase-generated user ID.</p>
                <p><strong>2. Data Usage:</strong> Your username and user ID are used solely to display your identity in chat rooms and manage your participation. Room data (including messages) is used to enable chat functionality. We do not use your data for advertising, tracking, or any other commercial purposes.</p>
                <p><strong>3. Data Storage and Deletion:</strong> Chat rooms and their messages are designed to be temporary. Rooms are automatically deleted if they become empty (no participants) or if there is no activity (no messages sent or users joining/leaving) for 15 minutes. This means your chat data is not permanently stored. We do not maintain backups of individual chat sessions.</p>
                <p><strong>4. Security:</strong> We use Firebase Firestore, which provides robust security features. However, please remember that random and unmoderated chat rooms inherently carry risks. Do NOT share sensitive personal information (e.g., real name, address, phone number, financial details) in Textroll chat rooms.</p>
                <p><strong>5. Third-Party Services:</strong> This app uses Firebase (Google) for backend services (authentication, database). Their privacy policies apply to the data they handle. We do not integrate with any other third-party analytics or advertising services.</p>
                <p><strong>6. Changes to this Policy:</strong> We may update this privacy policy from time to time. Any changes will be reflected directly within the app. Your continued use of the app after such changes constitutes your acceptance of the new policy.</p>
                <p><strong>7. Contact:</strong> For any privacy-related questions, please contact us through the platform where you accessed this application.</p>
            </div>
            <div id="privacy-policy-buttons">
                <button id="privacy-policy-close-btn">
                    Close
                </button>
            </div>
        </div>
    </div>


    <div id="home-screen" class="hidden">
        
        <h1>Textroll</h1>
        <p>
            Connect and chat anonymously with friends or strangers!
        </p>


<div class="dark-mode-toggle-container">
            <button id="dark-mode-toggle">
                <span class="icon-moon-text">🌙</span>
                <span class="icon-sun-text">☀️</span>
                </button>
        </div>
<br><br>

        <div id="mode-selection">
            <button id="default-mode-btn" class="active">Default Mode</button>
            <button id="random-mode-btn">Random Mode</button>
        </div>

        <div id="default-mode-container">
            <div class="input-group">
                <label for="username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="username-input"
                    placeholder="e.g., ChatMaster"
                    maxlength="15"
                />
            </div>

            <div class="input-group" id="create-password-input-group" style="display: none;">
                <label for="create-password-input">
                    Set a room password (optional):
                </label>
                <input
                    type="password"
                    id="create-password-input"
                    placeholder="Leave blank for no password"
                    maxlength="20"
                />
            </div>

            <div class="input-group">
                <label for="max-participants-input">
                    Max Participants (2-10):
                </label>
                <input
                    type="number"
                    id="max-participants-input"
                    value="4"
                    min="2"
                    max="10"
                />
            </div>

            <div class="input-group">
                <label for="room-code-input">
                    Or enter a room code to join:
                </label>
                <input
                    type="text"
                    id="room-code-input"
                    placeholder="e.g., ABCDEF"
                    maxlength="6"
                />
            </div>

            <div class="button-group">
                <button id="create-room-btn">
                    Create New Room
                </button>
                <button id="join-room-btn">
                    Join Room
                </button>
            </div>
        </div>

        <div id="random-mode-container" class="hidden">
            <div class="input-group">
                <label for="random-username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="random-username-input"
                    placeholder="e.g., AnonymousChatter"
                    maxlength="15"
                />
            </div>
            <div class="button-group">
                <button id="join-random-room-btn">
                    Join Random Room
                </button>
            </div>
        </div>

        <p id="user-id-display"></p>
    </div>

    <div id="chat-room-screen" class="hidden">
        <div class="header">
            <div class="dark-mode-toggle-container">
                <button id="dark-mode-toggle-chat">
                    <span class="icon-moon-text">🌙</span>
                    <span class="icon-sun-text">☀️</span>
                </button>
            </div>
            <h2>
                Room: <span id="current-room-code"></span>
            </h2>
            <button id="leave-room-btn">
                Leave Room
            </button>
        </div>

        <div class="participants-section">
            <h3>Participants (<span id="participants-count">0</span>/<span id="max-participants-display">4</span>):</h3>
            <div id="participants-list">
                </div>
        </div>

        <div id="messages-container" class="custom-scrollbar">
            <p id="no-messages-yet" class="hidden">No messages yet. Start the conversation!</p>
            <div id="messages-end-ref"></div> </div>

        <form id="message-form">
            <input
                type="text"
                id="new-message-input"
                placeholder="Type your message..."
            />
            <button
                type="submit"
                id="send-message-btn"
            >
                Send
            </button>
        </form>
    </div>

    <div id="app-footnote">
        Made by <a id="jdc-link" href="https://altroweb.github.io/justdevcrap">JustDevCrap.</a> With ☕. <a id="privacy-policy-link">Privacy Policy</a>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc, serverTimestamp, arrayUnion, arrayRemove, runTransaction, query, where, getDocs, orderBy, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

              // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyA8ErpL72u6bTzPuOx51l4Mb51NDCDBDBY",
    authDomain: "textroll-79302.firebaseapp.com",
    projectId: "textroll-79302",
    storageBucket: "textroll-79302.firebaseapp.com",
    messagingSenderId: "928701458132",
    appId: "1:928701458132:web:5eec69352bd35998023d41",
    measurementId: "G-DP3QEKB09S"
  };

        // Use your Firebase projectId for the Firestore path. This is crucial.
        const textrollAppId = firebaseConfig.projectId;

        // Initialize Firebase App
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // DOM Elements
        const loadingScreen = document.getElementById('loading-screen');
        const homeScreen = document.getElementById('home-screen');
        const chatRoomScreen = document.getElementById('chat-room-screen');

        // Mode Selection Elements
        const modeSelection = document.getElementById('mode-selection');
        const defaultModeBtn = document.getElementById('default-mode-btn');
        const randomModeBtn = document.getElementById('random-mode-btn');
        const defaultModeContainer = document.getElementById('default-mode-container');
        const randomModeContainer = document.getElementById('random-mode-container');

        // Default Mode Inputs
        const usernameInput = document.getElementById('username-input');
        const createPasswordInputGroup = document.getElementById('create-password-input-group');
        const createPasswordInput = document.getElementById('create-password-input');
        const maxParticipantsInput = document.getElementById('max-participants-input');
        const roomCodeInput = document.getElementById('room-code-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');

        // Random Mode Inputs
        const randomUsernameInput = document.getElementById('random-username-input');
        const joinRandomRoomBtn = document.getElementById('join-random-room-btn');

        // Chat Room Elements
        const userIdDisplay = document.getElementById('user-id-display');
        const currentRoomCodeDisplay = document.getElementById('current-room-code');
        const participantsCount = document.getElementById('participants-count');
        const maxParticipantsDisplay = document.getElementById('max-participants-display'); // New element
        const participantsList = document.getElementById('participants-list');
        const messagesContainer = document.getElementById('messages-container');
        const noMessagesYet = document.getElementById('no-messages-yet');
        const messagesEndRef = document.getElementById('messages-end-ref');
        const newMessageInput = document.getElementById('new-message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const messageForm = document.getElementById('message-form');
        const leaveRoomBtn = document.getElementById('leave-room-btn');

        // Main Modal Elements
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalPasswordInputGroup = document.getElementById('modal-password-input-group');
        const modalPasswordInput = document.getElementById('modal-password-input');
        const modalPasswordError = document.getElementById('modal-password-error'); // New element for password error
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // Privacy Policy Modal Elements
        const privacyPolicyLink = document.getElementById('privacy-policy-link');
        const privacyPolicyModalOverlay = document.getElementById('privacy-policy-modal-overlay');
        const privacyPolicyModalContent = document.getElementById('privacy-policy-modal-content');
        const privacyPolicyCloseBtn = document.getElementById('privacy-policy-close-btn');

        // Dark Mode Elements
        const darkModeToggleHome = document.getElementById('dark-mode-toggle');
        const darkModeToggleChat = document.getElementById('dark-mode-toggle-chat');
        const iconMoonHome = darkModeToggleHome.querySelector('.icon-moon-text');
        const iconSunHome = darkModeToggleHome.querySelector('.icon-sun-text');
        const iconMoonChat = darkModeToggleChat.querySelector('.icon-moon-text');
        const iconSunChat = darkModeToggleChat.querySelector('.icon-sun-text');


        // Application State
        let currentUserId = null;
        let currentRoom = null;
        let unsubscribeRoomListener = null;
        let unsubscribeMessagesListener = null;
        let currentMode = 'default'; // 'default' or 'random'
        let inactivityTimer = null; // Timer for room inactivity
        const INACTIVITY_TIMEOUT_MS = 15 * 60 * 1000; // 15 minutes in milliseconds

        // Global variable to store the user object for quick access on exit
        let currentUserObject = null;

        // Utility function to generate a random room code (6 characters)
        const generateRoomCode = () => {
            let result = '';
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const charactersLength = characters.length;
            for (let i = 0; i < 6; i++) { // Increased length to 6
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
        };

        // Function to show custom modal messages
        const showModal = (title, message, onConfirmCallback, showCancel = false, onCancelCallback = () => hideModal(), showPasswordInput = false) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.toggle('hidden', !showCancel);

            // Ensure password input group and error are hidden by default for any new modal display
            modalPasswordInputGroup.classList.add('hidden');
            modalPasswordError.classList.add('hidden');

            if (showPasswordInput) {
                modalPasswordInputGroup.classList.remove('hidden');
            }

            modalPasswordInput.value = ''; // Clear password input on modal open

            // IMPORTANT CHANGE HERE: onConfirmCallback now handles hiding the modal
            modalOkBtn.onclick = async () => { // Make it async if onConfirmCallback is async
                await onConfirmCallback(); // Execute the callback
                // The callback itself should decide when to hide the modal.
                // If it doesn't hide it, it means the modal should stay open (e.g., for error)
            };
            modalCancelBtn.onclick = () => {
                onCancelCallback();
                hideModal(); // Cancel always hides the modal
            };

            modalOverlay.classList.remove('hidden');
            // Trigger animation
            setTimeout(() => {
                modalContent.classList.add('show'); // Add 'show' class to trigger CSS animation
            }, 10);
        };

        const hideModal = () => {
            modalContent.classList.remove('show'); // Remove 'show' class to reverse CSS animation
            setTimeout(() => {
                modalOverlay.classList.add('hidden');
                // Explicitly hide password input group and error when modal is hidden
                modalPasswordInputGroup.classList.add('hidden');
                modalPasswordError.classList.add('hidden');
            }, 300); // Match animation duration
        };

        // Function to show privacy policy modal
        const showPrivacyPolicyModal = () => {
            privacyPolicyModalOverlay.classList.remove('hidden');
            setTimeout(() => {
                privacyPolicyModalContent.classList.add('show');
            }, 10);
        };

        // Function to hide privacy policy modal
        const hidePrivacyPolicyModal = () => {
            privacyPolicyModalContent.classList.remove('show');
            setTimeout(() => {
                privacyPolicyModalOverlay.classList.add('hidden');
            }, 300);
        };

        // Function to update UI based on current room state
        const updateUI = () => {
            loadingScreen.classList.add('hidden'); // Hide loading screen once auth is ready

            if (currentRoom) {
                homeScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('hidden');
                chatRoomScreen.classList.add('animate-scaleIn'); // Apply animation
                homeScreen.classList.remove('animate-scaleIn'); // Ensure home screen animation is removed
                currentRoomCodeDisplay.textContent = currentRoom.code;
                renderParticipants(currentRoom.users);
                // Set max participants display
                maxParticipantsDisplay.textContent = currentRoom.maxParticipants || 4; // Default to 4 if not set
                // Enable message input and send button if current user is in the room
                const isCurrentUserInRoom = currentRoom.users.some(u => u.userId === currentUserId);
                newMessageInput.disabled = !isCurrentUserInRoom;
                sendMessageBtn.disabled = !isCurrentUserInRoom;
            } else {
                homeScreen.classList.remove('hidden');
                homeScreen.classList.add('animate-scaleIn'); // Apply animation
                chatRoomScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('animate-scaleIn'); // Ensure chat screen animation is removed
                updateModeUI(currentMode); // Ensure mode UI is correct when returning to home
            }
        };

        // Render participants list
        const renderParticipants = (users) => {
            participantsList.innerHTML = ''; // Clear previous participants
            participantsCount.textContent = users.length;
            // maxParticipantsDisplay is updated in updateUI based on currentRoom.maxParticipants
            users.forEach(user => {
                const span = document.createElement('span');
                span.className = `${user.userId === currentUserId ? 'bg-indigo-100' : 'bg-gray-100'}`;
                span.textContent = `${user.username} ${user.userId === currentUserId ? '(You)' : ''}`;
                participantsList.appendChild(span);
            });
        };

        // Render messages
        const renderMessages = (messages) => {
            messagesContainer.innerHTML = ''; // Clear existing messages
            if (messages.length === 0) {
                noMessagesYet.classList.remove('hidden');
            } else {
                noMessagesYet.classList.add('hidden');
                messages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message-item ${msg.senderId === currentUserId ? 'justify-end' : 'justify-start'}`;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = "message-content";

                    const senderSpan = document.createElement('div');
                    senderSpan.className = "sender-info";
                    senderSpan.textContent = msg.senderId === currentUserId ? 'You' : msg.senderUsername;

                    const textP = document.createElement('p');
                    textP.textContent = msg.text;

                    const timestampDiv = document.createElement('div');
                    timestampDiv.className = "timestamp";
                    // Ensure timestamp is a Date object before calling toLocaleTimeString
                    const date = msg.timestamp && msg.timestamp.toDate ? msg.timestamp.toDate() : new Date();
                    timestampDiv.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                    contentDiv.appendChild(senderSpan);
                    contentDiv.appendChild(textP); // Always append text for now
                    contentDiv.appendChild(timestampDiv);
                    messageDiv.appendChild(contentDiv);
                    messagesContainer.appendChild(messageDiv);
                });
            }
            messagesContainer.appendChild(messagesEndRef); // Ensure scroll target is always at the end
            messagesEndRef.scrollIntoView({ behavior: 'smooth' });
        };

        // Firebase Authentication
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = `Your User ID: ${currentUserId}`;
            } else {
                try {
                    // For self-hosted apps, always sign in anonymously
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Error signing in:", error);
                    showModal("Authentication Error", "Could not sign in. Please try again.", () => { hideModal(); }); // MODIFIED
                }
            }
            updateUI(); // Show UI after authentication
        });

        // Function to create a room (can be called by create button or random join)
        const createRoom = async (username, password = null, maxParticipants = 4) => {
            let newRoomCode = generateRoomCode();
            let roomExists = true;
            let attempts = 0;
            const maxAttempts = 10;

            while (roomExists && attempts < maxAttempts) {
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, newRoomCode);
                const docSnap = await getDoc(roomRef);
                if (!docSnap.exists()) {
                    roomExists = false;
                } else {
                    newRoomCode = generateRoomCode();
                    attempts++;
                }
            }

            if (roomExists) {
                showModal("Error", "Could not generate a unique room code. Please try again.", () => { hideModal(); }); // MODIFIED
                return null;
            }

            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, newRoomCode);
            const user = { userId: currentUserId, username: username };
            const roomData = {
                code: newRoomCode,
                users: [user],
                createdAt: serverTimestamp(),
                lastActivity: serverTimestamp(), // Initialize last activity
                maxParticipants: maxParticipants, // Store max participants
            };

            if (password) {
                roomData.password = password;
            }

            try {
                await setDoc(roomRef, roomData);
                // Set currentUserObject and add beforeunload listener
                currentUserObject = user;
                window.addEventListener('beforeunload', handlePageExit);
                return { code: newRoomCode, users: [user], maxParticipants: maxParticipants };
            } catch (error) {
                console.error("Error creating room:", error);
                showModal("Creation Failed", "Failed to create room. Please try again.", () => { hideModal(); }); // MODIFIED
                return null;
            }
        };

        // Event listener for Create Room button (Default Mode)
        createRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const password = createPasswordInput.value.trim();
            const maxParticipants = parseInt(maxParticipantsInput.value, 10);

            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => { hideModal(); }); // MODIFIED
                return;
            }

            if (isNaN(maxParticipants) || maxParticipants < 2 || maxParticipants > 10) {
                showModal("Invalid Max Participants", "Please set max participants between 2 and 10.", () => { hideModal(); }); // MODIFIED
                return;
            }

            const room = await createRoom(username, password, maxParticipants);
            if (room) {
                currentRoom = room;
                roomCodeInput.value = room.code;
                createPasswordInput.value = '';
                setupRoomListeners(room.code);
                updateUI();
                // hideModal(); // This is handled by performJoinRoomTransaction or the error callbacks
            }
        });

        // Helper function to perform the actual join transaction
        const performJoinRoomTransaction = async (roomRef, roomCode, username, currentUsers, roomMaxParticipants) => {
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    const roomData = roomDoc.data();
                    const usersAfterRecheck = roomData.users || [];
                    const maxAllowedUsers = roomData.maxParticipants || roomMaxParticipants || 4; // Use room's maxParticipants or default

                    if (usersAfterRecheck.length >= maxAllowedUsers) {
                        return Promise.reject(new Error("Room full (re-check)"));
                    }
                    if (usersAfterRecheck.some(u => u.username.toLowerCase() === username.toLowerCase())) {
                        return Promise.reject(new Error("Username taken (re-check)"));
                    }

                    const newUser = { userId: currentUserId, username: username };
                    transaction.update(roomRef, {
                        users: arrayUnion(newUser),
                        lastActivity: serverTimestamp() // Update last activity on join
                    });

                    currentRoom = { code: roomCode, users: [...usersAfterRecheck, newUser], maxParticipants: maxAllowedUsers };
                });
                // Set currentUserObject and add beforeunload listener
                currentUserObject = { userId: currentUserId, username: username };
                window.addEventListener('beforeunload', handlePageExit);

                setupRoomListeners(roomCode);
                updateUI();
                hideModal(); // Hide modal on successful join
            } catch (error) {
                console.error("Error joining room (transaction):", error);
                let errorMessage = "Failed to join room. Please try again.";
                if (error.message.includes("Room full")) errorMessage = "Room is now full. Please try another room.";
                if (error.message.includes("Username taken")) errorMessage = "Username was taken. Please choose another.";
                showModal("Join Failed", errorMessage, () => { hideModal(); }); // MODIFIED
            }
        };

        // Event listener for Join Room button (Default Mode)
        joinRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const roomCode = roomCodeInput.value.trim().toUpperCase();

            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => { hideModal(); }); // MODIFIED
                return;
            }
            if (!roomCode) {
                showModal("Invalid Room Code", "Please enter a room code.", () => { hideModal(); }); // MODIFIED
                return;
            }

            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);

            try {
                const roomDoc = await getDoc(roomRef);

                if (!roomDoc.exists()) {
                    showModal("Room Not Found", "The room code you entered does not exist.", () => { hideModal(); }); // MODIFIED
                    return;
                }

                const roomData = roomDoc.data();
                const currentUsers = roomData.users || [];
                const maxAllowedUsers = roomData.maxParticipants || 4; // Use room's maxParticipants or default

                if (currentUsers.length >= maxAllowedUsers) {
                    showModal("Room Full", `This room has reached its maximum capacity (${maxAllowedUsers} users).`, () => { hideModal(); }); // MODIFIED
                    return;
                }

                if (currentUsers.some(u => u.username.toLowerCase() === username.toLowerCase())) {
                    showModal("Username Taken", "This username is already taken in this room. Please choose another.", () => { hideModal(); }); // MODIFIED
                    return;
                }

                // Handle password protected rooms
                if (roomData.password) {
                    const promptForPassword = () => {
                        showModal(
                            "Enter Password",
                            "This room is password protected. Please enter the password.",
                            async () => { // This is onConfirmCallback
                                const enteredPassword = modalPasswordInput.value.trim();
                                if (enteredPassword === roomData.password) {
                                    modalPasswordError.classList.add('hidden'); // Clear error if correct
                                    await performJoinRoomTransaction(roomRef, roomCode, username, currentUsers, maxAllowedUsers);
                                    // hideModal() is called by performJoinRoomTransaction on success
                                } else {
                                    modalPasswordError.textContent = "Incorrect password. Please try again.";
                                    modalPasswordError.classList.remove('hidden');
                                    modalPasswordInput.value = ''; // Clear input for re-entry
                                    // Do NOT call hideModal() here. Modal stays open.
                                }
                            },
                            true, // showCancel
                            () => { // onCancelCallback
                                // User cancelled, hideModal will be called by showModal's default cancel logic.
                            },
                            true // showPasswordInput
                        );
                    };
                    promptForPassword(); // Initial call to prompt for password
                } else {
                    await performJoinRoomTransaction(roomRef, roomCode, username, currentUsers, maxAllowedUsers);
                }

            } catch (error) {
                console.error("Error joining room (initial check):", error);
                showModal("Join Failed", "Failed to join room. Please check the code and try again.", () => { hideModal(); }); // MODIFIED
            }
        });

        // Event listener for Join Random Room button (Random Mode)
        joinRandomRoomBtn.addEventListener('click', async () => {
            const username = randomUsernameInput.value.trim();
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => { hideModal(); }); // MODIFIED
                return;
            }

            // Check if random mode warning has been shown
            const randomWarningShown = localStorage.getItem('randomWarningShown');
            if (!randomWarningShown) {
                showModal("Anonymous Chat Warning", "You are about to join a random, unmoderated, and temporary chat room. Do not share personal information.", async () => {
                    localStorage.setItem('randomWarningShown', 'true'); // Mark as shown
                    await findRandomRoom(username);
                    // The findRandomRoom function will call showModal again if no rooms are found,
                    // or performJoinRoomTransaction which calls hideModal on success.
                    // So, no hideModal() here.
                }, true, () => {
                    // User cancelled the warning, do nothing
                });
            } else {
                await findRandomRoom(username);
                // No hideModal() here, as findRandomRoom will handle it (or its subsequent calls)
            }
        });

        const findRandomRoom = async (username) => {
            const roomsCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms`);
            try {
                // Query for rooms that are not full, have at least one member, and no password
                const q = query(
                    roomsCollectionRef,
                    where('users', '!=', []), // Ensures 'users' array is not empty
                );
                const querySnapshot = await getDocs(q);
                let availableRooms = [];

                querySnapshot.forEach(docSnap => {
                    const roomData = docSnap.data();
                    const maxAllowedUsers = roomData.maxParticipants || 4; // Default to 4 if not set
                    // Client-side filtering for rooms that are not full and have no password
                    if (roomData.users && roomData.users.length > 0 && roomData.users.length < maxAllowedUsers && !roomData.password) {
                        availableRooms.push(roomData);
                    }
                });

                if (availableRooms.length > 0) {
                    // Pick a random available room
                    const randomIndex = Math.floor(Math.random() * availableRooms.length);
                    const roomToJoin = availableRooms[randomIndex];
                    const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomToJoin.code);

                    // Attempt to join the selected room
                    await performJoinRoomTransaction(roomRef, roomToJoin.code, username, roomToJoin.maxParticipants);
                } else {
                    // No suitable random room found, do NOT create a new one
                    showModal("No Random Rooms Available", "Sorry, no random rooms are currently available. Please try again later or create a new room in Default Mode.", () => { hideModal(); }); // MODIFIED
                }
            } catch (error) {
                console.error("Error finding random room:", error);
                showModal("Error", "Failed to find a random room. Please try again.", () => { hideModal(); }); // MODIFIED
            }
        };


        // Setup real-time listeners for room data and messages
        const setupRoomListeners = (roomCode) => {
            // Unsubscribe previous listeners if any
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            // Clear any existing inactivity timer
            if (inactivityTimer) {
                clearInterval(inactivityTimer);
                inactivityTimer = null;
            }


            const roomDocRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);
            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomCode}/messages`);

            // Listen for room data changes (users, capacity)
            unsubscribeRoomListener = onSnapshot(roomDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const roomData = docSnap.data();
                    currentRoom = { ...currentRoom, users: roomData.users || [], maxParticipants: roomData.maxParticipants || 4, lastActivity: roomData.lastActivity }; // Update maxParticipants and lastActivity
                    renderParticipants(currentRoom.users);
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants; // Update display

                    // Reset inactivity timer on any room data update
                    if (inactivityTimer) {
                        clearInterval(inactivityTimer);
                    }
                    inactivityTimer = setInterval(() => checkInactivity(roomDocRef), 60 * 1000); // Check every minute

                    // Check for inactivity immediately on snapshot
                    checkInactivity(roomDocRef);

                } else {
                    // Room no longer exists (deleted by another client or timeout)
                    showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal(); // MODIFIED
                    });
                }
            }, (error) => {
                console.error("Error listening to room:", error);
                showModal("Connection Error", "Failed to get room updates. Please check your internet connection.", () => { hideModal(); }); // MODIFIED
            });

            // Listen for messages
            unsubscribeMessagesListener = onSnapshot(query(messagesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
                const newMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderMessages(newMessages);
                // Also update room's last activity when a message is received (implies activity)
                if (currentRoom && currentRoom.code) {
                    const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                    updateDoc(roomRef, {
                        lastActivity: serverTimestamp()
                    }).catch(e => console.error("Error updating last activity on message receive:", e));
                }
            }, (error) => {
                console.error("Error listening to messages:", error);
                showModal("Connection Error", "Failed to get message updates. Please check your internet connection.", () => { hideModal(); }); // MODIFIED
            });
        };

        // Function to check for room inactivity
        const checkInactivity = async (roomDocRef) => {
            if (!currentRoom || !currentRoom.lastActivity) return;

            const lastActivityTime = currentRoom.lastActivity.toDate().getTime();
            const currentTime = Date.now();

            if (currentTime - lastActivityTime >= INACTIVITY_TIMEOUT_MS) {
                // Room has timed out
                if (inactivityTimer) {
                    clearInterval(inactivityTimer);
                    inactivityTimer = null;
                }

                showModal("Room Timed Out", "This room has been deleted due to inactivity.", async () => {
                    handleLeaveRoomCleanUp();
                    hideModal(); // MODIFIED
                    // Attempt to delete the room document. This is idempotent.
                    try {
                        await deleteDoc(roomDocRef);
                        console.log(`Room ${currentRoom.code} deleted due to inactivity.`);
                    } catch (e) {
                        console.warn(`Could not delete timed out room ${currentRoom.code}, it might have already been deleted:`, e);
                    }
                });
            }
        };


        // Handle sending a message
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newMessageText = newMessageInput.value.trim();

            if (!newMessageText) {
                return;
            }
            if (!currentRoom || !currentUserId) return;

            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.code}/messages`);
            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code); // Reference to the room document

            try {
                await addDoc(messagesCollectionRef, {
                    senderId: currentUserId,
                    senderUsername: (currentMode === 'default' ? usernameInput.value.trim() : randomUsernameInput.value.trim()),
                    type: 'text', // Explicitly set type to text
                    text: newMessageText,
                    timestamp: serverTimestamp(),
                });

                // Update room's lastActivity after sending a message
                await updateDoc(roomRef, {
                    lastActivity: serverTimestamp()
                });

                newMessageInput.value = ''; // Clear input
            } catch (error) {
                console.error("Error sending message:", error);
                showModal("Message Failed", "Failed to send message. Please try again.", () => { hideModal(); }); // MODIFIED
            }
        });

        // Handle leaving the room
        leaveRoomBtn.addEventListener('click', () => {
            showModal("Leave Room", "Are you sure you want to leave this room?", async () => {
                if (!currentRoom || !currentUserId) return;

                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                // Determine the current username based on the active mode
                const currentUsername = (currentMode === 'default' ? usernameInput.value.trim() : randomUsernameInput.value.trim());

                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (roomDoc.exists()) {
                            const roomData = roomDoc.data();
                            const currentUsers = roomData.users || [];

                            // Find the exact user object to remove based on userId
                            const userObjectInFirestore = currentUsers.find(u => u.userId === currentUserId);

                            if (userObjectInFirestore) { // Ensure the user is actually found in the list
                                const updatedUsers = currentUsers.filter(u => u.userId !== currentUserId);

                                if (updatedUsers.length === 0) {
                                    // If no users left, delete the room
                                    transaction.delete(roomRef);
                                } else {
                                    // Otherwise, just update the user list and lastActivity
                                    transaction.update(roomRef, {
                                        users: arrayRemove(userObjectInFirestore),
                                        lastActivity: serverTimestamp() // Update last activity on leave
                                    });
                                }
                            } else {
                                console.warn("Attempted to leave room, but user not found in participants list in Firestore. Proceeding with cleanup.");
                            }
                        }
                    });
                    handleLeaveRoomCleanUp();
                    hideModal(); // Hide modal after successful leave
                } catch (error) {
                    console.error("Error leaving room:", error);
                    showModal("Leave Room Failed", "Could not leave the room. Please try again.", () => { hideModal(); }); // MODIFIED
                }
            }, true); // Show cancel button
        });

        // Clean up function when leaving a room (local state and listeners)
        const handleLeaveRoomCleanUp = () => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) {
                clearInterval(inactivityTimer);
                inactivityTimer = null;
            }
            // Remove beforeunload listener
            window.removeEventListener('beforeunload', handlePageExit);
            currentUserObject = null; // Clear the user object

            currentRoom = null;
            roomCodeInput.value = '';
            newMessageInput.value = '';
            messagesContainer.innerHTML = ''; // Clear messages display
            noMessagesYet.classList.remove('hidden'); // Show "No messages yet"
            updateUI();
        };

        // Function to handle page exit (browser close, tab close, navigation away)
        const handlePageExit = () => { // Made synchronous as beforeunload doesn't wait for async
            if (currentRoom && currentUserId && currentUserObject) {
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                // This is a best-effort attempt as browser might terminate before write completes.
                // Do NOT use await here as beforeunload/unload events are synchronous and won't wait for promises.
                try {
                    getDoc(roomRef).then(roomDoc => {
                        if (roomDoc.exists()) {
                            const roomData = roomDoc.data();
                            const currentUsersInFirestore = roomData.users || [];
                            const userToReallyRemove = currentUsersInFirestore.find(u => u.userId === currentUserId);

                            if (userToReallyRemove) {
                                const updatedUsers = currentUsersInFirestore.filter(u => u.userId !== currentUserId);
                                if (updatedUsers.length === 0) {
                                    // If no users left, delete the room
                                    deleteDoc(roomRef).catch(e => console.warn("Failed to delete room on exit (best-effort):", e));
                                } else {
                                    // Otherwise, just update the user list and lastActivity
                                    updateDoc(roomRef, {
                                        users: arrayRemove(userToReallyRemove),
                                        lastActivity: serverTimestamp()
                                    }).catch(e => console.warn("Failed to remove user on exit (best-effort):", e));
                                }
                            }
                        }
                    }).catch(e => console.warn("Error attempting to remove user on page exit (getDoc):", e));
                } catch (e) {
                    console.warn("Error attempting to remove user on page exit (outer catch):", e);
                }
            }
        };


        // Dark Mode Toggle Logic
        const applyDarkMode = (isDarkMode) => {
            document.body.classList.toggle('dark-mode', isDarkMode);
            iconMoonHome.classList.toggle('hidden', isDarkMode);
            iconSunHome.classList.toggle('hidden', !isDarkMode);
            iconMoonChat.classList.toggle('hidden', isDarkMode);
            iconSunChat.classList.toggle('hidden', !isDarkMode);
        };

        darkModeToggleHome.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });

        darkModeToggleChat.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });

        // Apply dark mode on load if previously enabled
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') {
            applyDarkMode(true);
        } else {
            applyDarkMode(false);
        }

        // Mode Switching Logic
        const updateModeUI = (mode) => {
            currentMode = mode;
            if (mode === 'default') {
                defaultModeBtn.classList.add('active');
                randomModeBtn.classList.remove('active');
                defaultModeContainer.classList.remove('hidden');
                randomModeContainer.classList.add('hidden');
                // Clear random mode input when switching away
                randomUsernameInput.value = '';
            } else { // random mode
                randomModeBtn.classList.add('active');
                defaultModeBtn.classList.remove('active');
                randomModeContainer.classList.remove('hidden');
                defaultModeContainer.classList.add('hidden');
                // Clear default mode inputs when switching away
                usernameInput.value = '';
                createPasswordInput.value = '';
                roomCodeInput.value = '';
                createPasswordInputGroup.style.display = 'none'; // Hide password input
                maxParticipantsInput.value = '4'; // Reset max participants to default
            }
        };

        defaultModeBtn.addEventListener('click', () => updateModeUI('default'));
        randomModeBtn.addEventListener('click', () => updateModeUI('random'));

        // Show/hide password input for create room based on default username input
        usernameInput.addEventListener('input', () => {
            if (usernameInput.value.trim() !== '') {
                createPasswordInputGroup.style.display = 'block';
            } else {
                createPasswordInputGroup.style.display = 'none';
                createPasswordInput.value = ''; // Clear password if username is cleared
            }
        });

        // Event listeners for Privacy Policy Modal
        privacyPolicyLink.addEventListener('click', showPrivacyPolicyModal);
        privacyPolicyCloseBtn.addEventListener('click', hidePrivacyPolicyModal);

        // Initial UI update after script loads and before auth completes
        document.addEventListener('DOMContentLoaded', () => {
            homeScreen.classList.add('hidden');
            chatRoomScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            // Set initial mode to default and update UI
            updateModeUI('default');
            // Trigger initial check for username input to show password field if pre-filled
            if (usernameInput.value.trim() !== '') {
                createPasswordInputGroup.style.display = 'block';
            }
        });

    </script>
</body>
</html>
