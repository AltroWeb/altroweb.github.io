<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Textroll - Web Chat</title>
        <!-- Content Security Policy (CSP) Meta Tag -->
    <!-- This CSP is designed to allow necessary resources while restricting others. -->
    <!-- 'self': Allows resources from the same origin as the document. -->
    <!-- 'unsafe-inline': Allows inline scripts and styles. This is generally NOT recommended for production -->
    <!--                  but is often necessary for quick demos or when using frameworks like Tailwind JIT -->
    <!--                  without a build step that hashes inline styles. For production, prefer hashes or nonces. -->
    <!-- https://cdn.tailwindcss.com: For Tailwind CSS. -->
    <!-- https://www.gstatic.com: For Firebase SDK and other Google static assets. -->
    <!-- https://www.gstatic.com/firebasejs/: More specific for Firebase SDK. -->
    <!-- https://cdnjs.cloudflare.com: For general third-party libraries (e.g., Three.js, Cannon.js, etc.). -->
    <!-- https://firestore.googleapis.com: For Firestore API calls. -->
    <!-- https://securetoken.googleapis.com: For Firebase Authentication. -->
    <!-- https://fonts.googleapis.com & https://fonts.gstatic.com: For Google Fonts. -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' https://cdn.tailwindcss.com https://www.gstatic.com https://www.gstatic.com/firebasejs/ 'unsafe-inline';
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.tailwindcss.com;
        connect-src 'self' https://firestore.googleapis.com https://securetoken.googleapis.com;
        font-src 'self' https://fonts.gstatic.com;
        img-src 'self' data: https://placehold.co;
    ">

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="textroll.png">
    <style>
        /* CSS Variables for Theming */
        :root {
            /* Light Mode Colors */
            --bg-gradient-start: #8b5cf6; /* purple-500 */
            --bg-gradient-end: #4f46e5;   /* indigo-600 */
            --text-color-primary: #374151; /* gray-800 */
            --text-color-secondary: #4b5563; /* gray-600 */
            --card-bg: #fff;
            --header-text: #4338ca; /* indigo-700 */
            --room-code-text: #9333ea; /* purple-600 */
            --border-color: #e5e7eb; /* gray-200 */
            --input-border: #d1d5db; /* gray-300 */
            --input-bg-disabled: #f3f4f6; /* gray-100 */
            --button-bg-indigo: #4f46e5; /* indigo-600 */
            --button-hover-indigo: #4338ca; /* indigo-700 */
            --button-bg-purple: #9333ea; /* purple-600 */
            --button-hover-purple: #7e22ce; /* purple-700 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #2563eb; /* blue-600 */
            --button-hover-blue: #1d4ed8; /* blue-700 */
            --button-disabled-bg: #9ca3af; /* gray-400 */
            --participant-bg-you: #e0e7ff; /* indigo-100 */
            --participant-text-you: #4338ca; /* indigo-700 */
            --participant-bg-other: #f3f4f6; /* gray-100 */
            --message-bg-you: #6366f1; /* indigo-500 */
            --message-bg-other: #e5e7eb; /* gray-200 */
            --message-text-you: #fff;
            --message-text-other: #1f2937; /* gray-800 */
            --message-timestamp-opacity: 0.6;
            --chat-bg: #f9fafb; /* gray-50 */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-color-dark: rgba(0, 0, 0, 0.04);
            --modal-shadow-color: rgba(0, 0, 0, 0.25);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.06);
            --focus-ring-indigo: rgba(99, 102, 241, 0.5);
            --focus-ring-purple: rgba(168, 85, 247, 0.75);
            --focus-ring-red: rgba(239, 68, 68, 0.75);
            --focus-ring-blue: rgba(59, 130, 246, 0.5);
            --focus-ring-gray: rgba(156, 163, 175, 0.75);
            --button-shadow-offset: 0 4px 6px -1px;
            --button-shadow-blur: 0 2px 4px -1px;
        }

        /* Dark Mode Colors */
        .dark-mode {
            --bg-gradient-start: #1f2937; /* dark gray */
            --bg-gradient-end: #0f172a;   /* darker blue-gray */
            --text-color-primary: #e5e7eb; /* gray-200 */
            --text-color-secondary: #d1d5db; /* gray-300 */
            --card-bg: #374151; /* gray-700 */
            --header-text: #a78bfa; /* purple-400 */
            --room-code-text: #c084fc; /* purple-500 */
            --border-color: #4b5563; /* gray-600 */
            --input-border: #6b7280; /* gray-500 */
            --input-bg-disabled: #4b5563; /* gray-600 */
            --button-bg-indigo: #6366f1; /* indigo-500 */
            --button-hover-indigo: #4f46e5; /* indigo-600 */
            --button-bg-purple: #a855f7; /* purple-500 */
            --button-hover-purple: #9333ea; /* purple-600 */
            --button-bg-red: #ef4444; /* red-500 */
            --button-hover-red: #dc2626; /* red-600 */
            --button-bg-blue: #3b82f6; /* blue-500 */
            --button-hover-blue: #2563eb; /* blue-600 */
            --button-disabled-bg: #4b5563; /* gray-600 */
            --participant-bg-you: #4f46e5; /* indigo-600 */
            --participant-text-you: #e0e7ff; /* indigo-100 */
            --participant-bg-other: #4b5563; /* gray-600 */
            --message-bg-you: #4f46e5; /* indigo-600 */
            --message-bg-other: #4b5563; /* gray-600 */
            --message-text-you: #e5e7eb;
            --message-text-other: #e5e7eb;
            --message-timestamp-opacity: 0.7;
            --chat-bg: #374151; /* gray-700 */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-color-dark: rgba(0, 0, 0, 0.2);
            --modal-shadow-color: rgba(0, 0, 0, 0.4);
            --modal-shadow-color-dark: rgba(0, 0, 0, 0.2);
        }

        /* Universal Font and Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth dark mode transition */
        }

        /* All elements inherit font, remove default button borders */
        * {
            font-family: inherit;
            box-sizing: border-box; /* Ensure consistent box model */
        }
        button {
            border: none; /* Remove default button borders */
            outline: none; /* Remove default focus outline */
            cursor: pointer;
        }

        /* Custom scrollbar for chat messages */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: var(--input-bg-disabled);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Animations */
        @keyframes scaleIn {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        .animate-scaleIn {
            animation: scaleIn 0.3s ease-out forwards;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom right, var(--bg-gradient-start), var(--bg-gradient-end));
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #loading-screen.hidden {
            display: none;
        }

        /* Modal Styles */
        #modal-overlay, #privacy-policy-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(107, 114, 128, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        #modal-overlay.hidden, #privacy-policy-modal-overlay.hidden {
            display: none;
        }
        #modal-content, #privacy-policy-modal-content {
            background-color: var(--card-bg);
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px var(--modal-shadow-color), 0 10px 10px -5px var(--modal-shadow-color-dark);
            padding: 1.5rem;
            max-width: 24rem;
            width: 100%;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.3s ease-in-out;
            color: var(--text-color-primary);
        }
        #privacy-policy-modal-content {
            max-width: 36rem; /* Wider for policy text */
            max-height: 80vh; /* Limit height to enable scrolling */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            border-radius: 0.75rem; /* Rounded corners for the policy modal */
        }
        #modal-content.show, #privacy-policy-modal-content.show {
            transform: scale(1);
            opacity: 1;
        }
        #modal-title, #privacy-policy-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 1rem;
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        #modal-message {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
        }
        #privacy-policy-text {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
            flex-grow: 1; /* Allow content to grow and take available space */
            overflow-y: auto; /* Enable vertical scrolling for content */
            padding-right: 0.5rem; /* Add some padding for scrollbar */
        }
        #modal-buttons, #privacy-policy-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
            padding-top: 0.5rem; /* Space between content and buttons */
        }
        #modal-cancel-btn, #privacy-policy-close-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            color: var(--text-color-primary);
            background-color: var(--border-color);
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-cancel-btn:hover, #privacy-policy-close-btn:hover {
            background-color: #d1d5db;
        }
        .dark-mode #modal-cancel-btn:hover, .dark-mode #privacy-policy-close-btn:hover {
            background-color: #6b7280;
        }
        #modal-cancel-btn.hidden {
            display: none;
        }
        #modal-ok-btn {
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            background-color: var(--button-bg-blue);
            color: #fff;
            transition: background-color 0.2s ease-in-out;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #modal-ok-btn:hover {
            background-color: var(--button-hover-blue);
        }
        /* Password input group and error */
        #modal-password-input-group {
            margin-bottom: 1.5rem; /* Spacing below the group */
            padding: 0.75rem; /* Internal padding for the group */
            border: 1px solid var(--input-border); /* Subtle border */
            border-radius: 0.5rem; /* Rounded corners */
            background-color: var(--input-bg-disabled); /* Light background */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .dark-mode #modal-password-input-group {
            background-color: var(--border-color); /* Darker background for dark mode */
        }
        #modal-password-input-group label {
            margin-bottom: 0.75rem; /* More space below label */
            padding-left: 0.25rem; /* Align text with input */
        }
        #modal-password-input {
            width: 100%;
            padding: 0.8rem; /* Slightly more padding for input field */
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
            font-size: 1rem; /* Ensure good readability */
        }
        #modal-password-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px var(--focus-ring-indigo); /* Slightly thicker focus ring */
            border-color: transparent;
        }
        #modal-password-error {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem;
            margin-top: 0.5rem;
            text-align: left;
            display: block; /* Ensure it takes its own line */
        }
        /* IMPORTANT: Force hidden elements to be display: none */
        .hidden {
            display: none !important;
        }


        /* Focus styles for buttons */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-blue);
        }
        #modal-cancel-btn:focus, #privacy-policy-close-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-gray);
        }
        #leave-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red);
        }
        #create-room-btn:focus, #send-message-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
        }
        #join-room-btn:focus, #join-random-room-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-purple);
        }

        /* Dark Mode Toggle Button */
        .dark-mode-toggle-container {
            /* Removed absolute positioning for chat screen, now part of flex header */
            z-index: 10; /* Ensure it's above other elements in the card */
            display: flex; /* To center emoji */
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Explicitly prevent shrinking */
        }
        /* Specific adjustment for the toggle button within the home screen */
        #home-screen .dark-mode-toggle-container {
           margin-top: 2rem;
        }
        #dark-mode-toggle, #dark-mode-toggle-chat {
            background-color: var(--card-bg);
            color: var(--text-color-primary); /* Icon color */
            border: none;
            border-radius: 9999px;
            padding: 0.75rem;
            font-size: 1.25rem; /* Controls emoji size */
            cursor: pointer;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        }
        #dark-mode-toggle:hover, #dark-mode-toggle-chat:hover {
            transform: scale(1.1);
        }
        #dark-mode-toggle:active, #dark-mode-toggle-chat:active {
            transform: scale(0.95);
        }

        /* Text Icon specific styles */
        .icon-moon-text { display: block; }
        .icon-sun-text { display: none; }
        .dark-mode .icon-moon-text { display: none; }
        .dark-mode .icon-sun-text { display: block; }


        /* Home Screen */
        #home-screen {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 28rem;
            text-align: center;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
            position: relative; /* For dark mode toggle positioning */
        }
        #home-screen.hidden {
            display: none;
        }
        #home-screen h1 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--header-text);
            margin-bottom: 1.5rem;
            letter-spacing: -0.025em;
        }
        #home-screen p {
            color: var(--text-color-secondary);
            margin-bottom: 2rem;
            font-size: 1.125rem;
        }
        #home-screen .input-group {
            margin-bottom: 1.5rem;
        }
        #home-screen .input-group label {
            display: block;
            text-align: left;
            color: var(--text-color-primary);
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        #home-screen input[type="text"],
        #home-screen input[type="number"], /* Added for max participants */
        #home-screen input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #home-screen input[type="text"]:focus,
        #home-screen input[type="number"]:focus,
        #home-screen input[type="password"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #home-screen #create-password-input-group.hidden {
            display: none;
        }
        #home-screen .button-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #home-screen button {
            width: 100%;
            padding: 0.75rem 1.5rem;
            color: #fff;
            font-weight: 600;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        #home-screen button:hover {
            transform: scale(1.05);
        }
        #create-room-btn {
            background-color: var(--button-bg-indigo);
        }
        #create-room-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #join-room-btn, #join-random-room-btn { /* Apply purple to both join buttons */
            background-color: var(--button-bg-purple);
            color: #fff; /* Ensure text is white for contrast */
        }
        #join-room-btn:hover, #join-random-room-btn:hover {
            background-color: var(--button-hover-purple);
        }
        #user-id-display {
            font-size: 0.75rem;
            color: var(--text-color-secondary);
            margin-top: 1.5rem;
        }

        /* Chat Room Screen */
        #chat-room-screen {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px var(--modal-shadow-color);
            width: 100%;
            max-width: 42rem;
            display: flex;
            flex-direction: column;
            /* REVERTED: Fixed height for consistent scrolling */
            height: 85vh; 
            position: relative; /* Ensure it's relative as requested */
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.5s ease-in-out;
        }
        #chat-room-screen.hidden {
            display: none;
        }
        #chat-room-screen .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            gap: 0.25rem; /* Adjusted gap for tighter fit */
            flex-wrap: nowrap; /* Prevent wrapping/stacking on all screens */
        }
        /* Room Code: To appear fully and scale dynamically */
        #chat-room-screen h2 {
            font-size: clamp(1rem, 4vw, 1.875rem); /* Dynamically scales font size based on viewport width */
            font-weight: 700;
            color: var(--header-text);
            flex-grow: 1; /* Allows it to grow and take available space */
            flex-shrink: 1; /* Allow it to shrink if needed */
            text-align: center; /* Center the room code text */
            min-width: 0; /* Allows h2 to shrink down to 0 if necessary */
            /* REMOVED: overflow: hidden;, text-overflow: ellipsis;, white-space: nowrap; */
        }
        #current-room-code {
            color: var(--room-code-text);
        }
        /* Leave and Permanent Buttons: Text should appear with "..." if too large */
        #leave-room-btn {
            padding: 0.4rem 0.8rem; /* Smaller padding for compact size */
            font-size: 0.875rem; /* Smaller font size */
            background-color: var(--button-bg-red);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent button from shrinking */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #leave-room-btn:hover {
            background-color: var(--button-hover-red);
        }

        /* NEW: Styling for Permanent Mode Button */
        #toggle-permanent-mode-btn {
            padding: 0.4rem 0.8rem; /* Smaller padding */
            font-size: 0.875rem; /* Smaller font size */
            background-color: var(--button-bg-blue);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent button from shrinking */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        #toggle-permanent-mode-btn:hover {
            background-color: var(--button-hover-blue);
        }
        #toggle-permanent-mode-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* NEW: Styling for Permanent Room Indicator */
        #permanent-room-indicator {
            font-size: 0.55rem; /* Even smaller font */
            font-weight: 600;
            color: var(--room-code-text); /* Using room code text color for consistency */
            background-color: var(--participant-bg-you); /* Light background for visibility */
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
            white-space: nowrap; /* Prevent wrapping */
            flex-shrink: 0; /* Prevent from shrinking */
        }
        .dark-mode #permanent-room-indicator {
            background-color: var(--participant-bg-other);
        }


        #chat-room-screen .participants-section {
            margin-bottom: 1rem;
        }
        #chat-room-screen .participants-section h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin-bottom: 0.5rem;
        }
        #participants-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-color-secondary);
        }
        #participants-list span { /* This is the container for username and possibly remove button */
            display: flex; /* Use flex to align username and button */
            align-items: center; /* Vertically align items */
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
        }
        #participants-list span.bg-indigo-100 {
            background-color: var(--participant-bg-you);
            color: var(--participant-text-you);
            font-weight: 500;
        }
        #participants-list span.bg-gray-100 {
            background-color: var(--participant-bg-other);
            color: var(--text-color-primary);
        }
        .remove-participant-btn {
            background-color: transparent;
            color: var(--button-bg-red);
            border: none;
            padding: 0.1rem 0.3rem; /* Adjust padding for better visual */
            font-size: 0.9rem; /* Adjust size */
            font-weight: bold;
            border-radius: 0.25rem;
            margin-left: 0.5rem; /* Space between username and button */
            cursor: pointer;
            line-height: 1; /* Helps with vertical alignment */
        }
        .remove-participant-btn:hover {
            background-color: var(--button-hover-red);
            color: white;
        }
        .remove-participant-btn:focus {
            box-shadow: 0 0 0 2px var(--focus-ring-red); /* Specific focus for remove button */
        }


        #messages-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: var(--chat-bg);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease;
        }
        #no-messages-yet {
            text-align: center;
            color: var(--text-color-secondary);
            font-style: italic;
            margin-top: 1rem;
        }
        #no-messages-yet.hidden {
            display: none;
        }

        .message-item {
            display: flex;
            margin-bottom: 0.75rem;
        }
        .message-item.justify-end {
            justify-content: flex-end;
        }
        .message-item.justify-start {
            justify-content: flex-start;
        }
        .message-content {
            max-width: 70%;
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .message-item.justify-end .message-content {
            background-color: var(--message-bg-you);
            color: var(--message-text-you);
            border-bottom-right-radius: 0;
        }
        .message-item.justify-start .message-content {
            background-color: var(--message-bg-other);
            color: var(--message-text-other);
            border-bottom-left-radius: 0;
        }
        .message-content .sender-info {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            opacity: 0.8;
        }
        .message-content p {
            font-size: 0.875rem;
            word-break: break-word;
        }
        .message-content .timestamp {
            text-align: right;
            font-size: 0.75rem;
            opacity: var(--message-timestamp-opacity);
            margin-top: 0.25rem;
        }

        #message-form {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        #new-message-input {
            flex-grow: 1;
            padding: 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            background-color: var(--card-bg);
            color: var(--text-color-primary);
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.3s, color 0.3s;
        }
        #new-message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--focus-ring-indigo);
            border-color: transparent;
        }
        #new-message-input:disabled {
            background-color: var(--input-bg-disabled);
            cursor: not-allowed;
            color: var(--text-color-secondary);
        }
        #send-message-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--button-bg-indigo);
            color: #fff;
            border-radius: 0.5rem;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
            transition: background-color 0.2s ease-in-out;
        }
        #send-message-btn:hover {
            background-color: var(--button-hover-indigo);
        }
        #send-message-btn:disabled {
            background-color: var(--button-disabled-bg);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Footnote */
        #app-footnote {
            margin-top: 2rem; /* Spacing from the main content */
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7); /* Light white for contrast on gradient background */
            text-align: center;
            padding-bottom: 1rem; /* Ensure it's not right at the bottom edge */
        }
        #app-footnote a {
            color: inherit; /* Inherit color from parent */
            text-decoration: underline;
            
            cursor: pointer;
        }
        #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        .dark-mode #app-footnote {
            color: rgba(255, 255, 255, 0.5); /* Slightly darker for dark mode */
        }
        .dark-mode #app-footnote a:hover {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Mode Selection Styles */
        #mode-selection {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            width: 100%; /* Ensure it takes full width of parent */
        }
        #mode-selection button {
            flex: 1;
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            background-color: var(--card-bg); /* Default background */
            color: var(--text-color-primary); /* Default text color */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--button-shadow-offset) var(--shadow-color), var(--button-shadow-blur) var(--shadow-color-dark);
        }
        #mode-selection button.active {
            background-color: var(--button-bg-purple); /* Changed to purple */
            color: #fff;
            box-shadow: var(--button-shadow-offset) var(--button-bg-purple), var(--button-shadow-blur) var(--button-bg-purple); /* Changed to purple */
        }
        #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Lighter hover for non-active */
        }
        .dark-mode #mode-selection button:hover:not(.active) {
            background-color: var(--border-color); /* Darker hover for non-active */
        }

        /* Mode Containers */
        #default-mode-container,
        #random-mode-container {
            width: 100%;
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            gap: 1.5rem; /* Consistent spacing between input groups */
        }
        #default-mode-container.hidden,
        #random-mode-container.hidden {
            display: none;
        }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem; /* Re-added padding for overall layout */
                align-items: center; /* Re-centered content */
                justify-content: center; /* Re-centered content */
            }
            #home-screen {
                margin-top: 0; /* Remove specific mobile margins if body is centered */
                margin-bottom: 0;
            }
            #chat-room-screen {
                padding: 1.5rem;
                max-width: 100%;
                border-radius: 0.75rem; /* Restore border-radius */
                /* Reverted to original height and positioning for mobile */
                height: 85vh; /* Keep consistent height */
                position: relative; /* Keep consistent positioning */
            }
            #chat-room-screen .header {
                /* REVERTED: Keep header items in a row, prevent stacking */
                flex-direction: row; /* Ensure row direction */
                align-items: center; /* Vertically align items */
                flex-wrap: nowrap; /* Prevent wrapping/stacking */
                gap: 0.25rem; /* Keep original gap */
            }
            #chat-room-screen .header .dark-mode-toggle-container {
                /* REVERTED: Remove align-self, let flexbox handle it */
                align-self: auto; 
                margin-right: 0;
            }
            #chat-room-screen h2 {
                /* REMOVED: font-size: 1.5rem; */
                text-align: center; /* Keep room code centered */
                min-width: unset; 
            }
            #leave-room-btn, #toggle-permanent-mode-btn {
                /* REVERTED: Remove full width, let flex-shrink handle it */
                width: auto; 
                padding: 0.4rem 0.8rem; /* Keep smaller padding for touch targets */
                font-size: 0.875rem;
            }
            #permanent-room-indicator {
                align-self: center; /* Center the indicator if stacked */
            }

            #home-screen h1 {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }
            #home-screen p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }
            #home-screen .input-group {
                margin-bottom: 1rem;
            }
            #home-screen .button-group {
                gap: 0.75rem;
            }
            
            #chat-room-screen .participants-section h3 {
                font-size: 1rem;
            }
            #participants-list span {
                font-size: 0.75rem;
                padding: 0.2rem 0.6rem;
            }
            .remove-participant-btn {
                font-size: 0.8rem; /* Slightly smaller on mobile */
                padding: 0.1rem 0.25rem;
            }
            .message-content {
                max-width: 85%;
                padding: 0.6rem;
            }
            .message-content .sender-info, .message-content p, .message-content .timestamp {
                font-size: 0.8rem;
            }
            #message-form {
                flex-direction: column;
                gap: 0.5rem;
            }
            #new-message-input, #send-message-btn {
                width: 100%;
                padding: 0.6rem;
            }
            #send-message-btn {
                padding: 0.6rem 1rem;
            }
            /* Adjust dark mode toggle position for mobile in chat screen */
            #chat-room-screen .header .dark-mode-toggle-container {
                /* No specific right/left needed, flexbox handles it */
                margin-right: 0.5rem; /* Small margin to the right of the toggle */
            }
            #mode-selection {
                flex-direction: column;
            }
            #default-mode-container,
            #random-mode-container {
                gap: 1rem; /* Smaller gap on mobile */
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="loading-screen">
        <div class="text-2xl font-bold">Loading Textroll...</div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal-content">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="input-group hidden" id="modal-password-input-group">
                <label for="modal-password-input" class="hidden">Enter password:</label>
                <input type="password" id="modal-password-input" placeholder="Room password" />
                <span id="modal-password-error" class="hidden"></span> </div>
            <div id="modal-buttons">
                <button id="modal-cancel-btn" class="hidden">
                    Cancel
                </button>
                <button id="modal-ok-btn">
                    OK
                </button>
            </div>
        </div>
    </div>

    <div id="privacy-policy-modal-overlay" class="hidden">
        <div id="privacy-policy-modal-content">
            <h3 id="privacy-policy-title">Privacy Policy for Textroll Web Chat</h3>
            <div id="privacy-policy-text">
                <p><strong>1. Data Collection:</strong> We collect your chosen username and a unique user ID generated by Firebase Authentication for the purpose of identifying you within chat rooms. Room codes and messages sent within rooms are stored temporarily on our Firebase Firestore database to facilitate real-time communication. We do NOT collect any personally identifiable information beyond your chosen username and the Firebase-generated user ID.</p>
                <p><strong>2. Data Usage:</strong> Your username and user ID are used solely to display your identity in chat rooms and manage your participation. Room data (including messages) is used to enable chat functionality. We do not use your data for advertising, tracking, or any other commercial purposes.</p>
                <p><strong>3. Data Storage and Deletion:</strong> Chat rooms and their messages are designed to be temporary. Rooms are automatically deleted if they become empty (no participants) or if there is no activity (no messages sent or users joining/leaving) for 15 minutes. Permanent rooms, if enabled by the host and secured with a password, will persist even when empty, but will be deleted after 1 week of inactivity (no messages sent or users joining/leaving).</p>
                <p><strong>4. Security:</strong> We use Firebase Firestore, which provides robust security features. However, please remember that random and unmoderated chat rooms inherently carry risks. Do NOT share sensitive personal information (e.g., real name, address, phone password, financial details) in Textroll chat rooms.</p>
                <p><strong>5. Third-Party Services:</strong> This app uses Firebase (Google) for backend services (authentication, database). Their privacy policies apply to the data they handle. We do not integrate with any other third-party analytics or advertising services.</p>
                <p><strong>6. Changes to this Policy:</strong> We may update this privacy policy from time to time. Any changes will be reflected directly within the app. Your continued use of the app after such changes constitutes your acceptance of the new policy.</p>
                <p><strong>7. Contact:</strong> For any privacy-related questions, please contact us through the platform where you accessed this application.</p>
            </div>
            <div id="privacy-policy-buttons">
                <button id="privacy-policy-close-btn">
                    Close
                </button>
            </div>
        </div>
    </div>


    <div id="home-screen" class="hidden">
        
        <h1>Textroll</h1>
        <p>
            Connect and chat anonymously with friends or strangers!
        </p>
        <div class="dark-mode-toggle-container">
            <button id="dark-mode-toggle">
                <span class="icon-moon-text">üåô</span>
                <span class="icon-sun-text">‚òÄÔ∏è</span>
                </button>
        </div>
        <br><br>

        <div id="mode-selection">
            <button id="default-mode-btn" class="active">Default Mode</button>
            <button id="random-mode-btn">Random Mode</button>
        </div>

        <div id="default-mode-container">
            <div class="input-group">
                <label for="username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="username-input"
                    placeholder="e.g., ChatMaster"
                    maxlength="15"
                />
            </div>

            <div class="input-group" id="create-password-input-group" style="display: none;">
                <label for="create-password-input">
                    Set a room password (optional):
                </label>
                <input
                    type="password"
                    id="create-password-input"
                    placeholder="Leave blank for no password"
                    maxlength="20"
                />
            </div>

            <div class="input-group">
                <label for="max-participants-input">
                    Max Participants (2-10):
                </label>
                <input
                    type="number"
                    id="max-participants-input"
                    value="4"
                    min="2"
                    max="10"
                />
            </div>

            <div class="input-group">
                <label for="room-code-input">
                    Or enter a room code to join:
                </label>
                <input
                    type="text"
                    id="room-code-input"
                    placeholder="e.g., ABCDEF"
                    maxlength="6"
                />
            </div>

            <div class="button-group">
                <button id="create-room-btn">
                    Create New Room
                </button>
                <button id="join-room-btn">
                    Join Room
                </button>
            </div>
        </div>

        <div id="random-mode-container" class="hidden">
            <div class="input-group">
                <label for="random-username-input">
                    Enter your username:
                </label>
                <input
                    type="text"
                    id="random-username-input"
                    placeholder="e.g., AnonymousChatter"
                    maxlength="15"
                />
            </div>
            <div class="button-group">
                <button id="join-random-room-btn">
                    Join Random Room
                </button>
            </div>
        </div>

        <p id="user-id-display"></p>
    </div>

    <div id="chat-room-screen" class="hidden">
        <div class="header">
            <div class="dark-mode-toggle-container">
                <button id="dark-mode-toggle-chat">
                    <span class="icon-moon-text">üåô</span>
                    <span class="icon-sun-text">‚òÄÔ∏è</span>
                </button>
            </div>
            <h2>
                Room: <span id="current-room-code"></span>
                <!-- NEW: Permanent Room Indicator -->
                <span id="permanent-room-indicator" class="hidden">PUBLIC</span>
            </h2>
            <!-- NEW: Toggle Permanent Mode Button -->
            <button id="toggle-permanent-mode-btn" class="hidden">
                Perma
            </button>
            <button id="leave-room-btn">
                Leave
            </button>
        </div>

        <div class="participants-section">
            <h3>Participants (<span id="participants-count">0</span>/<span id="max-participants-display">4</span>):</h3>
            <div id="participants-list">
                </div>
        </div>

        <div id="messages-container" class="custom-scrollbar">
            <p id="no-messages-yet" class="hidden">No messages yet. Start the conversation!</p>
            <div id="messages-end-ref"></div> </div>

        <form id="message-form">
            <input
                type="text"
                id="new-message-input"
                placeholder="Type your message..."
            />
            <button
                type="submit"
                id="send-message-btn"
            >
                Send
            </button>
        </form>
    </div>

    <div id="app-footnote">
        Made by <a id="jdc-link" href="https://altroweb.github.io/justdevcrap">JustDevCrap.</a> With ‚òï. <a id="privacy-policy-link">Privacy Policy</a>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GithubAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc, serverTimestamp, arrayUnion, arrayRemove, runTransaction, query, where, getDocs, orderBy, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA8ErpL72u6bTzPuOx51l4Mb51NDCDBDBY", // Replace with your actual API key if necessary
            authDomain: "textroll-79302.firebaseapp.com",
            projectId: "textroll-79302",
            storageBucket: "textroll-79302.firebaseapp.com",
            messagingSenderId: "928701458132",
            appId: "1:928701458132:web:5eec69352bd35998023d41",
            measurementId: "G-DP3QEKB09S"
        };

        const textrollAppId = firebaseConfig.projectId;
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // DOM Elements
        const loadingScreen = document.getElementById('loading-screen');
        const homeScreen = document.getElementById('home-screen');
        const chatRoomScreen = document.getElementById('chat-room-screen');
        const modeSelection = document.getElementById('mode-selection');
        const defaultModeBtn = document.getElementById('default-mode-btn');
        const randomModeBtn = document.getElementById('random-mode-btn');
        const defaultModeContainer = document.getElementById('default-mode-container');
        const randomModeContainer = document.getElementById('random-mode-container');
        const usernameInput = document.getElementById('username-input');
        const createPasswordInputGroup = document.getElementById('create-password-input-group');
        const createPasswordInput = document.getElementById('create-password-input');
        const maxParticipantsInput = document.getElementById('max-participants-input');
        const roomCodeInput = document.getElementById('room-code-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const randomUsernameInput = document.getElementById('random-username-input');
        const joinRandomRoomBtn = document.getElementById('join-random-room-btn');
        const userIdDisplay = document.getElementById('user-id-display');
        const currentRoomCodeDisplay = document.getElementById('current-room-code');
        const participantsCount = document.getElementById('participants-count');
        const maxParticipantsDisplay = document.getElementById('max-participants-display');
        const participantsList = document.getElementById('participants-list');
        const messagesContainer = document.getElementById('messages-container');
        const noMessagesYet = document.getElementById('no-messages-yet');
        const messagesEndRef = document.getElementById('messages-end-ref');
        const newMessageInput = document.getElementById('new-message-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const messageForm = document.getElementById('message-form');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalPasswordInputGroup = document.getElementById('modal-password-input-group');
        const modalPasswordInput = document.getElementById('modal-password-input');
        const modalPasswordError = document.getElementById('modal-password-error');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const privacyPolicyLink = document.getElementById('privacy-policy-link');
        const privacyPolicyModalOverlay = document.getElementById('privacy-policy-modal-overlay');
        const privacyPolicyModalContent = document.getElementById('privacy-policy-modal-content');
        const privacyPolicyCloseBtn = document.getElementById('privacy-policy-close-btn');
        const darkModeToggleHome = document.getElementById('dark-mode-toggle');
        const darkModeToggleChat = document.getElementById('dark-mode-toggle-chat');
        const iconMoonHome = darkModeToggleHome.querySelector('.icon-moon-text');
        const iconSunHome = darkModeToggleHome.querySelector('.icon-sun-text');
        const iconMoonChat = darkModeToggleChat.querySelector('.icon-moon-text');
        const iconSunChat = darkModeToggleChat.querySelector('.icon-sun-text');

        // NEW DOM Elements for permanent room feature
        const permanentRoomIndicator = document.getElementById('permanent-room-indicator');
        const togglePermanentModeBtn = document.getElementById('toggle-permanent-mode-btn');


        // Application State
        let currentUserId = null;
        let currentRoom = null; // Will store { code, users, maxParticipants, password, hostId, isPermanent, permanentLastActivity }
        let unsubscribeRoomListener = null;
        let unsubscribeMessagesListener = null;
        let currentMode = 'default';
        let inactivityTimer = null;
        const INACTIVITY_TIMEOUT_MS = 15 * 60 * 1000; // 15 minutes
        const PERMANENT_INACTIVITY_TIMEOUT_MS = 7 * 24 * 60 * 60 * 1000; // 1 week in milliseconds
        let currentUserObject = null; // Stores { userId, username, joinTimestamp }

        // Utility to generate room code
        const generateRoomCode = () => {
            let result = '';
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            for (let i = 0; i < 6; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        };

        // Modal display functions
        const showModal = (title, message, onConfirmCallback, showCancel = false, onCancelCallback = () => hideModal(), showPasswordInput = false) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.toggle('hidden', !showCancel);
            modalPasswordInputGroup.classList.add('hidden');
            modalPasswordError.classList.add('hidden');
            if (showPasswordInput) {
                modalPasswordInputGroup.classList.remove('hidden');
            }
            modalPasswordInput.value = '';
            modalOkBtn.onclick = async () => { await onConfirmCallback(); };
            modalCancelBtn.onclick = () => { onCancelCallback(); hideModal(); };
            modalOverlay.classList.remove('hidden');
            setTimeout(() => modalContent.classList.add('show'), 10);
        };
        const hideModal = () => {
            modalContent.classList.remove('show');
            setTimeout(() => {
                modalOverlay.classList.add('hidden');
                modalPasswordInputGroup.classList.add('hidden');
                modalPasswordError.classList.add('hidden');
            }, 300);
        };
        const showPrivacyPolicyModal = () => {
            privacyPolicyModalOverlay.classList.remove('hidden');
            setTimeout(() => privacyPolicyModalContent.classList.add('show'), 10);
        };
        const hidePrivacyPolicyModal = () => {
            privacyPolicyModalContent.classList.remove('show');
            setTimeout(() => privacyPolicyModalOverlay.classList.add('hidden'), 300);
        };

        // UI Update Logic
        const updateUI = () => {
            loadingScreen.classList.add('hidden');
            if (currentRoom) {
                homeScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('hidden');
                chatRoomScreen.classList.add('animate-scaleIn');
                homeScreen.classList.remove('animate-scaleIn');
                currentRoomCodeDisplay.textContent = currentRoom.code;
                renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                maxParticipantsDisplay.textContent = currentRoom.maxParticipants || 4;
                const isCurrentUserInRoom = currentRoom.users.some(u => u.userId === currentUserId);
                newMessageInput.disabled = !isCurrentUserInRoom;
                sendMessageBtn.disabled = !isCurrentUserInRoom;
                updatePermanentModeUI(); // NEW: Update permanent mode UI
            } else {
                homeScreen.classList.remove('hidden');
                homeScreen.classList.add('animate-scaleIn');
                chatRoomScreen.classList.add('hidden');
                chatRoomScreen.classList.remove('animate-scaleIn');
                updateModeUI(currentMode);
            }
        };

        // NEW: Function to update the permanent mode button and indicator UI
        const updatePermanentModeUI = () => {
            if (!currentRoom) {
                togglePermanentModeBtn.classList.add('hidden');
                permanentRoomIndicator.classList.add('hidden');
                return;
            }
            const isHost = currentUserId === currentRoom.hostId;
            const isPermanent = currentRoom.isPermanent;
            // const hasPassword = currentRoom.password; // Removed password check for permanent mode

            togglePermanentModeBtn.classList.toggle('hidden', !isHost); // Only host sees the button
            // Shortened text for the button
            togglePermanentModeBtn.textContent = isPermanent ? 'Temp' : 'Perma';
            // Always enable the button for the host, regardless of password
            togglePermanentModeBtn.disabled = false; 

            permanentRoomIndicator.classList.toggle('hidden', !isPermanent); // Show indicator if permanent
        };

        // Render participants with remove button for host
        const renderParticipants = (users, hostId) => {
            participantsList.innerHTML = '';
            participantsCount.textContent = users.length;
            const isHost = currentUserId === hostId;

            users.forEach(user => {
                const participantSpan = document.createElement('span');
                participantSpan.className = `${user.userId === currentUserId ? 'bg-indigo-100' : 'bg-gray-100'}`;
                
                const usernameText = document.createTextNode(`${user.username} ${user.userId === currentUserId ? '(You)' : ''} ${user.userId === hostId ? '(Host)' : ''}`);
                participantSpan.appendChild(usernameText);

                if (isHost && user.userId !== currentUserId) { // Host can remove others
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-participant-btn';
                    removeBtn.textContent = '‚úï'; // Using a multiplication X, or use an SVG/icon font
                    removeBtn.title = `Remove ${user.username}`;
                    removeBtn.onclick = () => handleRemoveParticipant(user);
                    participantSpan.appendChild(removeBtn);
                }
                participantsList.appendChild(participantSpan);
            });
        };
        
        // Function for host to remove a participant
        const handleRemoveParticipant = (userToRemove) => {
            if (!currentRoom || currentUserId !== currentRoom.hostId) {
                showModal("Error", "Only the host can remove participants.", () => hideModal());
                return;
            }
            showModal(
                "Remove Participant", 
                `Are you sure you want to remove ${userToRemove.username} from the room?`,
                async () => {
                    const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                    try {
                        await runTransaction(db, async (transaction) => {
                            const roomDoc = await transaction.get(roomRef);
                            if (!roomDoc.exists()) {
                                throw new Error("Room does not exist.");
                            }
                            const roomData = roomDoc.data();
                            const usersInRoom = roomData.users || [];
                            
                            // Find the exact user object in Firestore to remove
                            const userObjectInFirestore = usersInRoom.find(u => u.userId === userToRemove.userId);

                            if (userObjectInFirestore) {
                                const updateFields = { users: arrayRemove(userObjectInFirestore), lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) { // NEW: Update permanentLastActivity if permanent
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                transaction.update(roomRef, updateFields);
                            } else {
                                console.warn(`User ${userToRemove.username} not found in Firestore for removal.`);
                            }
                        });
                        // The onSnapshot listener will update the UI.
                        // If the removed user is the current client, they will be kicked out by onSnapshot logic.
                        hideModal(); // Hide confirmation modal
                    } catch (error) {
                        console.error("Error removing participant:", error);
                        showModal("Removal Failed", `Failed to remove ${userToRemove.username}. Please try again.`, () => hideModal());
                    }
                },
                true // Show cancel button
            );
        };


        // Render messages (filtered by joinTimestamp)
        const renderMessages = (messages) => {
            messagesContainer.innerHTML = '';
            const currentUserJoinTimestamp = currentRoom?.users?.find(u => u.userId === currentUserId)?.joinTimestamp;
            const currentUserJoinTime = currentUserJoinTimestamp instanceof Date ? currentUserJoinTimestamp.getTime() : (currentUserJoinTimestamp?.toDate ? currentUserJoinTimestamp.toDate().getTime() : 0);

            const filteredMessages = messages.filter(msg => {
                if (!currentUserJoinTime || !msg.timestamp) return true;
                const messageTime = msg.timestamp instanceof Date ? msg.timestamp.getTime() : (msg.timestamp.toDate ? msg.timestamp.toDate().getTime() : 0);
                return messageTime >= currentUserJoinTime;
            });

            if (filteredMessages.length === 0) {
                noMessagesYet.classList.remove('hidden');
            } else {
                noMessagesYet.classList.add('hidden');
                filteredMessages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message-item ${msg.senderId === currentUserId ? 'justify-end' : 'justify-start'}`;
                    const contentDiv = document.createElement('div');
                    contentDiv.className = "message-content";
                    const senderSpan = document.createElement('div');
                    senderSpan.className = "sender-info";
                    senderSpan.textContent = msg.senderId === currentUserId ? 'You' : msg.senderUsername;
                    const textP = document.createElement('p');
                    textP.textContent = msg.text;
                    const timestampDiv = document.createElement('div');
                    timestampDiv.className = "timestamp";
                    const date = msg.timestamp ? (msg.timestamp instanceof Date ? msg.timestamp : msg.timestamp.toDate()) : null;
                    timestampDiv.textContent = date ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                    contentDiv.appendChild(senderSpan);
                    contentDiv.appendChild(textP);
                    contentDiv.appendChild(timestampDiv);
                    messageDiv.appendChild(contentDiv);
                    messagesContainer.appendChild(messageDiv);
                });
            }
            messagesContainer.appendChild(messagesEndRef);
            messagesEndRef.scrollIntoView({ behavior: 'smooth' });
        };

        // Firebase Auth
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = `Your User ID: ${currentUserId}`;
            } else {
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Error signing in:", error);
                    showModal("Authentication Error", "Could not sign in. Please try again.", () => hideModal());
                }
            }
            updateUI();
        });

        // Create Room
        const createRoom = async (username, password = null, maxParticipants = 4) => {
            let newRoomCode = generateRoomCode();
            // Check if room code already exists (unlikely but possible)
            let roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, newRoomCode);
            let roomDoc = await getDoc(roomRef);
            while (roomDoc.exists()) {
                newRoomCode = generateRoomCode();
                roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, newRoomCode);
                roomDoc = await getDoc(roomRef);
            }

            const user = { userId: currentUserId, username: username, joinTimestamp: new Date() };
            const roomData = {
                code: newRoomCode,
                users: [user],
                hostId: currentUserId, // Set hostId on creation
                createdAt: serverTimestamp(),
                lastActivity: serverTimestamp(),
                maxParticipants: maxParticipants,
                isPermanent: false, // NEW: Default to not permanent
                permanentLastActivity: null // NEW: No permanent activity yet
            };
            if (password) roomData.password = password;

            try {
                await setDoc(roomRef, roomData);
                currentUserObject = user;
                window.addEventListener('beforeunload', handlePageExit);
                // Return the full room data including hostId, isPermanent, permanentLastActivity
                return { ...roomData, users: [user], isPermanent: false, permanentLastActivity: null }; 
            } catch (error) {
                console.error("Error creating room:", error);
                showModal("Creation Failed", "Failed to create room. Please try again.", () => hideModal());
                return null;
            }
        };

        createRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const password = createPasswordInput.value.trim();
            const maxParticipants = parseInt(maxParticipantsInput.value, 10);
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => hideModal());
                return;
            }
            if (isNaN(maxParticipants) || maxParticipants < 2 || maxParticipants > 10) {
                showModal("Invalid Max Participants", "Please set max participants between 2 and 10.", () => hideModal());
                return;
            }
            const room = await createRoom(username, password || null, maxParticipants);
            if (room) {
                currentRoom = room; // currentRoom now includes hostId, isPermanent, permanentLastActivity
                roomCodeInput.value = room.code;
                createPasswordInput.value = '';
                await setupRoomListeners(room.code);
                updateUI();
            }
        });

        // Join Room Transaction
        const performJoinRoomTransaction = async (roomRef, roomCode, username, roomMaxParticipants, roomPassword = null, hostId = null, isPermanent = false, permanentLastActivity = null) => {
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw new Error("Room no longer exists");
                    const roomData = roomDoc.data();
                    let usersInRoom = roomData.users || [];
                    const maxAllowedUsers = roomData.maxParticipants || roomMaxParticipants || 4;
                    let existingUserIndex = usersInRoom.findIndex(u => u.userId === currentUserId);

                    if (existingUserIndex !== -1) {
                        usersInRoom[existingUserIndex].joinTimestamp = new Date();
                        usersInRoom[existingUserIndex].username = username;
                    } else {
                        if (usersInRoom.length >= maxAllowedUsers) throw new Error("Room full (re-check)");
                        if (usersInRoom.some(u => u.username.toLowerCase() === username.toLowerCase())) throw new Error("Username taken (re-check)");
                        const newUser = { userId: currentUserId, username: username, joinTimestamp: new Date() };
                        usersInRoom.push(newUser);
                    }
                    
                    const updateFields = { users: usersInRoom, lastActivity: serverTimestamp() };
                    if (roomData.isPermanent) { // NEW: Update permanentLastActivity if permanent
                        updateFields.permanentLastActivity = serverTimestamp();
                    }
                    transaction.update(roomRef, updateFields);

                    // Ensure currentRoom is set with all necessary fields including hostId from roomData
                    currentRoom = { 
                        code: roomCode, 
                        users: usersInRoom, 
                        maxParticipants: maxAllowedUsers, 
                        password: roomPassword,
                        hostId: roomData.hostId || hostId, // Prefer hostId from roomData, fallback if needed
                        isPermanent: roomData.isPermanent || isPermanent, // NEW
                        permanentLastActivity: roomData.permanentLastActivity || permanentLastActivity // NEW
                    };
                });
                currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                if (currentUserObject) window.addEventListener('beforeunload', handlePageExit);
                else console.error("Could not find current user object after join transaction.");
                await setupRoomListeners(roomCode);
                updateUI();
                hideModal();
            } catch (error) {
                console.error("Error joining room (transaction):", error);
                let errorMessage = "Failed to join room. Please try again.";
                if (error.message.includes("Room full")) errorMessage = "Room is now full.";
                if (error.message.includes("Username taken")) errorMessage = "Username was taken.";
                if (error.message.includes("Room no longer exists")) errorMessage = "The room no longer exists.";
                showModal("Join Failed", errorMessage, () => hideModal());
            }
        };

        joinRoomBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const roomCode = roomCodeInput.value.trim().toUpperCase();
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => hideModal());
                return;
            }
            if (!roomCode) {
                showModal("Invalid Room Code", "Please enter a room code.", () => hideModal());
                return;
            }

            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);
            try {
                const roomDoc = await getDoc(roomRef);
                if (!roomDoc.exists()) {
                    showModal("Room Not Found", "Room code does not exist.", () => hideModal());
                    return;
                }
                const roomData = roomDoc.data();
                const currentUsers = roomData.users || [];
                const maxAllowedUsers = roomData.maxParticipants || 4;
                
                // Check if username is taken (case-insensitive)
                const isUsernameTaken = currentUsers.some(u => u.username.toLowerCase() === username.toLowerCase() && u.userId !== currentUserId);
                if (isUsernameTaken) {
                    showModal("Username Taken", "This username is already taken in this room. Please choose another.", () => hideModal());
                    return;
                }

                // Check if room is full
                if (currentUsers.length >= maxAllowedUsers && !currentUsers.some(u => u.userId === currentUserId)) {
                    showModal("Room Full", "This room is full.", () => hideModal());
                    return;
                }

                if (roomData.password) {
                     showModal("Enter Password", "This room is password protected.", async () => {
                        const enteredPassword = modalPasswordInput.value.trim();
                        if (enteredPassword === roomData.password) {
                            modalPasswordError.classList.add('hidden');
                            // Pass all relevant roomData fields including isPermanent and permanentLastActivity
                            await performJoinRoomTransaction(roomRef, roomCode, username, maxAllowedUsers, roomData.password, roomData.hostId, roomData.isPermanent, roomData.permanentLastActivity);
                        } else {
                            modalPasswordError.textContent = "Incorrect password.";
                            modalPasswordError.classList.remove('hidden');
                            modalPasswordInput.value = '';
                        }
                    }, true, () => {}, true);
                } else {
                    // Pass all relevant roomData fields including isPermanent and permanentLastActivity
                    await performJoinRoomTransaction(roomRef, roomCode, username, maxAllowedUsers, null, roomData.hostId, roomData.isPermanent, roomData.permanentLastActivity);
                }
            } catch (error) {
                console.error("Error joining room (initial check):", error);
                showModal("Join Failed", "Failed to join room. Check code and try again.", () => hideModal());
            }
        });

        // Join Random Room
        joinRandomRoomBtn.addEventListener('click', async () => {
            const username = randomUsernameInput.value.trim();
            if (!username) {
                showModal("Invalid Username", "Please enter a username.", () => { hideModal(); }); 
                return;
            }
            const randomWarningShown = localStorage.getItem('randomWarningShown');
            if (!randomWarningShown) {
                showModal("Anonymous Chat Warning", "You are about to join a random, unmoderated, and temporary chat room. Do not share personal information.", async () => {
                    localStorage.setItem('randomWarningShown', 'true'); 
                    await findRandomRoom(username);
                }, true, () => {});
            } else {
                await findRandomRoom(username);
            }
        });

        const findRandomRoom = async (username) => {
            const roomsCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms`);
            try {
                // Query for rooms that are not permanent and have users
                const q = query(roomsCollectionRef, where('isPermanent', '==', false)); // NEW: Only consider non-permanent rooms for random join
                const querySnapshot = await getDocs(q);
                let availableRooms = [];
                querySnapshot.forEach(docSnap => {
                    const roomData = docSnap.data();
                    const maxAllowedUsers = roomData.maxParticipants || 4;
                    // Ensure room has users, is not full, and has no password for random join
                    if (roomData.users && roomData.users.length > 0 && roomData.users.length < maxAllowedUsers && !roomData.password) {
                        const isUsernameTaken = roomData.users.some(u => u.username.toLowerCase() === username.toLowerCase() && u.userId !== currentUserId);
                        if (!isUsernameTaken) {
                             // Include hostId, isPermanent, permanentLastActivity when pushing to availableRooms
                            availableRooms.push({...roomData, code: docSnap.id, hostId: roomData.hostId, isPermanent: roomData.isPermanent, permanentLastActivity: roomData.permanentLastActivity });
                        }
                    }
                });
                if (availableRooms.length > 0) {
                    const randomIndex = Math.floor(Math.random() * availableRooms.length);
                    const roomToJoin = availableRooms[randomIndex];
                    const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomToJoin.code);
                    // Pass all relevant roomData fields including isPermanent and permanentLastActivity
                    await performJoinRoomTransaction(roomRef, roomToJoin.code, username, roomToJoin.maxParticipants, null, roomToJoin.hostId, roomToJoin.isPermanent, roomToJoin.permanentLastActivity);
                } else {
                    showModal("No Random Rooms", "No random rooms available. Try creating one!", () => hideModal());
                }
            } catch (error) {
                console.error("Error finding random room:", error);
                showModal("Error", "Failed to find a random room.", () => hideModal());
            }
        };
        
        // Room Inactivity Check
        const checkInactivity = async (roomDocRef) => {
            try {
                const roomDoc = await getDoc(roomDocRef);
                if (!roomDoc.exists()) {
                    console.log("Room no longer exists, skipping inactivity check.");
                    return;
                }
                const roomData = roomDoc.data();
                const currentTime = Date.now();

                let shouldDelete = false;
                let reason = "";
                let activityTimestamp = null;
                let timeoutDuration = 0;

                if (roomData.isPermanent) {
                    activityTimestamp = roomData.permanentLastActivity ?
                        (roomData.permanentLastActivity.toDate ? roomData.permanentLastActivity.toDate() : roomData.permanentLastActivity) :
                        (roomData.createdAt.toDate ? roomData.createdAt.toDate() : roomData.createdAt); // Fallback to createdAt if permanentLastActivity is missing
                    timeoutDuration = PERMANENT_INACTIVITY_TIMEOUT_MS;
                    reason = "due to 1 week inactivity (permanent room)";
                } else {
                    activityTimestamp = roomData.lastActivity ?
                        (roomData.lastActivity.toDate ? roomData.lastActivity.toDate() : roomData.lastActivity) :
                        (roomData.createdAt.toDate ? roomData.createdAt.toDate() : roomData.createdAt); // Fallback to createdAt if lastActivity is missing
                    timeoutDuration = INACTIVITY_TIMEOUT_MS;
                    reason = "due to 15 minute inactivity (empty temporary room)";
                }

                if (!(activityTimestamp instanceof Date)) {
                    console.warn("Activity timestamp is not a valid Date object:", activityTimestamp);
                    return;
                }
                const lastActivityTime = activityTimestamp.getTime();

                // For temporary rooms, only delete if empty AND inactive.
                // For permanent rooms, delete if inactive, regardless of users (as they persist when empty).
                if (roomData.isPermanent) {
                    if (currentTime - lastActivityTime >= timeoutDuration) {
                        shouldDelete = true;
                    }
                } else {
                    if ((roomData.users && roomData.users.length === 0) && (currentTime - lastActivityTime >= timeoutDuration)) {
                        shouldDelete = true;
                    }
                }

                if (shouldDelete) {
                    if (inactivityTimer) {
                        clearInterval(inactivityTimer);
                        inactivityTimer = null;
                    }
                    showModal("Room Timed Out", `This room was deleted ${reason}.`, async () => {
                        const roomCodeToDelete = roomDoc.id;
                        handleLeaveRoomCleanUp();
                        hideModal();
                        if (roomCodeToDelete) {
                            try {
                                // Delete messages subcollection first
                                const messagesQuerySnapshot = await getDocs(collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomCodeToDelete}/messages`));
                                messagesQuerySnapshot.docs.forEach(async (msgDoc) => {
                                    await deleteDoc(msgDoc.ref);
                                });
                                await deleteDoc(doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCodeToDelete));
                                console.log(`Room ${roomCodeToDelete} deleted ${reason}.`);
                            } catch (e) {
                                console.warn(`Could not delete timed out room ${roomCodeToDelete}:`, e);
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Error in checkInactivity:", error);
            }
        };

        // Setup Room Listeners
        const setupRoomListeners = async (roomCode) => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) clearInterval(inactivityTimer);

            const roomDocRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, roomCode);
            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${roomCode}/messages`);

            try {
                const roomDoc = await getDoc(roomDocRef);
                if (roomDoc.exists()) {
                    const roomData = roomDoc.data();
                    currentRoom = { // Ensure all fields, including hostId, isPermanent, permanentLastActivity, are set
                        code: roomCode,
                        users: roomData.users || [],
                        maxParticipants: roomData.maxParticipants || 4,
                        lastActivity: roomData.lastActivity,
                        password: roomData.password || null,
                        hostId: roomData.hostId,
                        isPermanent: roomData.isPermanent || false, // NEW
                        permanentLastActivity: roomData.permanentLastActivity || null // NEW
                    };
                    currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                    renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants;
                    updatePermanentModeUI(); // NEW: Initial UI update for permanent mode
                } else { 
                    showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal();
                    });
                    return;
                }
            } catch (error) { 
                 console.error("Error fetching initial room data:", error);
                showModal("Connection Error", "Failed to get initial room data.", () => { hideModal(); });
                return;
            }
            // Initial messages fetch
            try {
                const initialMessagesQuery = query(messagesCollectionRef, orderBy('timestamp', 'asc'));
                const initialMessagesSnapshot = await getDocs(initialMessagesQuery);
                const initialMessages = initialMessagesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderMessages(initialMessages);
            } catch (error) {
                console.error("Error fetching initial messages:", error);
                showModal("Connection Error", "Failed to get initial messages.", () => { hideModal(); });
                return; 
            }


            unsubscribeRoomListener = onSnapshot(roomDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const roomData = docSnap.data();
                    // Check if current user is still in the room's user list
                    const amIStillInRoom = roomData.users && roomData.users.some(u => u.userId === currentUserId);

                    if (!amIStillInRoom && currentRoom) { // If current user was removed or left
                        showModal("Removed from Room", "You have been removed from the room or the room has changed.", () => {
                            handleLeaveRoomCleanUp();
                            hideModal();
                        });
                        return; // Stop further processing for this client in this room
                    }

                    currentRoom = {
                        ...currentRoom, // Preserve existing properties like password
                        users: roomData.users || [],
                        maxParticipants: roomData.maxParticipants || 4,
                        lastActivity: roomData.lastActivity,
                        hostId: roomData.hostId, // Update hostId from snapshot
                        isPermanent: roomData.isPermanent || false, // NEW
                        permanentLastActivity: roomData.permanentLastActivity || null // NEW
                    };
                    currentUserObject = currentRoom.users.find(u => u.userId === currentUserId);
                    renderParticipants(currentRoom.users, currentRoom.hostId); // Pass hostId
                    maxParticipantsDisplay.textContent = currentRoom.maxParticipants;
                    updatePermanentModeUI(); // NEW: Update permanent mode UI on snapshot
                    
                    // Reset and restart inactivity timer
                    if (inactivityTimer) clearInterval(inactivityTimer);
                    inactivityTimer = setInterval(() => checkInactivity(roomDocRef), 60 * 1000); // Check every minute
                    checkInactivity(roomDocRef); // Run immediately on snapshot update
                } else { 
                     showModal("Room Ended", "The room you were in has ended.", () => {
                        handleLeaveRoomCleanUp();
                        hideModal();
                    });
                }
            }, (error) => { 
                console.error("Error listening to room:", error);
                showModal("Connection Error", "Failed to get room updates.", () => { hideModal(); });
            });
            
            unsubscribeMessagesListener = onSnapshot(query(messagesCollectionRef, orderBy('timestamp', 'asc')), (snapshot) => {
                const newMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderMessages(newMessages); 
                if (currentRoom && currentRoom.code) {
                    const roomRefToUpdate = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                    const updateFields = { lastActivity: serverTimestamp() };
                    if (currentRoom.isPermanent) { // NEW: Update permanentLastActivity if permanent
                        updateFields.permanentLastActivity = serverTimestamp();
                    }
                    updateDoc(roomRefToUpdate, updateFields).catch(e => console.error("Error updating last activity on message receive:", e));
                }
            }, (error) => {
                console.error("Error listening to messages:", error);
                showModal("Connection Error", "Failed to get message updates.", () => { hideModal(); });
            });
        };

        // Send Message
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newMessageText = newMessageInput.value.trim();
            if (!newMessageText) return;
            if (!currentRoom || !currentUserId || !currentUserObject) {
                 console.warn("Cannot send message: currentRoom, currentUserId, or currentUserObject is not set.");
                 return;
            }
            const messagesCollectionRef = collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.code}/messages`);
            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code); 
            try {
                await addDoc(messagesCollectionRef, {
                    senderId: currentUserId,
                    senderUsername: currentUserObject.username,
                    type: 'text', 
                    timestamp: serverTimestamp(),
                    text: newMessageText,
                });
                const updateFields = { lastActivity: serverTimestamp() };
                if (currentRoom.isPermanent) { // NEW: Update permanentLastActivity if permanent
                    updateFields.permanentLastActivity = serverTimestamp();
                }
                await updateDoc(roomRef, updateFields);
                newMessageInput.value = ''; 
            } catch (error) {
                console.error("Error sending message:", error);
                showModal("Message Failed", "Failed to send message.", () => { hideModal(); }); 
            }
        });

        // Leave Room Button
        leaveRoomBtn.addEventListener('click', () => {
            showModal("Leave Room", "Are you sure you want to leave this room?", async () => {
                if (!currentRoom || !currentUserId || !currentUserObject) {
                    console.warn("Cannot leave room: state not properly set.");
                    hideModal();
                    return;
                }
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) {
                            console.warn("Room already gone when attempting to leave.");
                            return; // Room already gone, just clean up locally
                        }
                        const roomData = roomDoc.data();
                        const currentUsers = roomData.users || [];
                        const userObjectToRemoveFromFirestore = currentUsers.find(u => u.userId === currentUserId);

                        if (userObjectToRemoveFromFirestore) { 
                            const updatedUsers = currentUsers.filter(u => u.userId !== currentUserId);

                            if (currentUserId === roomData.hostId) { // Current user is the host
                                if (roomData.isPermanent) {
                                    // NEW: Host leaving a permanent room: just remove host from users, room persists
                                    transaction.update(roomRef, {
                                        users: arrayRemove(userObjectToRemoveFromFirestore),
                                        lastActivity: serverTimestamp(),
                                        permanentLastActivity: serverTimestamp() // NEW: Update permanent activity
                                    });
                                } else {
                                    // NEW: Host leaving a non-permanent room: delete the room immediately regardless of other participants
                                    // Delete all messages in the subcollection first
                                    const messagesQuerySnapshot = await getDocs(collection(db, `artifacts/${textrollAppId}/public/data/rooms/${currentRoom.code}/messages`));
                                    messagesQuerySnapshot.docs.forEach(msgDoc => {
                                        transaction.delete(msgDoc.ref);
                                    });
                                    transaction.delete(roomRef);
                                }
                            } else { // Current user is a participant (not host)
                                const updateFields = { users: arrayRemove(userObjectToRemoveFromFirestore), lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) { // NEW: Update permanentLastActivity if permanent
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                transaction.update(roomRef, updateFields);
                                // If this was the last participant in a non-permanent room, the 15-min inactivity timer will delete it.
                            }
                        } else {
                            console.warn("Attempted to leave room, user not found in Firestore. Cleaning up locally.");
                        }
                    });
                    handleLeaveRoomCleanUp(); 
                    hideModal(); 
                }
                catch (error) {
                    console.error("Error leaving room:", error);
                    showModal("Leave Failed", "Could not leave room.", () => { 
                        handleLeaveRoomCleanUp(); 
                        hideModal(); 
                    }); 
                }
            }, true); 
        });
        
        // Local Cleanup
        const handleLeaveRoomCleanUp = () => {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeMessagesListener) unsubscribeMessagesListener();
            if (inactivityTimer) clearInterval(inactivityTimer);
            window.removeEventListener('beforeunload', handlePageExit);
            currentUserObject = null; 
            currentRoom = null;
            roomCodeInput.value = '';
            newMessageInput.value = '';
            messagesContainer.innerHTML = ''; 
            noMessagesYet.classList.remove('hidden'); 
            updateUI();
        };

        // Page Exit (Best Effort)
        const handlePageExit = () => {
             if (currentRoom && currentUserId && currentUserObject) {
                const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
                try {
                    getDoc(roomRef).then(roomDoc => {
                        if (roomDoc.exists()) {
                            const roomData = roomDoc.data();
                            const usersInFirestore = roomData.users || [];
                            const userToRemove = usersInFirestore.find(u => u.userId === currentUserId && u.username === currentUserObject.username);
                            if (userToRemove) {
                                // Only remove the user. Let the onSnapshot and inactivity checks handle room deletion.
                                const updateFields = { lastActivity: serverTimestamp() };
                                if (roomData.isPermanent) { // NEW: Update permanentLastActivity if permanent
                                    updateFields.permanentLastActivity = serverTimestamp();
                                }
                                updateDoc(roomRef, {
                                    users: arrayRemove(userToRemove), 
                                    ...updateFields
                                }).catch(e => console.warn("Best-effort: Failed to remove user on exit (updateDoc):", e));
                            }
                        }
                    }).catch(e => console.warn("Best-effort: Error fetching room doc on exit:", e));
                } catch (e) {
                    console.warn("Best-effort: Error in handlePageExit:", e);
                }
            }
        };

        // NEW: Event listener for the "Toggle Permanent Mode" button
        togglePermanentModeBtn.addEventListener('click', async () => {
            if (!currentRoom || currentUserId !== currentRoom.hostId) {
                showModal("Permission Denied", "Only the host can toggle permanent mode.", () => hideModal());
                return;
            }
            // Removed: if (!currentRoom.password) check

            const roomRef = doc(db, `artifacts/${textrollAppId}/public/data/rooms`, currentRoom.code);
            const newPermanentState = !currentRoom.isPermanent; // Toggle the state

            showModal(
                "Toggle Permanent Room",
                `Are you sure you want to ${newPermanentState ? 'make this room permanent' : 'make this room temporary'}?`,
                async () => {
                    try {
                        const updateFields = {
                            isPermanent: newPermanentState,
                            lastActivity: serverTimestamp() // Also update general activity
                        };
                        if (newPermanentState) {
                            updateFields.permanentLastActivity = serverTimestamp(); // Set timestamp when made permanent
                        } else {
                            updateFields.permanentLastActivity = null; // Clear timestamp when made temporary
                        }
                        await updateDoc(roomRef, updateFields);
                        
                        // Update local state immediately for responsive UI
                        currentRoom.isPermanent = newPermanentState; 
                        currentRoom.permanentLastActivity = newPermanentState ? new Date() : null; 

                        updatePermanentModeUI(); // Update UI based on new state
                        hideModal();
                    } catch (error) {
                        console.error("Error toggling permanent mode:", error);
                        showModal("Error", "Failed to toggle permanent mode. Please try again.", () => hideModal());
                    }
                },
                true // Show cancel button
            );
        });


        // Dark Mode & UI Mode Switching
        const applyDarkMode = (isDarkMode) => {
            document.body.classList.toggle('dark-mode', isDarkMode);
            iconMoonHome.classList.toggle('hidden', isDarkMode);
            iconSunHome.classList.toggle('hidden', !isDarkMode);
            iconMoonChat.classList.toggle('hidden', isDarkMode);
            iconSunChat.classList.toggle('hidden', !isDarkMode);
        };
        darkModeToggleHome.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });
        darkModeToggleChat.addEventListener('click', () => {
            const isDarkMode = !document.body.classList.contains('dark-mode');
            applyDarkMode(isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
        });
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') applyDarkMode(true); else applyDarkMode(false);

        const updateModeUI = (mode) => {
            currentMode = mode;
            if (mode === 'default') {
                defaultModeBtn.classList.add('active');
                randomModeBtn.classList.remove('active');
                defaultModeContainer.classList.remove('hidden');
                randomModeContainer.classList.add('hidden');
                randomUsernameInput.value = '';
            } else { 
                randomModeBtn.classList.add('active');
                defaultModeBtn.classList.remove('active');
                randomModeContainer.classList.remove('hidden');
                defaultModeContainer.classList.add('hidden');
                usernameInput.value = '';
                createPasswordInput.value = '';
                roomCodeInput.value = '';
                createPasswordInputGroup.style.display = 'none'; 
                maxParticipantsInput.value = '4'; 
            }
        };
        defaultModeBtn.addEventListener('click', () => updateModeUI('default'));
        randomModeBtn.addEventListener('click', () => updateModeUI('random'));
        usernameInput.addEventListener('input', () => {
            if (usernameInput.value.trim() !== '') createPasswordInputGroup.style.display = 'block';
            else {
                createPasswordInputGroup.style.display = 'none';
                createPasswordInput.value = ''; 
            }
        });

        // Privacy Policy & DOMContentLoaded
        privacyPolicyLink.addEventListener('click', showPrivacyPolicyModal);
        privacyPolicyCloseBtn.addEventListener('click', hidePrivacyPolicyModal);
        document.addEventListener('DOMContentLoaded', () => {
            homeScreen.classList.add('hidden');
            chatRoomScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            updateModeUI('default');
            if (usernameInput.value.trim() !== '') createPasswordInputGroup.style.display = 'block';
        });

    </script>
</body>
</html>
