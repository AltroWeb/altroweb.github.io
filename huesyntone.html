<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HueSyntone</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
            user-select: none; /* Prevent text selection during drag attempts */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and Edge */
        }

        h1 {
            color: #333;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
            justify-content: center;
            align-items: center;
            gap: 20px; /* Space between flex items */
            width: 90%;
            max-width: 800px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control fieldset {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
        }

        .speed-control legend {
            padding: 0 5px;
            font-weight: bold;
        }

         .speed-control .radio-group {
             display: flex;
             gap: 15px; /* Space between radio buttons */
             align-items: center;
         }

         .speed-control label {
             cursor: pointer;
         }


        .color-palette {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); /* Responsive grid */
            grid-template-rows: repeat(2, 50px);
            gap: 10px;
            margin-bottom: 30px;
            width: 90%;
            max-width: 800px;
        }

        .color-box {
            width: 100%; /* Make boxes fill grid space */
            height: 50px;
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            transition: transform 0.1s ease-in-out;
            touch-action: manipulation; /* Improve mobile interaction */
            box-sizing: border-box; /* Include padding/border in element's total width and height */
        }

        .color-box:active {
            transform: scale(0.95);
        }

        /* Example Colors (you can customize these) */
        /* Add data-hex attributes here matching the CSS background-color */
        .color-box:nth-child(1) { background-color: #FF0000; } /* Red */
        .color-box:nth-child(2) { background-color: #FF4500; } /* OrangeRed */
        .color-box:nth-child(3) { background-color: #FFA500; } /* Orange */
        .color-box:nth-child(4) { background-color: #FFD700; } /* Gold */
        .color-box:nth-child(5) { background-color: #FFFF00; } /* Yellow */
        .color-box:nth-child(6) { background-color: #ADFF2F; } /* GreenYellow */
        .color-box:nth-child(7) { background-color: #00FF00; } /* Lime */
        .color-box:nth-child(8) { background-color: #008000; } /* Green */
        .color-box:nth-child(9) { background-color: #00FFFF; } /* Cyan */
        .color-box:nth-child(10) { background-color: #0000FF; } /* Blue */
        .color-box:nth-child(11) { background-color: #8A2BE2; } /* BlueViolet */
        .color-box:nth-child(12) { background-color: #9400D3; } /* DarkViolet */
        .color-box:nth-child(13) { background-color: #EE82EE; } /* Violet */
        .color-box:nth-child(14) { background-color: #FF00FF; } /* Magenta */
        .color-box:nth-child(15) { background-color: #FF1493; } /* DeepPink */
        .color-box:nth-child(16) { background-color: #FFC0CB; } /* Pink */


        .sequence-display {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #fff;
            min-height: 50px;
            width: 90%;
            max-width: 800px;
            white-space: pre-wrap; /* Preserve whitespace and wrap */
            word-wrap: break-word; /* Break long words */
            font-family: monospace;
            font-size: 14px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

         .playback-controls, .file-controls {
            display: flex;
             flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
             width: 90%;
            max-width: 800px;
        }

        button {
             padding: 10px 15px; /* Slightly smaller padding for more buttons */
             font-size: 15px; /* Slightly smaller font */
             cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

         .progress-bar-container {
            width: 90%;
            max-width: 800px;
            height: 10px;
            background-color: #eee;
            margin-bottom: 10px;
            position: relative;
            border: 1px solid #ccc; /* Add border for visibility */
            box-sizing: border-box;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50; /* Green */
            position: absolute;
            top: 0;
            left: 0;
            transition: width 0.1s linear; /* Smooth progress updates */
        }

p1 {
color: red;


}

    </style>
</head>
<body>
    <h1>HueSyntone</h1>
<!-- remove this in future -->
	<a href="https://altroweb.github.io"><- Back to AltroWeb</a><br>
	
<p2>ahh yes, the project is here. colors to sounds, now a reality ðŸ˜‰</p2><br>
  <p1>WARNING: bruh this ain't a joke, this project is still in active development and needs a lot to be reworked. stay calm and relax :) </p1><br>

    <div class="controls">
    
    
        <div class="control-group">
            <label for="instrument">Instrument:</label>
            <select id="instrument">
                <option value="piano">Piano</option>
                <option value="guitar">Guitar</option>
                <option value="drums">Drums</option>
            </select>
        </div>

         <div class="control-group speed-control">
             <fieldset>
                 <legend>Playback Speed</legend>
                 <div class="radio-group">
                     <input type="radio" id="speed1" name="speed" value="1">
                     <label for="speed1">1</label>
                     <input type="radio" id="speed2" name="speed" value="2">
                     <label for="speed2">2</label>
                     <input type="radio" id="speed3" name="speed" value="3" checked> <label for="speed3">3</label>
                     <input type="radio" id="speed4" name="speed" value="4">
                     <label for="speed4">4</label>
                     <input type="radio" id="speed5" name="speed" value="5">
                     <label for="speed5">5</label>
                 </div>
             </fieldset>
         </div>
    </div>

    <div class="color-palette">
        <div class="color-box" data-tone="C4" data-hex="#FF0000"></div>
        <div class="color-box" data-tone="C#4" data-hex="#FF4500"></div>
        <div class="color-box" data-tone="D4" data-hex="#FFA500"></div>
        <div class="color-box" data-tone="D#4" data-hex="#FFD700"></div>
        <div class="color-box" data-tone="E4" data-hex="#FFFF00"></div>
        <div class="color-box" data-tone="F4" data-hex="#ADFF2F"></div>
        <div class="color-box" data-tone="F#4" data-hex="#00FF00"></div>
        <div class="color-box" data-tone="G4" data-hex="#008000"></div>
        <div class="color-box" data-tone="G#4" data-hex="#00FFFF"></div>
        <div class="color-box" data-tone="A4" data-hex="#0000FF"></div>
        <div class="color-box" data-tone="A#4" data-hex="#8A2BE2"></div>
        <div class="color-box" data-tone="B4" data-hex="#9400D3"></div>
        <div class="color-box" data-tone="C5" data-hex="#EE82EE"></div>
        <div class="color-box" data-tone="C#5" data-hex="#FF00FF"></div>
        <div class="color-box" data-tone="D5" data-hex="#FF1493"></div>
        <div class="color-box" data-tone="D#5" data-hex="#FFC0CB"></div>
    </div>

    <div class="progress-bar-container">
        <div class="progress-bar"></div>
    </div>

    <div class="playback-controls">
        <button id="recordButton">Record</button>
        <button id="stopButton" disabled>Stop Recording</button>
         <button id="playButton" disabled>Play Sequence</button>
        <button id="pauseButton" disabled>Pause</button>
        <button id="clearButton">Clear All</button>
    </div>

    <div class="file-controls">
         <button id="downloadButton" disabled>Download Sequence (.txt)</button>
         <input type="file" id="uploadInput" accept=".txt" style="display: none;">
         <button id="uploadButton">Upload Sequence (.txt)</button>
    </div>

     <div class="sequence-display" id="sequenceDisplay">
        Sequence will appear here when recorded or uploaded...
    </div>

<p2>v0.4.2 ALPHA-tune. Early Access Mode</p2>

    <script>
        const colorBoxes = document.querySelectorAll('.color-box');
        const instrumentSelect = document.getElementById('instrument');
        const speedRadios = document.querySelectorAll('input[name="speed"]'); // Get all speed radio buttons
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const playButton = document.getElementById('playButton');
        const pauseButton = document.getElementById('pauseButton');
        const clearButton = document.getElementById('clearButton'); // Get the clear button
        const downloadButton = document.getElementById('downloadButton');
        const uploadButton = document.getElementById('uploadButton');
        const uploadInput = document.getElementById('uploadInput');
        const sequenceDisplay = document.getElementById('sequenceDisplay');
        const progressBar = document.querySelector('.progress-bar');

        // --- Web Audio API Context ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // --- Tone to Frequency Mapping (Standard MIDI notes would map well too) ---
        const toneFrequencies = {
            "C4": 261.63, "C#4": 277.18, "D4": 293.66, "D#4": 311.13, "E4": 329.63, "F4": 349.23,
            "F#4": 369.99, "G4": 392.00, "G#4": 415.30, "A4": 440.00, "A#4": 466.16, "B4": 493.88,
            "C5": 523.25, "C#5": 554.37, "D5": 587.33, "D#5": 622.25
        };

         // --- Basic Drum Sound Mapping (Example frequencies/types) ---
         // These don't directly map to musical tones but are triggered by the color index.
         const drumSounds = [
             { type: 'sine', frequency: 100, duration: 0.1, gain: 0.6 }, // Kick-like
             { type: 'triangle', frequency: 180, duration: 0.15, gain: 0.5 }, // Snare-like attack
             { type: 'square', frequency: 400, duration: 0.08, gain: 0.4 }, // Hi-hat closed
             { type: 'sawtooth', frequency: 600, duration: 0.12, gain: 0.3 }, // Cymbal crash (short)
             { type: 'sine', frequency: 120, duration: 0.1, gain: 0.6 },
             { type: 'triangle', frequency: 200, duration: 0.15, gain: 0.5 },
             { type: 'square', frequency: 450, duration: 0.08, gain: 0.4 },
             { type: 'sawtooth', frequency: 700, duration: 0.12, gain: 0.3 },
             { type: 'sine', frequency: 140, duration: 0.1, gain: 0.6 },
             { type: 'triangle', frequency: 220, duration: 0.15, gain: 0.5 },
             { type: 'square', frequency: 500, duration: 0.08, gain: 0.4 },
             { type: 'sawtooth', frequency: 800, duration: 0.12, gain: 0.3 },
             { type: 'sine', frequency: 160, duration: 0.1, gain: 0.6 },
             { type: 'triangle', frequency: 240, duration: 0.15, gain: 0.5 },
             { type: 'square', frequency: 550, duration: 0.08, gain: 0.4 },
             { type: 'sawtooth', frequency: 900, duration: 0.12, gain: 0.3 }
         ];

        // --- Speed Mapping (value from radio button to milliseconds) ---
        const speedMap = {
            '1': 1000, // Very Slow
            '2': 700,  // Slow
            '3': 400,  // Normal
            '4': 250,  // Fast
            '5': 100   // Very Fast
        };

        // --- State Variables ---
        let isRecording = false;
        let recordedSequence = []; // Stores hex codes
        let currentSequence = []; // The sequence currently loaded/recorded for playback
        let playbackInterval = null;
        let playbackIndex = 0;
        let isPlaying = false;
        let currentTempo = speedMap[document.querySelector('input[name="speed"]:checked').value]; // Initialize tempo from default checked radio

        // --- Helper to find color box element and index by hex code ---
        function getColorBoxByHex(hex) {
            for (let i = 0; i < colorBoxes.length; i++) {
                // Ensure robust comparison (handle potential missing # or different casing)
                 const boxHex = colorBoxes[i].dataset.hex ? colorBoxes[i].dataset.hex.toUpperCase().replace(/^#/, '') : '';
                 const searchHex = hex ? hex.toUpperCase().replace(/^#/, '') : '';
                if (boxHex === searchHex && boxHex !== '') {
                    return { element: colorBoxes[i], index: i };
                }
            }
            return null; // Not found
        }

        // --- Function to Play Sound based on Tone and Instrument ---
        function playInstrumentTone(tone, instrument, colorIndex) {
            // Ensure audio context is running
            if (audioContext.state === 'suspended') {
                 audioContext.resume();
            }

            const now = audioContext.currentTime;
            const gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.5, now); // Master volume

            let oscillator = null;
            let duration = 0.5; // Default duration
            let initialGain = 0.5; // Default initial gain

            if (instrument === 'drums') {
                 const drumParams = drumSounds[colorIndex % drumSounds.length];
                 oscillator = audioContext.createOscillator();
                 oscillator.type = drumParams.type;
                 oscillator.frequency.setValueAtTime(drumParams.frequency, now);
                 duration = drumParams.duration;
                 initialGain = drumParams.gain;

                 gainNode.gain.setValueAtTime(initialGain, now);
                 gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

            } else {
                const frequency = toneFrequencies[tone];
                if (!frequency) {
                    console.warn(`Unknown tone: ${tone}`);
                    return;
                }

                oscillator = audioContext.createOscillator();
                oscillator.frequency.setValueAtTime(frequency, now);

                if (instrument === 'piano') {
                    oscillator.type = 'sine';
                     duration = 0.8;
                     initialGain = 0.7;
                     gainNode.gain.setValueAtTime(0, now);
                     gainNode.gain.linearRampToValueAtTime(initialGain, now + 0.05);
                     gainNode.gain.exponentialRampToValueAtTime(initialGain * 0.4, now + 0.15);
                     gainNode.gain.setValueAtTime(initialGain * 0.4, now + 0.15 + 0.4);
                     gainNode.gain.linearRampToValueAtTime(0.001, now + duration);

                } else if (instrument === 'guitar') {
                    oscillator.type = 'triangle';
                    duration = 0.6;
                    initialGain = 0.9;
                     gainNode.gain.setValueAtTime(0, now);
                     gainNode.gain.linearRampToValueAtTime(initialGain, now + 0.01);
                     gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
                }
            }

            if (oscillator) {
                oscillator.connect(gainNode);
                oscillator.start(now);
                 oscillator.stop(now + duration + 0.5); // Ensure note plays fully before stopping oscillator
            }
        }

        // --- Update Sequence Display ---
        function updateSequenceDisplay(sequence) {
            if (sequence.length > 0) {
                sequenceDisplay.textContent = sequence.join('\n'); // Display hex codes on separate lines
            } else {
                sequenceDisplay.textContent = 'Sequence will appear here when recorded or uploaded...';
            }
            // Update the sequence used for playback
            currentSequence = [...sequence]; // Create a copy
            updateButtonStates(); // Update buttons whenever sequence changes
        }

        // --- Update Button States ---
        function updateButtonStates() {
            const hasSequence = currentSequence.length > 0;

            recordButton.disabled = isRecording || isPlaying;
            stopButton.disabled = !isRecording;
            playButton.disabled = isPlaying || !hasSequence || isRecording;
            pauseButton.disabled = !isPlaying || !hasSequence || isRecording;
             // Clear button is always enabled if there's something to clear (either recording or a sequence)
            clearButton.disabled = !(isRecording || hasSequence);
            downloadButton.disabled = !hasSequence || isRecording || isPlaying;
            uploadButton.disabled = isPlaying || isRecording;

            // Disable speed changes during playback or recording
            speedRadios.forEach(radio => {
                radio.disabled = isPlaying || isRecording;
            });
        }


        // --- Add Click Listeners to Color Boxes ---
        colorBoxes.forEach((box, index) => {
            box.addEventListener('click', () => {
                const tone = box.dataset.tone;
                const hex = box.dataset.hex;
                const instrument = instrumentSelect.value; // Get selected instrument

                // Always play the sound immediately on click
                playInstrumentTone(tone, instrument, index); // Pass color index for drums

                // If recording, add the hex code to the sequence
                if (isRecording) {
                    recordedSequence.push(hex);
                    updateSequenceDisplay(recordedSequence); // Update display immediately
                }
            });
        });

        // --- Recording Controls ---
        recordButton.addEventListener('click', () => {
            isRecording = true;
            recordedSequence = []; // Clear previous recording
            // Don't update currentSequence or display until stop
            progressBar.style.width = '0%'; // Reset progress bar
            playbackIndex = 0; // Reset playback index
            isPlaying = false; // Ensure playback is stopped
            clearInterval(playbackInterval); // Stop any ongoing playback interval

            sequenceDisplay.textContent = 'Recording... Click colors to add them.'; // Indicate recording status

            console.log("Recording started...");
            updateButtonStates();
        });

        stopButton.addEventListener('click', () => {
            isRecording = false;
            console.log("Recording stopped.");
             // Make the recorded sequence the current playback sequence
            updateSequenceDisplay(recordedSequence);
            updateButtonStates();
        });

        // --- Playback Controls ---
        playButton.addEventListener('click', () => {
            if (currentSequence.length === 0) {
                console.warn("No sequence to play.");
                return;
            }
            if (isPlaying) {
                console.log("Already playing...");
                return;
            }

            isPlaying = true;
            playbackIndex = 0; // Start from the beginning
            progressBar.style.width = '0%'; // Reset progress bar
            updateButtonStates();
            console.log("Playback started with tempo:", currentTempo, "ms");

            // Clear any old interval before starting a new one
            clearInterval(playbackInterval);

            playbackInterval = setInterval(() => {
                if (playbackIndex < currentSequence.length) {
                    const hexToPlay = currentSequence[playbackIndex];
                    const colorInfo = getColorBoxByHex(hexToPlay);

                    if (colorInfo) {
                         const tone = colorInfo.element.dataset.tone;
                         const instrument = instrumentSelect.value;
                         const colorIndex = colorInfo.index;
                         playInstrumentTone(tone, instrument, colorIndex);

                         // Update progress bar
                         const progress = (playbackIndex + 1) / currentSequence.length * 100;
                         progressBar.style.width = progress + '%';

                    } else {
                        console.warn(`Color hex not found in palette: ${hexToPlay}`);
                         // Continue to the next step even if hex is not found
                    }

                    playbackIndex++;
                } else {
                    // Sequence finished
                    clearInterval(playbackInterval);
                    isPlaying = false;
                    playbackIndex = 0; // Reset index
                    progressBar.style.width = '100%'; // Full progress bar
                     // Reset progress bar after a short delay to show completion briefly
                     setTimeout(() => { progressBar.style.width = '0%'; }, currentTempo / 2);
                    console.log("Playback finished.");
                    updateButtonStates();
                }
            }, currentTempo); // Use the currentTempo variable
        });

        pauseButton.addEventListener('click', () => {
            if (!isPlaying) {
                console.log("Not playing.");
                return;
            }
            clearInterval(playbackInterval);
            isPlaying = false;
            console.log("Playback paused.");
            updateButtonStates();
        });

         // --- Clear Button ---
         clearButton.addEventListener('click', () => {
             isRecording = false;
             recordedSequence = [];
             isPlaying = false;
             clearInterval(playbackInterval);
             playbackIndex = 0;
             progressBar.style.width = '0%';
             updateSequenceDisplay([]); // Clear the currentSequence and the display
             console.log("All sequences cleared.");
             updateButtonStates();
         });


        // --- File Controls ---
        downloadButton.addEventListener('click', () => {
            if (currentSequence.length === 0) {
                console.warn("No sequence to download.");
                return;
            }

            const sequenceText = currentSequence.join('\n'); // Join with newlines

            const blob = new Blob([sequenceText], { type: 'text/plain' });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'color_sequence.txt';

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            console.log("Sequence download initiated.");
        });

        uploadButton.addEventListener('click', () => {
            uploadInput.click();
        });

        uploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];

            if (!file) {
                return;
            }

            const reader = new FileReader();

            reader.onload = (e) => {
                const fileContent = e.target.result;
                // Split by any whitespace, filter out empty strings
                const uploadedHexCodes = fileContent.split(/\s+/).filter(hex => hex.trim() !== '');

                // Basic validation: Check if they look like hex codes
                // Optional: Filter to only include hex codes that exist in the palette?
                const validHexCodes = uploadedHexCodes.filter(hex => /^#?([0-9A-F]{3}){1,2}$/i.test(hex));

                if (validHexCodes.length > 0) {
                     const formattedHexCodes = validHexCodes.map(hex => hex.startsWith('#') ? hex.toUpperCase() : '#' + hex.toUpperCase());

                    console.log(`Loaded sequence with ${formattedHexCodes.length} valid hex codes.`);
                    // Set the loaded sequence as the current sequence
                    updateSequenceDisplay(formattedHexCodes);
                    progressBar.style.width = '0%';
                    playbackIndex = 0;
                    isPlaying = false;
                    clearInterval(playbackInterval);
                     // updateButtonStates called by updateSequenceDisplay

                } else {
                    console.warn("Uploaded file does not contain valid hex color codes.");
                    alert("Could not load sequence. Please ensure the file contains valid hex color codes separated by whitespace (e.g., #FF0000 #00FF00).");
                     updateSequenceDisplay([]); // Clear display if upload fails
                     progressBar.style.width = '0%';
                     playbackIndex = 0;
                     isPlaying = false;
                     clearInterval(playbackInterval);
                     // updateButtonStates called by updateSequenceDisplay
                }

                // Reset the file input so change event fires for the same file again
                uploadInput.value = '';
            };

            reader.onerror = (e) => {
                console.error("Error reading file:", e);
                alert("Error reading file. Please try again.");
                 updateSequenceDisplay([]);
                 progressBar.style.width = '0%';
                 playbackIndex = 0;
                 isPlaying = false;
                 clearInterval(playbackInterval);
                 // updateButtonStates called by updateSequenceDisplay
            };

            reader.readAsText(file);
        });

        // --- Speed Control Listener ---
        speedRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                const selectedSpeed = event.target.value;
                currentTempo = speedMap[selectedSpeed];
                console.log("Speed changed to:", selectedSpeed, "Tempo:", currentTempo, "ms");

                // If playing, restart the interval with the new tempo
                if (isPlaying) {
                    clearInterval(playbackInterval);
                    // Restart playback from the current index
                     playbackInterval = setInterval(() => {
                        // Re-run the same playback logic from here
                         if (playbackIndex < currentSequence.length) {
                            const hexToPlay = currentSequence[playbackIndex];
                            const colorInfo = getColorBoxByHex(hexToPlay);

                            if (colorInfo) {
                                const tone = colorInfo.element.dataset.tone;
                                const instrument = instrumentSelect.value;
                                const colorIndex = colorInfo.index;
                                playInstrumentTone(tone, instrument, colorIndex);

                                const progress = (playbackIndex + 1) / currentSequence.length * 100;
                                progressBar.style.width = progress + '%';

                            } else {
                                console.warn(`Color hex not found in palette during speed change restart: ${hexToPlay}`);
                            }

                            playbackIndex++;
                         } else {
                             // Sequence finished (duplicate logic, but necessary for restart)
                             clearInterval(playbackInterval);
                             isPlaying = false;
                             playbackIndex = 0;
                             progressBar.style.width = '100%';
                             setTimeout(() => { progressBar.style.width = '0%'; }, currentTempo / 2);
                             console.log("Playback finished after speed change.");
                             updateButtonStates();
                         }

                    }, currentTempo); // Use the NEW currentTempo
                }
            });
        });


        // Initialize button states and display on load
        updateSequenceDisplay([]); // Sets currentSequence to [], updates display and buttons
        // Default speed is already set by the checked radio button

    </script>
</body>
</html>
