<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MixPix's MixBox</title>
    <link rel="icon" type="image/x-xicon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHIAAAByCAAAAACqttqhAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAACYktHRAD/h4/MvwAAAAd0SU1FB+gFCw40OLCUXV0AAAN4SURBVGje7ZlNSFRRFMdPH0wiucg+FirlZzaMWaYIMYFoheSu2rgNWkVr165b1iyF2hVJGQVKSUSLobKxckDGSXQ0R1HEkXAYaEBq4dTMPe+++855cy9t7tnMnP+57/zm3ffO/RoAa9asWbNmzZq1/2T7RDc8lFc0Drx4KNX77yivuhdV/YLB30qbkl81qr5qUGy9n9UnZ+TyRVYSHvLQoEwNHjGIDPTJ1OuVBpHQKhM7eDmYyKZOp9bQysvBRNbWOrX6JqNI6HFKId6jZCOvOqU+ZgouUvLcepgpuMjALawEDxtGwgAWbgdMI09goZmbgY0M9iK/xTjy+DHRb2FWpQ8kLpM27qP0gbykdLUgc2jGRx2JkPmcBuR6WvQDd0u9cJUYTa9rQG4lkSCMNjdQMLmlAQkJ5J8qdbo8GvtCVowgoam/+L2zDgVHKrTcJXp/qmuK3xsbxVhey10CzCC/ZEEXQqGPhHQU5DjyB6RfAQDgnSbkHPJLFiPnPJr6Rc4vIuFfZfaj0W5xhpCOgpxGg0Fx6XETBdKEt4c2xsaQ3/x3IXDeo6F/5HPk1xZuM3zUo6F/ZBSN1dUn9z5Po6rMRSnZaJMX7rDCMNvm0awc5GvkFzr2mkezcpDzeMzb+wiKan5eIzK2gIRhAAC82Uzq7NjUEhK6AZw7g3RKIxLwIUF9AzircoqWi4icRH5dF0BvDRJfaUVGM6JfFQIIob1mZlorEj4hvwOg3aNJuchR5F8BuOzRpFzkGqrMSgA82q0RUx0ktvuePCsKw3g2nqXMlZy7TOGa63bMld6LZh7S8XK0XkACbejhIMfQw3QsJx9rRyY21XHiaMdBwgd1+As5ER35TB1+agC5odw57lCrkoNMzKqic9Sq5CDXl1XR5awBJHxVxPLv6XkYyPs77rFfj4wgs4rKTNP7lXUI89Y9NMFIw0FOuocYj5KFXHR9mJurhpBJ1w1rIslIw0Fmv7n+GMbbwzvDi7v8m5aPc7KwkBGXm8lGjCFhgyVrQbqUH33i4iPfyGVOVXKRP6Rj3uqSQWRCesgSJy97fCBBWvKUwx7/SFll5j4bRUZ+OrXtJ0aRsOSUFpgpuMhxp0Q7evGPlGzOx7Qjxe1gJoPjq9uK5t4JYeUlfiUPiEWXetC+K8Zj4iZvYm4XZQisMLvBmjVr1qxZs2bNlP0BnuP7s/BXv9cAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjQtMDUtMTFUMTQ6NTI6NDcrMDA6MDAugOVxAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDI0LTA1LTExVDE0OjUyOjQ3KzAwOjAwX91dzQAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyNC0wNS0xMVQxNDo1Mjo1NiswMDowMGIVdzgAAAAASUVORK5CYII=">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Corinthia:wght@400;700&family=Honk&family=Radio+Canada+Big:ital,wght@0,400..700;1,400..700&family=Rowdies:wght@300;400;700&display=swap" rel="stylesheet">
    
    <script src="jsmediatags.min.js"></script>
    
    <style>
    html {
        scroll-behavior: smooth;
    }
    
    body {
        font-family: "Radio Canada Big";
        margin: 0;
        padding: 0;
        background-color: #121212;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
    }

    .card {
        background-color: #2b2828;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 1.2rem;
        flex-basis: calc(33.33% - 2rem);
        text-align: center;
        padding: 1rem;
        transition: transform 0.3s ease-in-out;
        padding: 1.5rem;
        width: 100%;
        max-width: 28rem; /* Max width for the entire card */
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
    }

    .card:hover {
        transform: translateY(-5px);
    }

    h1 {
        font-size: 3rem;
        margin-top: 0;
        color: #fff;
    }

    p {
        font-size: 1.2rem;
        color: #fff;
    }
    h3 {
        color: #fff;
    }
    h5 {
        font-size: 1.1rem;
        color: #fff;
    }
    
    a {
        font-size: 1.2rem;
        color: #fff;
    }
    
    @media (max-width: 768px) {
        .card {
            flex-basis: calc(50% - 2rem);
        }
    }

    @media (max-width: 480px) {
        .card {
            flex-basis: 100%;
        }
    }
    /*Blur CSS start*/
    body {
        transition: filter 0.5s, opacity 0.5s;
    }

    .blurred {
        filter: blur(10px);
        opacity: 0.5;
    }

    toggleBlur {
        position: relative;
        z-index: 1;
    }
    /*Blur CSS end*/

    /* Custom seekbar styling */
    input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 8px;
        background: #474747; /* Darker gray track */
        outline: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.2s ease-in-out;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff; /* Blue thumb */
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        transition: background 0.2s ease-in-out;
    }

    input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        transition: background 0.2s ease-in-out;
    }

    input[type="range"]::-ms-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        transition: background 0.2s ease-in-out;
    }

    /* Hover effect for seekbar */
    input[type="range"]:hover::-webkit-slider-thumb {
        background: #e8e8e8; /* Darker blue on hover */
    }
    input[type="range"]:hover::-moz-range-thumb {
        background: #e8e8e8;
    }
    input[type="range"]:hover::-ms-thumb {
        background: #e8e8e8;
    }

    /* Player button styling with gradients and shadows */
    .player-button {
        background: #383838;
        border: none;
        color: white;
        font-size: 1.25rem; /* Larger icons */
        padding: 0.75rem;
        border-radius: 10px; /* Fully rounded */
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
        transition: all 0.2s ease-in-out;
        display: flex;
        justify-content: center;
        align-items: center; /* Corrected from align: center */
        cursor: pointer;
    }

    .player-button:hover {
        background: #2e2e2e; /* Darker gradient on hover */
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15), 0 3px 5px rgba(0, 0, 0, 0.1);
        transform: translateY(-2px); /* Slight lift effect */
    }

    .player-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Specific styling for play/pause button */
    #play-pause-button {
        width: 60px; /* Larger */
        height: 60px;
        font-size: 1.8rem;
    }

    /* Active state for loop/shuffle buttons */
    .player-button.active {
        background: #2e2e2e; /* dark color for active */
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2); /* Inset shadow */
    }

    /* Style for the track list items */
    .track-item {
        background-color: #3d3d3d; /* Slightly lighter gray for non-active list items */
        border-radius: 0.5rem;
        padding: 0.75rem 1rem;
        margin-bottom: 0.5rem;
        transition: background-color 0.2s ease-in-out;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .track-item:hover {
        background-color:  #5c5c5c; /* Lighter gray on hover */
    }

    .track-item.active-track {
        background-color: #5c5c5c; /* strong white for active track */
        font-weight: bold;
    }

    /* Styles for truncating long track titles with ellipsis */
    .track-title-container {
        flex-grow: 1;
        min-width: 0;
        text-align: center; /* Center text within the container */
    }

    .track-title-text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Toggle Switch Styling */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 24px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #474747;
        transition: .4s;
        border-radius: 24px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .toggle-slider {
        background-color: #474747; /* Green for active */
    }

    input:focus + .toggle-slider {
        box-shadow: 0 0 1px #474747;
    }

    input:checked + .toggle-slider:before {
        transform: translateX(16px);
    }

    /* Individual Panel Styles (no background, shadow, margin-top) */
    .player-container,
    .track-list-container,
    .effects-panel {
        background-color: transparent; /* Remove individual panel backgrounds */
        box-shadow: none; /* Remove individual panel shadows */
        margin-top: 0; /* Remove individual panel top margins */
        padding: 0; /* Remove individual panel padding, handled by main-player-card */
        width: 100%; /* Ensure they take full width of parent card */
        max-width: none; /* Remove max-width, handled by main-player-card */
        border-radius: 0; /* Remove individual panel border-radius */
    }

    /* Artwork/Lyrics Wrapper */
    .artwork-lyrics-wrapper {
        position: relative;
        width: 100%;
        max-width: 12rem;
        height: 12rem;
        margin: 0 auto 1.5rem auto;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        overflow: hidden;
    }

    @media (min-width: 640px) {
        .artwork-lyrics-wrapper {
            max-width: 17rem;
            height: 17rem;
        }
    }
    @media (min-width: 768px) {
        .artwork-lyrics-wrapper {
            max-width: 22rem;
            height: 22rem;
        }
    }

    /* Artwork */
    .player-container img#artwork {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        margin-bottom: 0;
        cursor: pointer;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
    }
    /* Class to hide artwork when lyrics are shown */
    .player-container img#artwork.hidden-artwork {
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent clicks when hidden */
    }

    /* Track Info Section */
    .player-container .text-center.w-full {
        margin-bottom: 1.5rem;
        text-align: center;
    }

    /* Track Title */
    #track-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #fff;
    }

    /* Artist Name */
    #artist-name {
        color: #e0e0e0;
        font-size: 1.125rem;
    }

    /* Seekbar group container */
    .seekbar-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        margin-bottom: 1.5rem;
    }
    .seekbar-group > *:not(:first-child) {
        margin-top: 0.5rem;
    }

    /* Time display */
    .time-display {
        display: flex;
        justify-content: space-between;
        width: 100%;
        font-size: 0.875rem;
        color: #e0e0e0;
    }

    /* Player Controls */
    .player-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        margin-bottom: 1.5rem;
    }
    .player-controls > *:not(:first-child) {
        margin-left: 1rem;
    }

    /* Upload Button */
    #upload-button {
        font-family: "Radio Canada Big", sans-serif;
        background-color: #383838;
        color: white;
        font-weight: 700;
        padding: 0.75rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        transition: all 0.2s ease-in-out;
        transform: scale(1);
        outline: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        font-size: 1.2rem;
    }
    #upload-button:hover {
        background-color: #2e2e2e;
        transform: scale(1.05);
    }
    #upload-button:focus {
        box-shadow: 0 0 0 2px #e0e0e0, 0 0 0 4px #e0e0e0;
    }
    #upload-button .fas {
        margin-right: 0.5rem;
    }

    /* Upload Error Message */
    #upload-error-message {
        color: #ef4444;
        font-size: 0.875rem;
        margin-top: 0.5rem;
        text-align: center;
    }
    .hidden {
        display: none;
    }

    /* Track List Container Specifics */
    .track-list-container {
        position: relative;
        padding-top: 1.5rem;
        padding-bottom: 1.5rem;
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }

    /* Flex spacer to push content */
    .flex-spacer {
        flex-grow: 1;
    }

    /* Playlist header */
    .playlist-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
        position: relative;
    }

    /* Playlist title */
    .track-list-container h3 {
        font-size: 1.25rem;
        font-weight: 600;
        color: #fff;
        flex-grow: 1;
        text-align: left;
    }

    /* Clear playlist button */
    #clear-playlist-button {
        color: #e0e0e0;
        transition: color 0.2s ease-in-out;
        font-size: 1.5rem;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
    }
    #clear-playlist-button:hover {
        color: #fff;
    }

    /* Playlist list */
    #playlist-list {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 15rem;
        overflow-y: auto;
        padding-right: 0.5rem;
        color: #fff;
    }
    #playlist-list > li:not(:first-child) {
        margin-top: 0.5rem;
    }

    /* No tracks message */
    #playlist-list li.text-gray-400 {
        color: #e0e0e0;
        text-align: center;
        padding-top: 1rem;
        padding-bottom: 1rem;
    }

    /* Effects Panel Specifics */
    .effects-panel {
        padding-top: 1.5rem;
        padding-bottom: 1.5rem;
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }
    .effects-panel h3 {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #ffffff;
        text-align: left;
    }

    /* Effects section spacing */
    .effects-panel .effect-group {
        margin-bottom: 1.5rem;
    }
    .effects-panel .effect-group:last-child {
        margin-bottom: 0;
    }
    .effects-panel .effect-group.hidden {
        display: none;
    }

    /* Effect label and toggle alignment */
    .effects-panel .effect-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }

    /* Effect label text */
    .effects-panel label.text-lg {
        font-size: 1.125rem;
        font-weight: 500;
        color: #ffffff;
    }

    /* Slider value display */
    .effects-panel .slider-value-display {
        display: flex;
        justify-content: space-between;
        font-size: 0.875rem;
        color: #e0e0e0;
        margin-top: 0.25rem;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .main-player-card {
            width: 95%;
            padding: 1rem;
        }
        .player-controls button {
            font-size: 1rem;
            padding: 0.5rem;
        }
        #play-pause-button {
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
        }
        #clear-playlist-button {
            top: 0.5rem;
            right: 0.5rem;
            font-size: 1.2rem;
            padding: 0.3rem;
        }
    }

    /* General alignment for other content */
    p[align="center"], h3[align="center"] {
        text-align: center;
    }

    /* Save Track Button Specific Styling */
    #save-track-button {
        font-family: "Radio Canada Big", sans-serif;
        font-size: 1rem;
        padding: 0.5rem 1rem;
    }

    /* Lyrics Panel Styling */
    .lyrics-panel {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent; /* Make panel background transparent to show overlay */
        border-radius: 0.5rem;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 1rem;
        box-sizing: border-box;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        z-index: 2;
        cursor: pointer;
        overflow: hidden; /* Ensure overlay respects border-radius */
    }

    .lyrics-panel.show {
        opacity: 1;
        visibility: visible;
    }

    /* New overlay for blurred artwork background */
    .lyrics-background-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        filter: blur(20px); /* Apply blur directly to the background image */
        -webkit-filter: blur(20px); /* For Safari support */
        background-color: #000000; /* Solid black */
        opacity: 10; /* Control overall transparency of this overlay */
        z-index: -1; /* Place behind lyrics content */
    }


    .lyrics-display {
        flex-grow: 1;
        width: 100%;
        height: 100%;
        overflow-y: scroll;
        text-align: center;
        padding: 0;
        -webkit-mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
        mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
        scroll-behavior: smooth;
        display: flex;
        flex-direction: column;
        align-items: center;
        /* Hide scrollbar for all devices */
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
        position: relative; /* Ensure lyrics content is above the overlay */
        z-index: 1;
    }

    /* Hide scrollbar for Webkit browsers (Chrome, Safari) */
    .lyrics-display::-webkit-scrollbar {
        display: none;
    }

    .lyrics-display.centered-content {
        justify-content: center;
    }

    .lyrics-line {
        color: #e0e0e0; /* Brighter gray for normal lines */
        font-size: 1.2rem;
        padding: 0.3rem 0;
        transition: color 0.4s ease-in-out, font-weight 0.4s ease-in-out, transform 0.4s ease-out, opacity 0.4s ease-in-out, text-shadow 0.4s ease-in-out; /* Adjusted transition duration */
        line-height: 1.5;
        font-weight: 500;
        transform: scale(1); /* Default scale */
        opacity: 0.7; /* Slightly dim non-active lines */
    }

    .lyrics-line.active {
        color: #ffffff; /* Pure white for highlighted lines */
        font-weight: 700;
        text-shadow: 0 0 8px rgba(255, 255, 255, 0.7), 0 0 15px rgba(255, 255, 255, 0.3); /* Subtle white glow (glaze effect) */
        transform: scale(1.05); /* Slightly larger for "pull off" effect */
        opacity: 1; /* Fully opaque active line */
    }

    .no-lyrics-message {
        color: #e0e0e0;
        font-size: 1.1rem;
        margin-bottom: 1rem;
        margin: auto;
    }

    .upload-lrc-button {
        margin-top: 1rem;
        font-family: "Radio Canada Big", sans-serif;
        font-size: 1rem;
        padding: 0.75rem 1.25rem;
        margin: auto;
        cursor: pointer;
    }
    /* Hidden input for LRC upload */
    #lrc-upload-input {
        display: none;
    }

    </style>
</head>
<body>
    <div class="container">
        <div class="card">
<h1 id="top">MixPix's MixBox</h1>
          <h3>Groove in style! 🎵</h3><br>
          <a href="https://altroweb.github.io">< Back to AltroWeb</a><br><br><br><a href="#bottom">Bottom ↓</a><br><br>

        <div class="player-container">
            <div class="artwork-lyrics-wrapper">
                <img id="artwork" src="https://placehold.co/300x300/333333/FFFFFF?text=No+Artwork" alt="Album Artwork">

                <div id="lyrics-panel" class="lyrics-panel">
                    <div class="lyrics-background-overlay" id="lyrics-background-overlay"></div>
                    <div id="lyrics-display" class="lyrics-display">
                        </div>
                </div>
            </div>

            <div class="text-center w-full">
                <h2 id="track-title">No Song Loaded</h2>
                <p id="artist-name">Upload music to start</p>
            </div>

            <div class="seekbar-group">
                <div class="time-display">
                    <span id="current-time">00:00</span>
                    <span id="total-time">00:00</span>
                </div>
                <input type="range" id="seekbar" value="0" min="0" max="100">
            </div>

            <div class="player-controls">
                <button id="shuffle-button" class="player-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="white" width="24" height="24">
                        <path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM64 256c0-17.7 14.3-32 32-32H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H96c-17.7 0-32-14.3-32-32zM96 416c0-17.7 14.3-32 32-32H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H128c-17.7 0-32-14.3-32-32z"/>
                    </svg>
                </button>
                <button id="prev-button" class="player-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="white" width="24" height="24">
                        <path d="M192 64c8.188 0 16.38 3.125 22.62 9.375c12.5 12.5 12.5 32.75 0 45.25L77.25 256L214.6 393.4c12.5 12.5 12.5 32.75 0 45.25s-32.75 12.5-45.25 0l-160-160c-12.5-12.5-12.5-32.75 0-45.25l160-160C175.6 67.19 183.8 64 192 64zM320 64c17.69 0 32 14.31 32 32v320c0 17.69-14.31 32-32 32s-32-14.31-32-32V96C288 78.31 302.3 64 320 64z"/>
                    </svg>
                </button>
                <button id="play-pause-button" class="player-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="white" width="24" height="24">
                        <path d="M73.05 7.854c-11.12 8.358-17.05 22.42-17.05 36.88v422.3c0 14.46 5.922 28.52 17.05 36.88c11.13 8.358 25.17 10.42 38.38 5.497l300-211.6c12.98-4.874 21.62-17.15 21.62-31.02c0-13.88-8.637-26.15-21.62-31.02l-300-211.6C98.22-2.569 84.18-0.4957 73.05 7.854z"/>
                    </svg>
                </button>
                <button id="next-button" class="player-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="white" width="24" height="24">
                                                <path d="M192 448c-8.188 0-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-32.75 0-45.25L306.8 256L169.4 118.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25l-160 160C208.4 444.8 200.2 448 192 448zM64 448c-17.69 0-32-14.31-32-32V96c0-17.69 14.31-32 32-32S96 78.31 96 96v320C96 433.7 81.69 448 64 448z"/>

                    </svg>
                </button>
                <button id="loop-button" class="player-button">
                    <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 62.63" style="enable-background:new 0 0 122.88 62.63" xml:space="preserve" fill="white" width="24" height="24">
                        <g>
                            <path d="M44.94,20.02c-7.77-8.05-18.67-13.18-27.82-4.34c-2.99,2.88-5.13,6.8-6.07,11c-1.12,4.98-0.28,9.53,1.79,13.28 c1.84,3.34,4.65,6.07,7.96,7.95c3.32,1.89,7.1,2.91,10.85,2.8c4.12-0.12,8.24-1.64,11.7-4.91c4.89-4.63,9.16-11.55,13.33-18.3 c4.56-7.38,9-14.57,14.45-19.43c3.89-3.47,8.05-5.71,12.27-6.94c6.06-1.76,12.12-1.37,17.63,0.55c5.42,1.88,10.28,5.22,14.02,9.42 c3.18,3.56,5.6,7.8,6.92,12.33c1.92,6.6,0.76,14.51-2.74,21.43c-2.48,4.89-6.16,9.38-10.78,12.62c-4.75,3.33-10.47,5.34-16.87,5.15 c-7.32-0.22-15.4-3.3-23.73-10.6l6.93-7.92c6.31,5.53,12.08,7.85,17.09,8c3.98,0.12,7.56-1.15,10.56-3.25 c3.13-2.19,5.66-5.3,7.4-8.74c2.36-4.66,3.2-9.75,2.04-13.75c-0.86-2.96-2.5-5.79-4.69-8.25c-2.6-2.92-5.92-5.22-9.56-6.49 c-3.55-1.23-7.44-1.5-11.28-0.38c-2.73,0.79-5.5,2.31-8.19,4.71c-4.37,3.9-8.39,10.4-12.51,17.08c-4.54,7.35-9.19,14.88-15.03,20.4 c-5.48,5.19-12.07,7.6-18.67,7.8c-5.71,0.17-11.4-1.34-16.34-4.16c-4.96-2.82-9.2-6.96-12-12.04c-3.24-5.87-4.55-12.96-2.82-20.67 c1.39-6.18,4.58-11.97,9.05-16.28c3.01-2.9,6.6-5.15,10.63-6.42c4.06-1.28,8.52-1.55,13.24-0.49c6.08,1.37,12.51,4.96,18.85,11.54 L44.94,20.02L44.94,20.02z"/>
                        </g>
                    </svg>
                </button>
            </div>

            <input type="file" id="music-upload" accept="audio/*" multiple class="hidden">
          
            <p id="upload-error-message" class="hidden"></p>
        </div>

<button id="upload-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="white" width="20" height="20" style="margin-right: 0.5rem;">
                    <path d="M288 109.3V352c0 17.7-14.3 32-32 32s-32-14.3-32-32V109.3L135.5 184.5c-12.5 12.5-32.75 12.5-45.25 0s-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25s-32.75 12.5-45.25 0L288 109.3zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352v96c0 35.2 28.8 64 64 64H448c35.2 0 64-28.8 64-64V352c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 0-1.375 0-1.75 0H64c0 0-1.375 0-1.75 0V352z"/>
                </svg>
                Upload Music
            </button>


        <div class="track-list-container">
            <div class="playlist-header">
                <h3>Playlist</h3>
                <button id="clear-playlist-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="white" width="24" height="24">
                        <path d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM343.1 329.1c-9.375 9.375-24.56 9.375-33.94 0L256 290.1L202.9 343.1c-9.375 9.375-24.56 9.375-33.94 0c-9.375-9.375-9.375-24.56 0-33.94L222.1 256L169 202.9c-9.375-9.375-9.375-24.56 0-33.94s24.56-9.375 33.94 0L256 222.1L309.1 169c9.375-9.375 24.56-9.375 33.94 0s9.375 24.56 0 33.94L290.1 256L343.1 309.1C352.5 318.6 352.5 329.1 343.1 329.1z"/>
                    </svg>
                </button>
            </div>
            
            <ul id="playlist-list">
                <li>No tracks uploaded yet.</li>
            </ul>
        </div>

        <div class="effects-panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h3>Effects Panel</h3>
                <button id="save-track-button" class="player-button" disabled>
                    Save Track
                </button>
            </div>

            <div class="effect-group hidden">
                <div class="effect-header">
                    <label for="pitch-toggle" class="text-lg font-medium">Pitch Shift</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="pitch-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <input type="range" id="pitch-slider" min="-400" max="400" value="0" disabled>
                <div class="slider-value-display">
                    <span>-4 semitones</span>
                    <span id="pitch-value">0 semitones</span>
                    <span>+4 semitones</span>
                </div>
            </div>

            <div class="effect-group">
                <div class="effect-header">
                    <label for="tempo-toggle" class="text-lg font-medium">Tempo</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="tempo-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <input type="range" id="tempo-slider" min="0.8" max="1.2" value="1.0" step="0.01" disabled>
                <div class="slider-value-display">
                    <span>80%</span>
                    <span id="tempo-value">100%</span>
                    <span>120%</span>
                </div>
            </div>

            <div class="effect-group">
                <div class="effect-header">
                    <label for="reverb-toggle" class="text-lg font-medium">Reverb</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="reverb-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <input type="range" id="reverb-slider" min="0" max="5" value="0" disabled>
                <div class="slider-value-display">
                    <span>No Reverb</span>
                    <span id="reverb-value">No Reverb</span>
                    <span>Max Reverb</span>
                </div>
            </div>

            <div class="effect-group">
                <div class="effect-header">
                    <label for="bass-toggle" class="text-lg font-medium">Bass Boost</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="bass-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <input type="range" id="bass-slider" min="0" max="20" value="0" disabled>
                <div class="slider-value-display">
                    <span>0 dB</span>
                    <span id="bass-value">0 dB</span>
                    <span>20 dB</span>
                </div>
            </div>

            <div class="effect-group">
                <div class="effect-header">
                    <label for="lowpass-toggle" class="text-lg font-medium">Muffle (LPF)</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="lowpass-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <input type="range" id="lowpass-slider" min="0" max="100" value="0" disabled>
                <div class="slider-value-display">
                    <span>0%</span>
                    <span id="lowpass-value">0%</span>
                    <span>100%</span>
                </div>
            </div>

            <div class="effect-group">
                <div class="effect-header">
                    <label for="pan-toggle" class="text-lg font-medium">Stereo Pan</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="pan-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <input type="range" id="pan-slider" min="-1" max="1" value="0" step="0.01" disabled>
                <div class="slider-value-display">
                    <span>Left</span>
                    <span id="pan-value">Center</span>
                    <span>Right</span>
                </div>
            </div>

            </div>
    

    <audio id="audio-player" class="hidden"></audio>


 <br><br>

 		<br><br>
 	<p id="bottom" align="center"></p><br><br>
    <div>
    <a href="#top">Top ↑</a>
    </div>
 	<br><br><br>
    <p align="center">NOTE: If you use tempo effect, the lyrics may mismatch due to altered time stretch.<br><br>This music player may contain bugs which are to be fixed. Sorry for any inconvenience.</p>
    <br><br>
    <p>For Fun Only:</p>
    <a href="javascript:void(0);" onclick="changeFont()">Change Font</a><br><br>
    <a href="javascript:void(0)" id="toggleBlur">Toggle Blur</a>
    
    <h5>NOTE: If any problem occurs due to the font or blur effect, just reload the page.</h5>
    <br><br>
    <a href="https://altroweb.github.io">< Back to AltroWeb</a>
    <br><br>
    <p align="center">Last Updated: 27 May 2025, 4:30 PM</p><br>
 	
 	<p align=center>Source Code: <a href="https://github.com/AltroWeb/altroweb.github.io/">AltroWeb Source</a>
</p>


 	<br><br>
 	<h3 align=center>©AltroWeb - MixPix. All rights reserved.</h3>
    
   </div>
   
 <script>
var fontNames = ['Rowdies', 'Honk', 'Corinthia', 'Radio Canada Big'];
var currentIndex = 0;

function changeFont() {
    document.body.style.fontFamily = fontNames[currentIndex];
    currentIndex = (currentIndex + 1) % fontNames.length;
}

/*Blur function start*/
const toggleButton = document.getElementById('toggleBlur');

toggleButton.addEventListener('click', () => {
  document.body.classList.toggle('blurred');
});
/*Blur function start*/




  // Get references to DOM elements
        const audioPlayer = document.getElementById('audio-player'); // Still used for UI time updates
        const artwork = document.getElementById('artwork');
        const trackTitle = document.getElementById('track-title');
        const artistName = document.getElementById('artist-name');
        const seekbar = document.getElementById('seekbar');
        const currentTimeSpan = document.getElementById('current-time');
        const totalTimeSpan = document.getElementById('total-time');
        const playPauseButton = document.getElementById('play-pause-button');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const loopButton = document.getElementById('loop-button');
        const shuffleButton = document.getElementById('shuffle-button');
        const uploadButton = document.getElementById('upload-button');
        const musicUploadInput = document.getElementById('music-upload');
        const playlistList = document.getElementById('playlist-list');
        const clearPlaylistButton = document.getElementById('clear-playlist-button');
        const uploadErrorMessage = document.getElementById('upload-error-message');
        const saveTrackButton = document.getElementById('save-track-button'); // New save button

        // Effects Panel elements
        const pitchToggle = document.getElementById('pitch-toggle');
        const pitchSlider = document.getElementById('pitch-slider');
        const pitchValue = document.getElementById('pitch-value');
        const tempoToggle = document.getElementById('tempo-toggle'); 
        const tempoSlider = document.getElementById('tempo-slider');
        const tempoValue = document.getElementById('tempo-value');
        const reverbToggle = document.getElementById('reverb-toggle');
        const reverbSlider = document.getElementById('reverb-slider');
        const reverbValue = document.getElementById('reverb-value');
        // Bass Boost elements
        const bassToggle = document.getElementById('bass-toggle');
        const bassSlider = document.getElementById('bass-slider');
        const bassValue = document.getElementById('bass-value');
        // New Low Pass Filter elements
        const lowpassToggle = document.getElementById('lowpass-toggle');
        const lowpassSlider = document.getElementById('lowpass-slider');
        const lowpassValue = document.getElementById('lowpass-value');
        // New Stereo Pan elements
        const panToggle = document.getElementById('pan-toggle');
        const panSlider = document.getElementById('pan-slider');
        const panValue = document.getElementById('pan-value');

        // New Lyrics Panel elements
        const lyricsPanel = document.getElementById('lyrics-panel');
        const lyricsBackgroundOverlay = document.getElementById('lyrics-background-overlay'); // Get the new overlay div
        const lyricsDisplay = document.getElementById('lyrics-display');
        // Removed closeLyricsButton as it's now a toggle


        // Player state variables
        let playlist = [];
        let currentTrackIndex = -1;
        let isShuffling = false;
        let isLooping = false;
        let isPlaying = false;
        const MAX_TRACKS = 10; // Maximum number of tracks allowed in the playlist

        // Web Audio API setup
        let audioCtx;
        let currentSourceNode = null; // The AudioBufferSourceNode for the currently playing track
        let dryGainNode; // For the original signal
        let wetGainNode; // For the reverb signal
        let convolverNode = null; // For reverb effect using impulse response
        let bassFilterNode = null; // Node for bass boost (low-shelf filter)
        let compressorNode = null; // Node for dynamics compression
        let lowpassFilterNode = null; // New node for low-pass filter

        // Variables for managing playback time with AudioBufferSourceNode
        let playbackStartTime = 0; // audioCtx.currentTime when playback started/resumed (real-time)
        let currentPlaybackOffset = 0; // Current position in the original track (in seconds)

        // Animation frame for updating seekbar
        let animationFrameId = null;

        // Stereo Pan specific nodes (global references for real-time playback)
        let pannerNode = null;

        // Lyrics state variable
        let currentLyricIndex = -1; // Keep track of the currently highlighted lyric


        /**
         * Generates a simple decaying noise impulse response for the convolver.
         * This simulates a room's echo characteristics, with an attempt to reduce white noise
         * by shaping the decay.
         * @param {number} duration - The length of the impulse response in seconds.
         * @param {number} decay - How quickly the noise decays (higher value = faster initial decay).
         * @param {AudioContext|OfflineAudioContext} context - The audio context to create the buffer in.
         * @returns {AudioBuffer} The generated impulse response.
         */
        function generateReverbImpulseResponse(duration = 2, decay = 1.5, context = audioCtx) {
            const sampleRate = context.sampleRate;
            const length = sampleRate * duration;
            const impulse = context.createBuffer(2, length, sampleRate); // Stereo buffer

            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);

            // Generate random noise and apply a decaying envelope.
            // A higher decay value makes the initial drop-off steeper, which can help
            // reduce lingering high-frequency noise.
            for (let i = 0; i < length; i++) {
                // Apply a power curve for decay, making it more aggressive.
                const envelope = Math.pow(1 - i / length, decay);
                // Introduce a slight random variation to the envelope for more naturalness
                // without adding too much harsh noise.
                const randomL = (Math.random() * 2 - 1) * 0.7; // Reduce max amplitude of noise
                const randomR = (Math.random() * 2 - 1) * 0.7; // Reduce max amplitude of noise

                impulseL[i] = randomL * envelope;
                impulseR[i] = randomR * envelope;
            }
            return impulse;
        }

        /**
         * Initializes the Web Audio API context and nodes.
         * This should be called on the first user interaction to comply with browser autoplay policies.
         */
        function initAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                dryGainNode = audioCtx.createGain(); // Node for the direct sound
                wetGainNode = audioCtx.createGain(); // Node for the reverb (wet) sound
                convolverNode = audioCtx.createConvolver(); // Node for the reverb effect
                bassFilterNode = audioCtx.createBiquadFilter(); // Node for bass boost
                bassFilterNode.type = 'lowshelf'; // Low-shelf filter for bass boost
                bassFilterNode.frequency.value = 80; // Frequency around 80 Hz for bass
                bassFilterNode.gain.value = 0; // Default 0 dB gain

                // Initialize the DynamicsCompressorNode
                compressorNode = audioCtx.createDynamicsCompressor();
                // Set compressor parameters for smooth, boomy bass without distortion
                compressorNode.threshold.value = -24; 
                compressorNode.knee.value = 30;      
                compressorNode.ratio.value = 10;     
                compressorNode.attack.value = 0.005; 
                compressorNode.release.value = 0.15; 

                // Initialize the Low Pass Filter Node
                lowpassFilterNode = audioCtx.createBiquadFilter();
                lowpassFilterNode.type = 'lowpass';
                // Default high frequency (no muffling)
                lowpassFilterNode.frequency.value = audioCtx.sampleRate / 2; // Nyquist frequency, effectively transparent
                lowpassFilterNode.Q.value = 1; // Default Q value

                // Connect the core chain that always exists, but is controlled by gains/toggles
                // These connections are persistent and do not need to be re-established in playTrack
                bassFilterNode.connect(compressorNode);
                compressorNode.connect(dryGainNode);
                convolverNode.connect(wetGainNode);
                dryGainNode.connect(lowpassFilterNode);
                wetGainNode.connect(lowpassFilterNode);
                lowpassFilterNode.connect(audioCtx.destination);

                // Set initial reverb wet gain to 0 (off)
                wetGainNode.gain.value = 0;
                
                // Generate a default impulse response for the convolver
                convolverNode.buffer = generateReverbImpulseResponse();

                // Initialize Stereo Panner node
                pannerNode = audioCtx.createStereoPanner();
                pannerNode.pan.value = 0; // Default center
            }
            // Resume context if suspended (e.g., after user interaction)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }


        // --- Helper Functions ---

        /**
         * Formats time in seconds to MM:SS format.
         * @param {number} seconds - The time in seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        /**
         * Shows an error message below the upload button.
         * @param {string} message - The error message to display.
         */
        function showUploadError(message) {
            uploadErrorMessage.textContent = message;
            uploadErrorMessage.classList.remove('hidden');
            setTimeout(() => {
                uploadErrorMessage.classList.add('hidden');
            }, 5000); // Hide after 5 seconds
        }

        /**
         * Updates the UI to reflect the current track's information.
         * @param {Object} track - The track object containing title, artist, and duration.
         */
        function updateTrackInfo(track) {
            artwork.src = track.artwork || 'https://placehold.co/300x300/333333/FFFFFF?text=No+Artwork';
            artwork.onerror = () => artwork.src = 'https://placehold.co/300x300/333333/FFFFFF?text=No+Artwork'; // Fallback
            trackTitle.textContent = track.title;
            artistName.textContent = track.artist;
            totalTimeSpan.textContent = track.duration ? formatTime(track.duration) : '00:00';
            seekbar.value = 0;
            currentTimeSpan.textContent = '00:00';
            updatePlaylistUI(); // Highlight the current track in the list
            // Do NOT call displayLyrics here, it's handled when lyrics panel is shown
        }

        /**
         * Updates the visual state of the play/pause button.
         */
        function updatePlayPauseButton() {
            if (isPlaying) {
                playPauseButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" fill="white" width="24" height="24">
                        <path d="M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z"/>
                    </svg>
                `;
            } else {
                playPauseButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="white" width="24" height="24">
                        <path d="M73.05 7.854c-11.12 8.358-17.05 22.42-17.05 36.88v422.3c0 14.46 5.922 28.52 17.05 36.88c11.13 8.358 25.17 10.42 38.38 5.497l300-211.6c12.98-4.874 21.62-17.15 21.62-31.02c0-13.88-8.637-26.15-21.62-31.02l-300-211.6C98.22-2.569 84.18-0.4957 73.05 7.854z"/>
                    </svg>
                `;
            }
        }

        /**
         * Updates the visual state of the loop button.
         */
        function updateLoopButton() {
            if (isLooping) {
                loopButton.classList.add('active');
            } else {
                loopButton.classList.remove('active');
            }
        }

        /**
         * Updates the visual state of the shuffle button.
         */
        function updateShuffleButton() {
            if (isShuffling) {
                shuffleButton.classList.add('active');
            } else {
                shuffleButton.classList.remove('active');
            }
        }

        /**
         * Clears and re-renders the playlist UI, highlighting the currently playing track.
         */
        function updatePlaylistUI() {
            playlistList.innerHTML = ''; // Clear existing list
            if (playlist.length === 0) {
                playlistList.innerHTML = '<li class="text-gray-400 text-center py-4">No tracks uploaded yet.</li>';
                return;
            }

            playlist.forEach((track, index) => {
                const listItem = document.createElement('li');
                listItem.className = `track-item ${index === currentTrackIndex ? 'active-track' : ''}`;
                listItem.dataset.index = index;
                listItem.innerHTML = `
                    <div class="track-title-container">
                        <div class="font-semibold text-base track-title-text">${track.title}</div>
                        <div class="text-sm text-gray-300 track-title-text">${track.artist}</div>
                    </div>
                    <div class="text-sm text-gray-300 ml-4 flex-shrink-0">${formatTime(track.duration || 0)}</div>
                `;
                listItem.addEventListener('click', () => loadTrack(index));
                playlistList.appendChild(listItem);
            });
        }

        // --- Core Player Functions ---

        /**
         * Loads and prepares a track from the playlist.
         * Decodes audio data into an AudioBuffer.
         * @param {number} index - The index of the track to load.
         */
        async function loadTrack(index) {
            if (index < 0 || index >= playlist.length) {
                console.error("Invalid track index.");
                return;
            }

            // Stop current playback if any
            if (currentSourceNode) {
                try {
                    currentSourceNode.stop();
                    currentSourceNode.disconnect();
                } catch (e) {
                    console.warn("Error stopping previous source node:", e);
                }
                currentSourceNode = null;
                cancelAnimationFrame(animationFrameId);
            }
            
            currentTrackIndex = index;
            const track = playlist[currentTrackIndex];

            // If audioBuffer is already decoded, just update UI and play
            if (track.audioBuffer) {
                updateTrackInfo(track);
                currentPlaybackOffset = 0; // Reset playback to start
                playTrack();
                return;
            }

            // Otherwise, fetch and decode audio
            try {
                const response = await fetch(track.src);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                
                track.audioBuffer = audioBuffer; // Store the decoded buffer
                track.duration = audioBuffer.duration; // Store actual duration

                updateTrackInfo(track);
                currentPlaybackOffset = 0; // Reset playback to start
                playTrack();

            } catch (error) {
                console.error("Error loading or decoding audio:", error);
                trackTitle.textContent = "Error Loading Track";
                artistName.textContent = "Please try another file.";
                isPlaying = false;
                updatePlayPauseButton();
            }
        }

        /**
         * Plays the current track using AudioBufferSourceNode.
         */
        function playTrack() {
            if (playlist.length === 0 || currentTrackIndex === -1) return;

            initAudioContext(); // Ensure audio context is initialized and resumed

            // Stop and disconnect existing source node completely before rebuilding connections
            if (currentSourceNode) {
                try {
                    currentSourceNode.stop();
                    currentSourceNode.disconnect();
                } catch (e) {
                    console.warn("Error stopping source node:", e);
                }
                currentSourceNode = null;
            }

            const track = playlist[currentTrackIndex];
            if (!track.audioBuffer) {
                console.error("AudioBuffer not available for current track.");
                return;
            }

            currentSourceNode = audioCtx.createBufferSource();
            currentSourceNode.buffer = track.audioBuffer;

            // Apply current pitch and tempo settings directly to the source
            applyPitch(); // Sets currentSourceNode.detune.value
            applyTempo(); // Sets currentSourceNode.playbackRate.value

            // --- Disconnect previous connections from pannerNode to main effects ---
            // This is crucial to ensure a clean graph for the new connections.
            try {
                if (pannerNode) { // Check if pannerNode exists
                    pannerNode.disconnect(bassFilterNode);
                    pannerNode.disconnect(convolverNode);
                }
            } catch (e) {
                // Catch errors if a disconnection is attempted on a node that wasn't connected
                console.warn("Error during pre-connection disconnection (expected for non-active nodes):", e);
            }

            // --- Connect Source to Panner (if active) or directly to main effects ---
            if (panToggle.checked) {
                currentSourceNode.connect(pannerNode); // Source connects to panner
                pannerNode.pan.value = parseFloat(panSlider.value); // Set pan value
                pannerNode.connect(bassFilterNode); // Panner output connects to main dry path
                pannerNode.connect(convolverNode); // Panner output connects to main wet path
            } else {
                if (pannerNode) pannerNode.pan.value = 0; // Reset pan value if effect is off
                currentSourceNode.connect(bassFilterNode); // Source connects directly to main dry path
                currentSourceNode.connect(convolverNode); // Source connects directly to main wet path
            }

            // --- Apply remaining effects (Bass, Reverb, LPF) ---
            // These functions set parameters on already connected nodes.
            applyBassBoost(); // Sets bassFilterNode.gain.value
            applyReverbPreset(parseInt(reverbSlider.value)); // Sets wetGainNode.gain.value
            applyLowPass(); // Sets lowpassFilterNode.frequency.value


            // The offset parameter to start() is in terms of the buffer's time,
            // which is affected by playbackRate.
            const startOffsetInBuffer = currentPlaybackOffset / currentSourceNode.playbackRate.value;
            
            // Ensure we don't start beyond the buffer's actual length
            if (startOffsetInBuffer >= currentSourceNode.buffer.duration) {
                currentPlaybackOffset = 0;
                nextTrack();
                return;
            }

            try {
                currentSourceNode.start(0, startOffsetInBuffer);
                playbackStartTime = audioCtx.currentTime;
                isPlaying = true;
                updatePlayPauseButton();
                updateSeekbarLoop();
            } catch (error) {
                console.error("Error starting audio playback:", error);
                isPlaying = false;
                updatePlayPauseButton();
            }
        }

        /**
         * Pauses the current track.
         */
        function pauseTrack() {
            if (currentSourceNode) {
                try {
                    currentSourceNode.stop();
                    currentSourceNode.disconnect();
                } catch (e) {
                    console.warn("Error stopping source node:", e);
                }
                // Calculate current playback position in ORIGINAL track time
                currentPlaybackOffset += (audioCtx.currentTime - playbackStartTime) * currentSourceNode.playbackRate.value;
                isPlaying = false;
                updatePlayPauseButton();
                cancelAnimationFrame(animationFrameId);
            }
        }

        /**
         * Toggles play/pause state.
         */
        function playPause() {
            if (playlist.length === 0) return;

            if (isPlaying) {
                pauseTrack();
            } else {
                if (currentTrackIndex === -1 || !playlist[currentTrackIndex].audioBuffer) {
                    loadTrack(0); // Load and play the first track if nothing is loaded
                } else {
                    playTrack(); // Resume or start playing the current track
                }
            }
        }

        /**
         * Plays the next track in the playlist. Handles shuffle and loop.
         */
        function nextTrack() {
            if (playlist.length === 0) return;

            if (isShuffling) {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * playlist.length);
                } while (newIndex === currentTrackIndex && playlist.length > 1); // Ensure different track if possible
                loadTrack(newIndex);
            } else {
                currentTrackIndex++;
                if (currentTrackIndex >= playlist.length) {
                    currentTrackIndex = 0; // Loop back to start
                    if (!isLooping) { // If not looping, pause after the last track
                        pauseTrack();
                        updateTrackInfo(playlist[currentTrackIndex]); // Show info of first track
                        currentPlaybackOffset = 0; // Reset playback offset
                        return;
                    }
                }
                loadTrack(currentTrackIndex);
            }
        }

        /**
         * Plays the previous track in the playlist.
         */
        function prevTrack() {
            if (playlist.length === 0) return;

            currentTrackIndex--;
            if (currentTrackIndex < 0) {
                currentTrackIndex = playlist.length - 1; // Loop back to end
            }
            loadTrack(currentTrackIndex);
        }

        /**
         * Toggles the loop mode for the current track.
         */
        function toggleLoop() {
            isLooping = !isLooping;
            updateLoopButton();
        }

        /**
         * Toggles the shuffle mode.
         */
        function toggleShuffle() {
            isShuffling = !isShuffling;
            updateShuffleButton();
            // Note: Shuffle logic is applied in nextTrack()
        }

        /**
         * Updates the seekbar and current time display.
         * This function is called repeatedly via requestAnimationFrame.
         */
        function updateSeekbar() {
            if (!isPlaying || !currentSourceNode || !currentSourceNode.buffer) {
                animationFrameId = null;
                return;
            }

            const trackOriginalDuration = playlist[currentTrackIndex].duration; // Use original duration
            
            // Calculate current position in ORIGINAL track time
            const elapsedRealTime = audioCtx.currentTime - playbackStartTime;
            const currentPositionInOriginalTime = currentPlaybackOffset + (elapsedRealTime * currentSourceNode.playbackRate.value);

            currentTimeSpan.textContent = formatTime(currentPositionInOriginalTime);

            if (isNaN(trackOriginalDuration) || trackOriginalDuration === 0) {
                seekbar.value = 0;
            } else {
                const progress = (currentPositionInOriginalTime / trackOriginalDuration) * 100;
                seekbar.value = progress;
                totalTimeSpan.textContent = formatTime(trackOriginalDuration); // Always show original total time
            }

            // Synchronize lyrics ONLY if the lyrics panel is visible
            if (lyricsPanel.classList.contains('show')) {
                syncLyrics();
            }

            // Check if current position in original time has exceeded original duration
            if (currentPositionInOriginalTime >= trackOriginalDuration) {
                // This is the custom end condition, overriding the native onended if tempo changes duration
                isPlaying = false;
                updatePlayPauseButton();
                cancelAnimationFrame(animationFrameId); // Stop updating seekbar
                currentPlaybackOffset = 0; // Reset for next play/loop
                // Stop the current source node explicitly to prevent it from playing further
                try {
                    currentSourceNode.stop();
                    currentSourceNode.disconnect();
                } catch (e) {
                    console.warn("Error stopping source node at end of track:", e);
                }
                currentSourceNode = null; // Clear the reference

                if (isLooping) {
                    playTrack(); // Loop
                } else {
                    nextTrack(); // Go to next track
                }
                return; // Stop further execution for this frame
            }

            animationFrameId = requestAnimationFrame(updateSeekbar);
        }

        /**
         * Starts the requestAnimationFrame loop for updating the seekbar.
         */
        function updateSeekbarLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(updateSeekbar);
        }

        /**
         * Seeks to a specific position in the track based on seekbar value.
         */
        function seekTo() {
            if (!currentSourceNode || !currentSourceNode.buffer) return;

            // Calculate seek time based on original duration
            const trackOriginalDuration = playlist[currentTrackIndex].duration;
            const seekTimeInOriginal = (seekbar.value / 100) * trackOriginalDuration;
            currentPlaybackOffset = seekTimeInOriginal; // Update offset in original time

            // If currently playing, stop and restart from the new seek position
            if (isPlaying) {
                playTrack(); // This will use the updated currentPlaybackOffset
            } else {
                // If paused, just update the current time display
                currentTimeSpan.textContent = formatTime(currentPlaybackOffset);
            }
            // Also update lyrics position when seeking
            if (lyricsPanel.classList.contains('show')) {
                syncLyrics();
            }
        }

        /**
         * Clears the entire playlist and resets the player state.
         */
        function clearPlaylist() {
            pauseTrack(); // This will also stop currentSourceNode and cancel animationFrame
            playlist = [];
            currentTrackIndex = -1;
            
            artwork.src = 'https://placehold.co/300x300/333333/FFFFFF?text=No+Artwork';
            trackTitle.textContent = 'No Song Loaded';
            artistName.textContent = 'Upload music to start';
            currentTimeSpan.textContent = '00:00';
            totalTimeSpan.textContent = '00:00';
            seekbar.value = 0;
            updatePlayPauseButton();
            updatePlaylistUI();
            uploadErrorMessage.classList.add('hidden'); // Hide any error message
            updateSaveButtonState(); // Update save button state
            lyricsPanel.classList.remove('show'); // Hide lyrics panel
            artwork.classList.remove('hidden-artwork'); // Ensure artwork is visible
            lyricsBackgroundOverlay.style.backgroundImage = ''; // Clear background image on overlay
        }

        // --- Effects Panel Functions ---

        /**
         * Updates the enabled/disabled state of the save button based on active effects.
         */
        function updateSaveButtonState() {
            const isAnyEffectEnabled = pitchToggle.checked || tempoToggle.checked || reverbToggle.checked || bassToggle.checked || lowpassToggle.checked || panToggle.checked;
            saveTrackButton.disabled = !isAnyEffectEnabled;
        }

        /**
         * Applies the current pitch setting to the source node.
         * Pitch is controlled by detune parameter (cents).
         */
        function applyPitch() {
            if (currentSourceNode && pitchToggle.checked) {
                const cents = parseFloat(pitchSlider.value);
                currentSourceNode.detune.value = cents;
                pitchValue.textContent = `${cents / 100} semitones`;
            } else if (currentSourceNode) {
                currentSourceNode.detune.value = 0; // Reset to normal pitch
                pitchValue.textContent = '0 semitones';
            }
        }

        /**
         * Updates the pitch based on the slider value.
         */
        function updatePitch() {
            applyPitch(); // Apply the current slider value
        }

        /**
         * Toggles the pitch shift effect on or off.
         */
        function togglePitch() {
            initAudioContext(); // Ensure audio context is initialized
            const isEnabled = pitchToggle.checked;
            pitchSlider.disabled = !isEnabled;
            applyPitch(); // Apply or reset pitch based on toggle state
            updateSaveButtonState(); // Update save button state
        }

        /**
         * Applies the current tempo setting to the source node.
         * Tempo is controlled by playbackRate.
         */
        function applyTempo() {
            if (currentSourceNode && tempoToggle.checked) {
                const tempoFactor = parseFloat(tempoSlider.value);
                currentSourceNode.playbackRate.value = tempoFactor;
                const tempoPercentage = Math.round(tempoFactor * 100);
                tempoValue.textContent = `${tempoPercentage}%`;
            } else if (currentSourceNode) {
                currentSourceNode.playbackRate.value = 1.0; // Reset to normal tempo
                tempoValue.textContent = '100%';
            }
        }

        /**
         * Updates the tempo based on the slider value.
         * Slider range: 0.8 (80%) to 1.2 (120%).
         */
        function updateTempo() {
            applyTempo(); // Apply the current slider value
        }

        /**
         * Toggles the tempo effect on or off.
         */
        function toggleTempo() {
            initAudioContext(); // Ensure audio context is initialized
            const isEnabled = tempoToggle.checked;
            tempoSlider.disabled = !isEnabled;
            applyTempo(); // Apply or reset tempo based on toggle state
            updateSaveButtonState(); // Update save button state
        }


        /**
         * Applies the selected reverb preset by adjusting the convolver's impulse response
         * and the wet gain.
         * @param {number} presetIndex - The index of the reverb preset (0-5).
         * @param {AudioContext|OfflineAudioContext} context - The audio context to use.
         * @returns {void}
         */
        function applyReverbPreset(presetIndex, context = audioCtx) {
            // Define reverb presets (wetMix: how much reverb is heard,
            // duration/decay: characteristics of the generated impulse response)
            const presets = [
                { wetMix: 0.0, duration: 0.1, decay: 0.1, label: "No Reverb" },     // 0: No Reverb
                { wetMix: 0.15, duration: 0.4, decay: 1.5, label: "Bathroom" },      // 1: Bathroom (shorter duration, slightly faster decay)
                { wetMix: 0.30, duration: 1.0, decay: 2.0, label: "Large Room" },    // 2: Large Room (medium duration, more pronounced decay)
                { wetMix: 0.45, duration: 2.0, decay: 2.5, label: "Concert Hall" },  // 3: Concert Hall (longer duration, smoother decay)
                { wetMix: 0.60, duration: 3.5, decay: 3.0, label: "Cathedral" },     // 4: Cathedral (very long, expansive decay)
                { wetMix: 0.75, duration: 4.5, decay: 3.5, label: "Maximum Reverb" } // 5: Maximum Reverb (even longer, more pronounced decay)
            ];

            const preset = presets[presetIndex];
            if (context === audioCtx) { // Only update UI if it's the main audio context
                reverbValue.textContent = preset.label;
            }

            // Update the convolver's impulse response based on preset duration and decay
            if (context && convolverNode) { // Ensure audio context and convolverNode are initialized
                convolverNode.buffer = generateReverbImpulseResponse(preset.duration, preset.decay, context);
                // Smoothly change the wet gain to avoid clicks
                wetGainNode.gain.setTargetAtTime(preset.wetMix, context.currentTime, 0.05); // 0.05s ramp
            } else if (context) { // If convolverNode isn't ready but context is, just set the gain
                // This branch is mostly for offline context where convolverNode might be created on the fly
                // and wetGainNode needs to be set directly.
                // For main context, convolverNode should always be ready after initAudioContext.
                wetGainNode.gain.value = preset.wetMix;
            }
        }

        /**
         * Toggles the reverb effect on or off.
         */
        function toggleReverb() {
            initAudioContext(); // Ensure audio context is ready
            const isEnabled = reverbToggle.checked;
            reverbSlider.disabled = !isEnabled;

            if (isEnabled) {
                // Apply current slider value
                applyReverbPreset(parseInt(reverbSlider.value));
            } else {
                // Smoothly set wet gain to 0 to turn off reverb
                if (audioCtx) {
                    wetGainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
                } else {
                    wetGainNode.gain.value = 0;
                }
                reverbSlider.value = 0; // Reset slider visual
                reverbValue.textContent = 'No Reverb';
            }
            updateSaveButtonState(); // Update save button state
        }

        /**
         * Applies the current bass boost setting to the bass filter node.
         */
        function applyBassBoost() {
            if (bassFilterNode && bassToggle.checked) {
                const gain = parseFloat(bassSlider.value);
                bassFilterNode.gain.value = gain;
                bassValue.textContent = `${gain} dB`;
            } else if (bassFilterNode) {
                bassFilterNode.gain.value = 0; // Reset to 0 dB gain
                bassValue.textContent = '0 dB';
            }
        }

        /**
         * Updates the bass boost based on the slider value.
         */
        function updateBassBoost() {
            applyBassBoost(); // Apply the current slider value
        }

        /**
         * Toggles the bass boost effect on or off.
         */
        function toggleBassBoost() {
            initAudioContext(); // Ensure audio context is initialized
            const isEnabled = bassToggle.checked;
            bassSlider.disabled = !isEnabled;
            applyBassBoost(); // Apply or reset bass boost based on toggle state
            updateSaveButtonState(); // Update save button state
        }

        /**
         * Applies the low pass filter effect based on the slider value.
         * Muffling percentage (0-100) maps to frequency (20000 Hz to 200 Hz logarithmically).
         */
        function applyLowPass() {
            if (lowpassFilterNode && lowpassToggle.checked) {
                const muffledPercentage = parseFloat(lowpassSlider.value);
                // Map 0-100% to frequency range (e.g., 20000 Hz down to 200 Hz)
                // Using a logarithmic scale for frequency to match human perception
                const minFreq = 200; // Hz (fully muffled)
                const maxFreq = audioCtx.sampleRate / 2; // Nyquist frequency, effectively transparent
                
                // Inverse logarithmic mapping: as slider goes up, frequency goes down
                const freq = maxFreq * Math.pow(minFreq / maxFreq, muffledPercentage / 100);
                
                lowpassFilterNode.frequency.value = freq;
                lowpassValue.textContent = `${muffledPercentage}%`;
            } else if (lowpassFilterNode) {
                // Reset to default (no muffling)
                lowpassFilterNode.frequency.value = audioCtx.sampleRate / 2;
                lowpassValue.textContent = '0%';
            }
        }

        /**
         * Updates the low pass filter based on the slider value.
         */
        function updateLowPass() {
            applyLowPass(); // Apply the current slider value
        }

        /**
         * Toggles the low pass filter effect on or off.
         */
        function toggleLowPass() {
            initAudioContext(); // Ensure audio context is initialized
            const isEnabled = lowpassToggle.checked;
            lowpassSlider.disabled = !isEnabled;
            applyLowPass(); // Apply or reset low pass filter based on toggle state
            updateSaveButtonState(); // Update save button state
        }

        /**
         * Applies the current Stereo Pan setting.
         */
        function applyPan() {
            if (pannerNode && panToggle.checked) {
                pannerNode.pan.value = parseFloat(panSlider.value);
                let panText = "Center";
                if (pannerNode.pan.value < -0.05) panText = "Left";
                else if (pannerNode.pan.value > 0.05) panText = "Right";
                panValue.textContent = panText;
            } else if (pannerNode) {
                pannerNode.pan.value = 0; // Reset to center
                panValue.textContent = "Center";
            }
        }

        /**
         * Updates the Stereo Pan based on the slider value.
         */
        function updatePan() {
            applyPan();
        }

        /**
         * Toggles the Stereo Pan effect on or off.
         */
        function togglePan() {
            initAudioContext();
            const isEnabled = panToggle.checked;
            panSlider.disabled = !isEnabled;
            applyPan(); // Apply or reset pan based on toggle state
            updateSaveButtonState();

            // ONLY re-route audio if a track is currently playing
            if (isPlaying && currentSourceNode) {
                // Disconnect currentSourceNode from its current connections to the main effect chain
                // (either directly or via pannerNode)
                try {
                    currentSourceNode.disconnect(bassFilterNode);
                    currentSourceNode.disconnect(convolverNode);
                } catch (e) { /* Expected error if not directly connected */ }
                
                // Disconnect pannerNode from its current connections to the main effect chain
                try {
                    pannerNode.disconnect(bassFilterNode);
                    pannerNode.disconnect(convolverNode);
                } catch (e) { /* Expected error if not connected */ }

                // Now, establish the new connections based on the toggle state
                if (isEnabled) {
                    // If pan is ON, route: currentSourceNode -> pannerNode -> (bassFilterNode, convolverNode)
                    currentSourceNode.connect(pannerNode);
                    pannerNode.connect(bassFilterNode);
                    pannerNode.connect(convolverNode);
                } else {
                    // If pan is OFF, route: currentSourceNode -> (bassFilterNode, convolverNode)
                    currentSourceNode.connect(bassFilterNode);
                    currentSourceNode.connect(convolverNode);
                }
            }
        }


        /**
         * Converts an AudioBuffer to a WAV Blob.
         * @param {AudioBuffer} audioBuffer - The AudioBuffer to convert.
         * @returns {Blob} The WAV Blob.
         */
        function exportWAV(audioBuffer) {
            const numOfChan = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // 1 = PCM
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;

            let buffer = new ArrayBuffer(44 + audioBuffer.length * numOfChan * bytesPerSample);
            let view = new DataView(buffer);

            /* RIFF identifier */
            writeString(view, 0, 'RIFF');
            /* file length */
            view.setUint32(4, 36 + audioBuffer.length * numOfChan * bytesPerSample, true);
            /* RIFF type */
            writeString(view, 8, 'WAVE');
            /* format chunk identifier */
            writeString(view, 12, 'fmt ');
            /* format chunk length */
            view.setUint32(16, 16, true);
            /* sample format (raw) */
            view.setUint16(20, format, true);
            /* channel count */
            view.setUint16(22, numOfChan, true);
            /* sample rate */
            view.setUint32(24, sampleRate, true);
            /* byte rate (sample rate * block align) */
            view.setUint32(28, sampleRate * numOfChan * bytesPerSample, true);
            /* block align (channel count * bytes per sample) */
            view.setUint16(32, numOfChan * bytesPerSample, true);
            /* bits per sample */
            view.setUint16(34, bitDepth, true);
            /* data chunk identifier */
            writeString(view, 36, 'data');
            /* data chunk length */
            view.setUint32(40, audioBuffer.length * numOfChan * bytesPerSample, true);

            // Write PCM data
            floatTo16BitPCM(view, 44, audioBuffer);

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function floatTo16BitPCM(output, offset, input) {
            const channels = [];
            for (let i = 0; i < input.numberOfChannels; i++) {
                channels.push(input.getChannelData(i));
            }

            for (let i = 0; i < input.length; i++) {
                for (let channel = 0; channel < input.numberOfChannels; channel++) {
                    let s = Math.max(-1, Math.min(1, channels[channel][i]));
                    s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    output.setInt16(offset, s, true);
                    offset += 2;
                }
            }
        }

        /**
         * Processes the current track with applied effects using OfflineAudioContext
         * and then triggers a download of the modified audio.
         */
        async function saveModifiedTrack() {
            if (currentTrackIndex === -1 || !playlist[currentTrackIndex] || !playlist[currentTrackIndex].audioBuffer) {
                console.warn("No track loaded to save.");
                return;
            }

            const originalBuffer = playlist[currentTrackIndex].audioBuffer;
            const originalDuration = originalBuffer.duration;

            const isPitchEnabled = pitchToggle.checked;
            const isTempoEnabled = tempoToggle.checked;
            const isReverbEnabled = reverbToggle.checked;
            const isBassEnabled = bassToggle.checked;
            const isLowPassEnabled = lowpassToggle.checked;
            const isPanEnabled = panToggle.checked;

            if (!isPitchEnabled && !isTempoEnabled && !isReverbEnabled && !isBassEnabled && !isLowPassEnabled && !isPanEnabled) {
                console.warn("No effects applied. Please enable at least one effect to save.");
                return;
            }

            // Change button text and disable during processing
            saveTrackButton.textContent = "Processing...";
            saveTrackButton.disabled = true;

            // Determine the output duration based on tempo
            const tempoFactor = isTempoEnabled ? parseFloat(tempoSlider.value) : 1.0;
            const outputDuration = originalDuration / tempoFactor;
            const offlineCtxLength = Math.ceil(outputDuration * originalBuffer.sampleRate);

            try {
                const offlineCtx = new OfflineAudioContext(
                    originalBuffer.numberOfChannels,
                    offlineCtxLength,
                    originalBuffer.sampleRate
                );

                const source = offlineCtx.createBufferSource();
                source.buffer = originalBuffer;
                source.detune.value = isPitchEnabled ? parseFloat(pitchSlider.value) : 0;
                source.playbackRate.value = tempoFactor;

                let currentNode = source; // This node feeds the next effect in the chain

                // --- Apply Stereo Pan Effect (if enabled) ---
                if (isPanEnabled) {
                    const offlinePanner = offlineCtx.createStereoPanner();
                    offlinePanner.pan.value = parseFloat(panSlider.value);
                    currentNode.connect(offlinePanner);
                    currentNode = offlinePanner;
                }
                
                // --- Core processing nodes (Bass, Compressor, Reverb, Lowpass) ---
                // These nodes are created here for the offline context, and connected from `currentNode`.

                const offlineBassFilter = offlineCtx.createBiquadFilter();
                offlineBassFilter.type = 'lowshelf';
                offlineBassFilter.frequency.value = 80;
                offlineBassFilter.gain.value = isBassEnabled ? parseFloat(bassSlider.value) : 0;

                const offlineCompressor = offlineCtx.createDynamicsCompressor();
                offlineCompressor.threshold.value = -24; 
                offlineCompressor.knee.value = 30;
                offlineCompressor.ratio.value = 10;     
                offlineCompressor.attack.value = 0.005;
                offlineCompressor.release.value = 0.15;

                const offlineLowpassFilter = offlineCtx.createBiquadFilter();
                offlineLowpassFilter.type = 'lowpass';
                offlineLowpassFilter.Q.value = 1;
                if (isLowPassEnabled) {
                    const muffledPercentage = parseFloat(lowpassSlider.value);
                    const minFreq = 200; 
                    const maxFreq = offlineCtx.sampleRate / 2;
                    const freq = maxFreq * Math.pow(minFreq / maxFreq, muffledPercentage / 100);
                    offlineLowpassFilter.frequency.value = freq;
                } else {
                    offlineLowpassFilter.frequency.value = offlineCtx.sampleRate / 2;
                }

                const offlineConvolver = offlineCtx.createConvolver();
                const offlineWetGain = offlineCtx.createGain();
                if (isReverbEnabled) {
                    const reverbPresetIndex = parseInt(reverbSlider.value);
                    const presets = [
                        { wetMix: 0.0, duration: 0.1, decay: 0.1, label: "No Reverb" },
                        { wetMix: 0.15, duration: 0.4, decay: 1.5, label: "Bathroom" },
                        { wetMix: 0.30, duration: 1.0, decay: 2.0, label: "Large Room" },
                        { wetMix: 0.45, duration: 2.0, decay: 2.5, label: "Concert Hall" },
                        { wetMix: 0.60, duration: 3.5, decay: 3.0, label: "Cathedral" },
                        { wetMix: 0.75, duration: 4.5, decay: 3.5, label: "Maximum Reverb" }
                    ];
                    const preset = presets[reverbPresetIndex];
                    offlineConvolver.buffer = generateReverbImpulseResponse(preset.duration, preset.decay, offlineCtx);
                    offlineWetGain.gain.value = preset.wetMix;
                } else {
                    offlineWetGain.gain.value = 0;
                }

                // Connect the dry path: currentNode -> Bass -> Compressor -> LowpassFilter
                currentNode.connect(offlineBassFilter);
                offlineBassFilter.connect(offlineCompressor);
                offlineCompressor.connect(offlineLowpassFilter); // Dry path goes to LPF

                // Connect the wet path: currentNode -> Convolver -> Wet Gain -> LowpassFilter
                currentNode.connect(offlineConvolver);
                offlineConvolver.connect(offlineWetGain);
                offlineWetGain.connect(offlineLowpassFilter); // Wet path also goes to LPF

                // Final connection to destination
                offlineLowpassFilter.connect(offlineCtx.destination);

                source.start(0);
                const renderedBuffer = await offlineCtx.startRendering();

                const wavBlob = exportWAV(renderedBuffer); // Get the Blob
                const url = URL.createObjectURL(wavBlob); // Create an Object URL from the Blob

                // Trigger download using the Object URL
                const a = document.createElement('a');
                a.href = url;
                a.download = `${playlist[currentTrackIndex].title}_modified.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Clean up the URL

            } catch (error) {
                console.error("Error processing audio for saving:", error);
                // Provide user feedback on error
                saveTrackButton.textContent = "Save Failed!";
                setTimeout(() => {
                    updateSaveButtonState(); // Revert button state after a short delay
                }, 3000);
            } finally {
                // Revert button text and enable it if not already handled by error
                if (saveTrackButton.textContent === "Processing...") {
                    saveTrackButton.textContent = "Save Track";
                    updateSaveButtonState(); // Re-evaluate state based on toggles
                }
            }
        }

        /**
         * Parses LRC content into an array of lyric objects.
         * @param {string} lrcContent - The raw content of an LRC file.
         * @returns {Array<Object>} An array of { time: number, text: string } objects.
         */
        function parseLRC(lrcContent) {
            const lines = lrcContent.split('\n');
            const lyrics = [];
            const timeTagRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g; // Matches [mm:ss.xx] or [mm:ss.xxx]

            lines.forEach(line => {
                const matches = [...line.matchAll(timeTagRegex)]; // Use spread to get all matches
                if (matches.length > 0) {
                    const lyricText = line.replace(timeTagRegex, '').trim();
                    matches.forEach(match => {
                        const minutes = parseInt(match[1], 10);
                        const seconds = parseInt(match[2], 10);
                        let milliseconds = parseInt(match[3], 10);

                        // Handle two-digit milliseconds (e.g., .01) by multiplying by 10
                        if (match[3].length === 2) {
                            milliseconds *= 10;
                        }

                        const timeInSeconds = minutes * 60 + seconds + milliseconds / 1000;
                        lyrics.push({ time: timeInSeconds, text: lyricText });
                    });
                }
            });

            // Sort lyrics by time to ensure correct order
            lyrics.sort((a, b) => a.time - b.time);
            return lyrics;
        }

        /**
         * Renders lyrics to the display and sets up for synchronization.
         * @param {Array<Object>|null} lyrics - Array of { time, text } or null if no lyrics.
         */
        function displayLyrics(lyrics) {
            lyricsDisplay.innerHTML = ''; // Clear previous lyrics
            currentLyricIndex = -1; // Reset highlight

            if (!lyrics || lyrics.length === 0) {
                lyricsDisplay.innerHTML = `
                    <p class="no-lyrics-message">No lyrics found for this track.</p>
                    <button id="upload-lrc-button" class="player-button upload-lrc-button">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" fill="white" width="20" height="20" style="margin-right: 0.5rem; display:none;">
                            <path d="M144 0H248c22.1 0 40 17.9 40 40v48c0 22.1-17.9 40-40 40H144c-22.1 0-40-17.9-40-40V40c0-22.1 17.9-40 40-40zm-48 96H288V416c0 35.3-28.7 64-64 64H160c-35.3 0-64-28.7-64-64V96zM64 416c0 70.7 57.3 128 128 128s128-57.3 128-128V96H384V416c0 97.2-78.8 176-176 176S32 513.2 32 416V96H64V416z"/>
                        </svg>
                        Upload LRC
                    </button>
                    <input type="file" id="lrc-upload-input" accept=".lrc">
                `;
                // Add class to center content when no lyrics
                lyricsDisplay.classList.add('centered-content');

                // IMPORTANT: Re-attach event listeners after recreating elements
                const uploadLrcButton = document.getElementById('upload-lrc-button');
                const lrcUploadInput = document.getElementById('lrc-upload-input');

                if (uploadLrcButton && lrcUploadInput) {
                    uploadLrcButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent click from bubbling to lyricsPanel and toggling back
                        lrcUploadInput.click();
                    });
                    lrcUploadInput.addEventListener('change', handleLrcUpload);
                }
            } else {
                // Remove class to align content to flex-start when lyrics are present
                lyricsDisplay.classList.remove('centered-content');
                lyrics.forEach((line, index) => {
                    const p = document.createElement('p');
                    p.className = 'lyrics-line';
                    p.textContent = line.text;
                    p.dataset.time = line.time; // Store time for syncing
                    p.dataset.index = index; // Store index for highlighting
                    lyricsDisplay.appendChild(p);
                });
            }
            // Always scroll to top when displaying new lyrics (or no lyrics message)
            lyricsDisplay.scrollTop = 0;
        }

        /**
         * Synchronizes lyrics with the current playback time.
         */
        function syncLyrics() {
            if (!isPlaying || !currentSourceNode || !currentSourceNode.buffer || !playlist[currentTrackIndex] || !playlist[currentTrackIndex].lyrics) {
                return;
            }

            const currentLyrics = playlist[currentTrackIndex].lyrics;
            const currentPositionInOriginalTime = currentPlaybackOffset + (audioCtx.currentTime - playbackStartTime) * currentSourceNode.playbackRate.value;

            // Find the current lyric line
            let newLyricIndex = -1;
            for (let i = 0; i < currentLyrics.length; i++) {
                // Check if the current time is greater than or equal to the lyric's start time
                // and less than the next lyric's start time (or end of lyrics)
                if (currentPositionInOriginalTime >= currentLyrics[i].time &&
                    (i + 1 === currentLyrics.length || currentPositionInOriginalTime < currentLyrics[i+1].time)) {
                    newLyricIndex = i;
                    break;
                }
            }

            if (newLyricIndex !== currentLyricIndex) {
                // Remove active class from previous lyric
                if (currentLyricIndex !== -1) {
                    const prevLyricElement = lyricsDisplay.querySelector(`[data-index="${currentLyricIndex}"]`);
                    if (prevLyricElement) {
                        prevLyricElement.classList.remove('active');
                    }
                }

                // Add active class to new lyric
                if (newLyricIndex !== -1) {
                    const newLyricElement = lyricsDisplay.querySelector(`[data-index="${newLyricIndex}"]`);
                    if (newLyricElement) {
                        newLyricElement.classList.add('active');
                        
                        // Manually scroll to center the newLyricElement within lyricsDisplay
                        const containerHeight = lyricsDisplay.clientHeight;
                        const elementHeight = newLyricElement.clientHeight;
                        const elementOffsetTop = newLyricElement.offsetTop; // Relative to lyricsDisplay's scroll top

                        // Calculate the scroll position to center the element
                        // This formula places the element's middle at the container's middle
                        const scrollTo = elementOffsetTop - (containerHeight / 2) + (elementHeight / 2);

                        // Apply the scroll smoothly
                        lyricsDisplay.scrollTo({
                            top: scrollTo,
                            behavior: 'smooth'
                        });
                    }
                }
                currentLyricIndex = newLyricIndex;
            }
        }

        /**
         * Handles the upload of an LRC file.
         * @param {Event} event - The change event from the file input.
         */
        async function handleLrcUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (currentTrackIndex === -1) {
                showUploadError("Please load a music track first before uploading lyrics.");
                return;
            }

            try {
                const lrcContent = await file.text(); // This reads the file content
                const parsedLyrics = parseLRC(lrcContent); // This parses the content

                // Store lyrics with the current track
                playlist[currentTrackIndex].lyrics = parsedLyrics;
                displayLyrics(parsedLyrics); // Display the newly loaded lyrics
                
            } catch (error) {
                console.error("Error loading or parsing LRC file:", error);
                showUploadError("Failed to load LRC file. Please check the file format.");
                // Re-display the upload prompt if parsing failed
                displayLyrics(null); // This will re-render the "No lyrics" message and button
            } finally {
                // Clear the file input value so that selecting the same file again triggers change event
                event.target.value = ''; // Use event.target.value to clear the specific input
            }
        }


        // --- Event Listeners ---

        // Play/Pause button click
        playPauseButton.addEventListener('click', playPause);

        // Previous button click
        prevButton.addEventListener('click', prevTrack);

        // Next button click
        nextButton.addEventListener('click', nextTrack);

        // Loop button click
        loopButton.addEventListener('click', toggleLoop);

        // Shuffle button click
        shuffleButton.addEventListener('click', toggleShuffle);

        // Seekbar input (while dragging) and change (after release)
        seekbar.addEventListener('input', seekTo);

        // Clear playlist button
        clearPlaylistButton.addEventListener('click', clearPlaylist);

        // Handle music file upload
        uploadButton.addEventListener('click', () => {
            musicUploadInput.click(); // Trigger the hidden file input click
        });

        musicUploadInput.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files); // Convert FileList to Array
            if (files.length === 0) return;

            // Hide any previous error message
            uploadErrorMessage.classList.add('hidden');

            // Initialize audio context on user interaction
            initAudioContext();

            // Process files sequentially to ensure metadata is read before audio decoding
            const newTracks = [];
            for (const file of files) {
                const fileURL = URL.createObjectURL(file);
                let title = file.name.replace(/\.[^/.]+$/, ""); // Default title
                let artist = "Unknown Artist"; // Default artist
                let artworkDataURL = null; // Default artwork
                let lyrics = null; // Initialize lyrics for the track

                try {
                    const tags = await new Promise((resolve, reject) => {
                        jsmediatags.read(file, {
                            onSuccess: function(tag) {
                                resolve(tag);
                            },
                            onError: function(error) {
                                console.warn("Error reading metadata for", file.name, ":", error);
                                resolve(null); // Resolve with null if error, so processing continues
                            }
                        });
                    });

                    if (tags && tags.tags) {
                        if (tags.tags.title) {
                            title = tags.tags.title;
                        }
                        if (tags.tags.artist) {
                            artist = tags.tags.artist;
                        }
                        if (tags.tags.picture) {
                            const picture = tags.tags.picture;
                            let base64String = "";
                            for (let i = 0; i < picture.data.length; i++) {
                                base64String += String.fromCharCode(picture.data[i]);
                            }
                            artworkDataURL = `data:${picture.format};base64,${btoa(base64String)}`;
                        }
                    }
                } catch (error) {
                    console.error("Unexpected error during metadata reading:", error);
                }

                newTracks.push({
                    title: title,
                    artist: artist,
                    src: fileURL,
                    duration: 0, // Duration will be updated after decoding
                    audioBuffer: null, // Placeholder for decoded audio buffer
                    artwork: artworkDataURL, // Store artwork data URL
                    lyrics: lyrics // Store lyrics (initially null)
                });
            }

            if (files.length === 1) {
                // Scenario 1: Single file upload (add to queue if space allows)
                if (playlist.length >= MAX_TRACKS) {
                    showUploadError(`Cannot add "${files[0].name}". Playlist is full (max ${MAX_TRACKS} tracks).`);
                    return;
                }
                playlist.push(newTracks[0]);
                updatePlaylistUI();
                if (!isPlaying && playlist.length === 1) {
                    await loadTrack(0);
                } else if (!isPlaying && currentTrackIndex === -1 && playlist.length > 0) {
                    await loadTrack(0);
                }
            } else {
                // Scenario 2: Multiple file upload (replace queue, capped at MAX_TRACKS)
                let filesToProcess = newTracks;
                if (newTracks.length > MAX_TRACKS) {
                    showUploadError(`Cannot upload more than ${MAX_TRACKS} tracks. Only the first ${MAX_TRACKS} will be loaded.`);
                    filesToProcess = newTracks.slice(0, MAX_TRACKS); // Slice files to the maximum allowed
                }

                // Stop current playback and clear existing playlist
                pauseTrack();
                playlist = filesToProcess;
                currentTrackIndex = -1;
                
                updatePlaylistUI();
                if (playlist.length > 0) {
                    await loadTrack(0); // Load and play the first track automatically
                } else {
                    // Reset UI if no tracks were added (e.g., if files.length was 0 after slicing)
                    artwork.src = 'https://placehold.co/300x300/333333/FFFFFF?text=No+Artwork';
                    trackTitle.textContent = 'No Song Loaded';
                    artistName.textContent = 'Upload music to start';
                    currentTimeSpan.textContent = '00:00';
                    totalTimeSpan.textContent = '00:00';
                    seekbar.value = 0;
                    updatePlayPauseButton();
                }
            }
            // Clear the file input value so that selecting the same file(s) again triggers change event
            musicUploadInput.value = '';
            updateSaveButtonState(); // Update save button state after new tracks are loaded
        });


        // Effects panel event listeners
        pitchToggle.addEventListener('change', togglePitch);
        pitchSlider.addEventListener('input', updatePitch);
        tempoToggle.addEventListener('change', toggleTempo); 
        tempoSlider.addEventListener('input', updateTempo);
        reverbToggle.addEventListener('change', toggleReverb);
        reverbSlider.addEventListener('input', () => applyReverbPreset(parseInt(reverbSlider.value)));
        // Bass Boost event listeners
        bassToggle.addEventListener('change', toggleBassBoost);
        bassSlider.addEventListener('input', updateBassBoost);
        // New Low Pass Filter event listeners
        lowpassToggle.addEventListener('change', toggleLowPass);
        lowpassSlider.addEventListener('input', updateLowPass);
        // New Stereo Pan event listeners
        panToggle.addEventListener('change', togglePan);
        panSlider.addEventListener('input', updatePan);


        // Save track button listener
        saveTrackButton.addEventListener('click', saveModifiedTrack);

        // Artwork click to show lyrics
        artwork.addEventListener('click', () => {
            if (currentTrackIndex !== -1 && playlist[currentTrackIndex]) {
                displayLyrics(playlist[currentTrackIndex].lyrics);
                // Set background image on the new overlay div
                const currentArtworkSrc = artwork.src;
                if (currentArtworkSrc && !currentArtworkSrc.includes('No+Artwork')) {
                    lyricsBackgroundOverlay.style.backgroundImage = `url('${currentArtworkSrc}')`;
                } else {
                    lyricsBackgroundOverlay.style.backgroundImage = ''; // Clear if no valid artwork
                }
            } else {
                displayLyrics(null); // No track loaded, show "No lyrics found"
                lyricsBackgroundOverlay.style.backgroundImage = ''; // Clear background
            }
            artwork.classList.add('hidden-artwork'); // Fade out artwork
            lyricsPanel.classList.add('show'); // Fade in lyrics panel
        });

        // Lyrics panel click to hide lyrics and show artwork
        lyricsPanel.addEventListener('click', (event) => {
            // Prevent clicks on the upload button from bubbling to lyricsPanel and toggling back
            if (event.target.closest('.upload-lrc-button') || event.target.closest('#lrc-upload-input')) {
                return;
            }
            lyricsPanel.classList.remove('show'); // Fade out lyrics panel
            artwork.classList.remove('hidden-artwork'); // Fade in artwork
            lyricsBackgroundOverlay.style.backgroundImage = ''; // Clear background image on overlay
        });


        // Initial UI setup
        updatePlayPauseButton();
        updateLoopButton();
        updateShuffleButton();
        updatePlaylistUI(); // This will show "No tracks uploaded yet." initially

        // Ensure lyrics panel is hidden and artwork is visible on initial load
        lyricsPanel.classList.remove('show');
        artwork.classList.remove('hidden-artwork');
        lyricsBackgroundOverlay.style.backgroundImage = ''; // Ensure cleared on load


        // Initial state for effects panel
        togglePitch(); // Set initial slider state for pitch
        toggleTempo(); // Set initial slider state for tempo
        toggleReverb(); // Set initial slider state for reverb
        toggleBassBoost(); // Set initial slider state for bass boost
        toggleLowPass(); // Set initial slider state for low pass filter
        togglePan(); // Set initial state for pan
        updateSaveButtonState(); // Set initial state for save button
</script>
</div>
</body>
</html>
